<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如果一切重来</title>
  <subtitle>小小程序员的成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaoybboy.github.io/"/>
  <updated>2017-04-13T01:56:04.586Z</updated>
  <id>https://xiaoybboy.github.io/</id>
  
  <author>
    <name>Blithe Shaw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么新生代需要两个Survivor区</title>
    <link href="https://xiaoybboy.github.io/2017/04/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B0%E7%94%9F%E4%BB%A3%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AASurvivor%E5%8C%BA/"/>
    <id>https://xiaoybboy.github.io/2017/04/12/为什么新生代需要两个Survivor区/</id>
    <published>2017-04-12T14:14:32.000Z</published>
    <updated>2017-04-13T01:56:04.586Z</updated>
    
    <content type="html"><![CDATA[<p>在JVM的新生代内存中，为什么除了Eden区，还要设置两个Survivor区？</p>
<h1 id="为什么要有Survivor区"><a href="#为什么要有Survivor区" class="headerlink" title="为什么要有Survivor区"></a>为什么要有Survivor区</h1><p>先不去想为什么有两个Survivor区，第一个问题是，设置Survivor区的意义在哪里？<br><a id="more"></a><br>堆内存分类<br><img src="http://i.imgur.com/SYmUFnA.png" alt="堆内存分类"><br>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。你也许会问，执行时间长有什么坏处？频发的Full GC消耗的时间是非常可观的，这一点会影响大型程序的执行和响应速度，更不要说某些连接会因为超时发生连接错误了。</p>
<p>好，那我们来想想在没有Survivor的情况下，有没有什么解决办法，可以避免上述情况：<br><img src="http://i.imgur.com/e1qd82c.png" alt=""><br>显而易见，没有Survivor的话，上述两种解决方案都不能从根本上解决问题。</p>
<p>我们可以得到第一条结论：<font color="red" size="4"><strong>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</strong></font></p>
<h1 id="为什么要设置两个Survivor区"><a href="#为什么要设置两个Survivor区" class="headerlink" title="为什么要设置两个Survivor区"></a>为什么要设置两个Survivor区</h1><font color="red" size="4"><strong>设置两个Survivor区最大的好处就是解决了碎片化</strong></font>

<p>下面我们来分析一下。</p>
<p>为什么一个Survivor区不行？第一部分中，我们知道了必须设置Survivor区。假设现在只有一个survivor区，我们来模拟一下流程：<br>刚刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，下一次Eden满了的时候，问题来了，此时进行Minor GC，Eden和Survivor各有一些存活对象，如果此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。<br>我绘制了一幅图来表明这个过程。其中色块代表对象，白色框分别代表Eden区（大）和Survivor区（小）。Eden区理所当然大一些，否则新建对象很快就导致Eden区满，进而触发Minor GC，有悖于初衷。<br><img src="http://i.imgur.com/NmSEUK3.png" alt=""><br>一个Survivor区带来碎片化</p>
<p>碎片化带来的风险是极大的，严重影响Java程序的性能。堆空间被散布的对象占据不连续的内存，最直接的结果就是，堆中没有足够大的连续内存空间，接下去如果程序需要给一个内存需求很大的对象分配内存。。。画面太美不敢看。。。这就好比我们爬山的时候，背包里所有东西紧挨着放，最后就可能省出一块完整的空间放相机。如果每件行李之间隔一点空隙乱放，很可能最后就要一路把相机挂在脖子上了。</p>
<p>那么，顺理成章的，应该建立两块Survivor区，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。下图中每部分的意义和上一张图一样，就不加注释了。<br><img src="http://i.imgur.com/Y0x3nl1.png" alt=""><br>两块Survivor避免碎片化<br>上述机制最大的好处就是，整个过程中，永远有一个survivor space是空的，另一个非空的survivor space无碎片。</p>
<p>那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满，因此，我认为两块Survivor区是经过权衡之后的最佳方案。</p>
<p>转自：<a href="http://blog.csdn.net/antony9118/article/details/51425581" target="_blank" rel="external">http://blog.csdn.net/antony9118/article/details/51425581</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JVM的新生代内存中，为什么除了Eden区，还要设置两个Survivor区？&lt;/p&gt;
&lt;h1 id=&quot;为什么要有Survivor区&quot;&gt;&lt;a href=&quot;#为什么要有Survivor区&quot; class=&quot;headerlink&quot; title=&quot;为什么要有Survivor区&quot;&gt;&lt;/a&gt;为什么要有Survivor区&lt;/h1&gt;&lt;p&gt;先不去想为什么有两个Survivor区，第一个问题是，设置Survivor区的意义在哪里？&lt;br&gt;
    
    </summary>
    
      <category term="java虚拟机" scheme="https://xiaoybboy.github.io/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java虚拟机" scheme="https://xiaoybboy.github.io/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="垃圾回收" scheme="https://xiaoybboy.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法详解</title>
    <link href="https://xiaoybboy.github.io/2017/04/11/%E5%9B%9E%E6%9C%94%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://xiaoybboy.github.io/2017/04/11/回朔算法详解/</id>
    <published>2017-04-11T03:47:08.000Z</published>
    <updated>2017-04-11T04:32:56.989Z</updated>
    
    <content type="html"><![CDATA[<p>刷题的时候碰到一个很常见的算法-回溯法，看了一些博客，感觉这个讲得通俗易懂。转过来，后面有些自己的补充。<br>&emsp;&emsp;回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。<br><a id="more"></a><br>首先我们来看一道题目：<br>Combinations：Given two integers n and k,return all possible combinations of k numbersout of 1 … n. For example, If n = 4 and k =2, a solution is:</p>
<p>[<br> [2,4],<br> [3,4],<br> [2,3],<br> [1,2],<br> [1,3],<br> [1,4],<br>]<br>（做一个白话版的描述，给你两个整数 n和k，从1-n中选择k个数字的组合。比如n=4，那么从1,2,3,4中选取两个数字的组合，包括图上所述的四种。）<br>然后我们看看题目给出的框架：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要求返回的类型是List<list<integer>&gt; 也就是说将所有可能的组合list（由整数构成）放入另一个list（由list构成）中。<br>现在进行套路教学：要求返回List<list<integer>&gt;，那我就给你一个List<list<integer>&gt;，因此</list<integer></list<integer></list<integer></p>
<ol>
<li>定义一个全局List<list<integer>&gt; result=new ArrayList<list<integer>&gt;();</list<integer></list<integer></li>
<li>定义一个辅助的方法（函数）public void backtracking(int n,int k, List<integer>list){}<br>n k 总是要有的吧，加上这两个参数，前面提到List<integer> 是数字的组合，也是需要的吧，这三个是必须的，没问题吧。（可以尝试性地写参数，最后不需要的删除）</integer></integer></li>
<li>接着就是我们的重头戏了，如何实现这个算法？对于n=4，k=2，1,2,3,4中选2个数字，我们可以做如下尝试，加入先选择1，那我们只需要再选择一个数字，注意这时候k=1了（此时只需要选择1个数字啦）。当然，我们也可以先选择2,3 或者4，通俗化一点，我们可以选择（1-n）的所有数字，这个是可以用一个循环来描述？每次选择一个加入我们的链表list中，下一次只要再选择k-1个数字。那什么时候结束呢？当然是k<0的时候啦，这时候都选完了。 有了上面的分析，我们可以开始填写public="" void="" backtracking(int="" n,int="" k,="" list<integer=""> list){}中的内容。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> start,List&lt;Integer&gt; list)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>)    <span class="keyword">return</span>;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;  <span class="comment">//k==0表示已经找到了k个数字的组合，这时候加入全局result中  </span></div><div class="line">            result.add(<span class="keyword">new</span> ArrayList(list));  </div><div class="line">        &#125;<span class="keyword">else</span>&#123;  </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)&#123;  </div><div class="line">                list.add(i);<span class="comment">//尝试性的加入i  </span></div><div class="line">                <span class="comment">//开始回溯啦，下一次要找的数字减少一个所以用k-1，i+1见后面分析  </span></div><div class="line">                backtracking(n,k-<span class="number">1</span>,i+<span class="number">1</span>,list);  </div><div class="line">                <span class="comment">//（留白，有用=。=）  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</0的时候啦，这时候都选完了。></li>
</ol>
<p>观察一下上述代码，我们加入了一个start变量，它是i的起点。为什么要加入它呢？比如我们第一次加入了1，下一次搜索的时候还能再搜索1了么？肯定不可以啊！我们必须从他的下一个数字开始，也就是2 、3或者4啦。所以start就是一个开始标记这个很重要啦！<br>这时候我们在主方法中加入backtracking(n,k,1,list);调试后发现答案不对啊！为什么我的答案比他长那么多？</p>
<p>回溯回溯当然要退回再走啦，你不退回，当然又臭又长了！所以我们要在刚才代码注释留白处加上退回语句。仔细分析刚才的过程，我们每次找到了1,2这一对答案以后，下一次希望2退出然后让3进来，1 3就是我们要找的下一个组合。如果不回退，找到了2 ，3又进来，找到了3，4又进来，所以就出现了我们的错误答案。正确的做法就是加上：list.remove(list.size()-1);他的作用就是每次清除一个空位 让后续元素加入。寻找成功，最后一个元素要退位，寻找不到，方法不可行，那么我们回退，也要移除最后一个元素。<br>所以完整的程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </div><div class="line">   List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();  </div><div class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;  </div><div class="line">       List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </div><div class="line">       backtracking(n,k,<span class="number">1</span>,list);  </div><div class="line">       <span class="keyword">return</span> result;  </div><div class="line">    &#125;  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> start,List&lt;Integer&gt;list)</span></span>&#123;  </div><div class="line">       <span class="keyword">if</span>(k&lt;<span class="number">0</span>) <span class="keyword">return</span> ;  </div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;  </div><div class="line">           result.add(<span class="keyword">new</span> ArrayList(list));  </div><div class="line">       &#125;<span class="keyword">else</span>&#123;  </div><div class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)&#123;  </div><div class="line">                list.add(i);  </div><div class="line">                backtracking(n,k-<span class="number">1</span>,i+<span class="number">1</span>,list);  </div><div class="line">                list.remove(list.size()-<span class="number">1</span>);  </div><div class="line">            &#125;  </div><div class="line">       &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是不是有点想法了？那么我们操刀一下。<br>Combination Sum<br>Given a set ofcandidate numbers (C) and a target number (T), findall unique combinations in C where thecandidate numbers sums toT.<br>The same repeated numbermay be chosen from C unlimited numberof times.<br>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>For example,given candidate set [2, 3, 6, 7] and target 7,<br>A solution set is:<br>[<br> [7],<br> [2,2, 3]<br>]<br>（容我啰嗦地白话下，给你一个正数数组candidate[],一个目标值target，寻找里面所有的不重复组合，让其和等于target，给你[2,3,6,7] 2+2+3=7 ,7=7,所以可能组合为[2,2,3],[7]）<br>按照前述的套路走一遍：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target) &#123;</div><div class="line">       Arrays.sort(candidates);</div><div class="line">       List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,)</span></span>&#123;       </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>全局List<list<integer>&gt; result先定义</list<integer></li>
<li>回溯backtracking方法要定义，数组candidates 目标target 开头start 辅助链表List<integer> list都加上。</integer></li>
<li>分析算法：以[2,3,6,7]  每次尝试加入数组任何一个值，用循环来描述，表示依次选定一个值<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(inti=start;i&lt;candidates.length;i++)&#123;</div><div class="line">       list.add(candidates[i]);</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>接下来回溯方法再调用。比如第一次选了2，下次还能再选2是吧，所以每次start都可以从当前i开始（ps：如果不允许重复，从i+1开始）。第一次选择2，下一次要凑的数就不是7了，而是7-2，也就是5，一般化就是remain=target-candidates[i],所以回溯方法为：<br>backtracking(candidates,target-candidates[i],i,list);<br>然后加上退回语句：list.remove(list.size()-1);<br>那么什么时候找到的解符合要求呢？自然是remain（注意区分初始的target）=0了，表示之前的组合恰好能凑出target。如果remain<0 表示凑的数太大了，组合不可行，要回退。当remain="">0 说明凑的还不够，继续凑。<br>所以完整方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </div><div class="line">    List&lt;List&lt;Integer&gt;&gt; result=newArrayList&lt;List&lt;Integer&gt;&gt;();  </div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt;combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;  </div><div class="line">        Arrays.sort(candidates);<span class="comment">//所给数组可能无序，排序保证解按照非递减组合  </span></div><div class="line">        List&lt;Integer&gt; list=newArrayList&lt;Integer&gt;();  </div><div class="line">        backtracking(candidates,target,<span class="number">0</span>,list);<span class="comment">//给定target，start=0表示从数组第一个开始  </span></div><div class="line">        <span class="keyword">return</span> result;<span class="comment">//返回解的组合链表  </span></div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[]candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,List&lt;Integer&gt; list)</span></span>&#123;  </div><div class="line">         </div><div class="line">            <span class="keyword">if</span>(target&lt;<span class="number">0</span>)    <span class="keyword">return</span>;<span class="comment">//凑过头了  </span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;  </div><div class="line">                result.add(newArrayList&lt;&gt;(list));<span class="comment">//正好凑出答案，开心地加入解的链表    </span></div><div class="line">            &#125;<span class="keyword">else</span>&#123;  </div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.length;i++)&#123;<span class="comment">//循环试探每个数  </span></div><div class="line">                    list.add(candidates[i]);<span class="comment">//尝试加入  </span></div><div class="line">           			<span class="comment">//下一次凑target-candidates[i]，允许重复，还是从i开始  </span></div><div class="line">                   backtracking(candidates,target-candidates[i],i,list);                     </div><div class="line">           		   list.remove(list.size()-<span class="number">1</span>);<span class="comment">//回退  </span></div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">         </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></0></p>
<p>是不是觉得还是有迹可循的？下一篇博客将部分回溯算法拿出来，供大家更好地发现其中的套路。<br>This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.</p>
<p>Subsets : <a href="https://leetcode.com/problems/subsets/" target="_blank" rel="external">https://leetcode.com/problems/subsets/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</div><div class="line">        tempList.add(nums[i]);</div><div class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</div><div class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Subsets II (contains duplicates) : <a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="external">https://leetcode.com/problems/subsets-ii/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></div><div class="line">        tempList.add(nums[i]);</div><div class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</div><div class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Permutations : <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="external">https://leetcode.com/problems/permutations/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">   List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">   <span class="comment">// Arrays.sort(nums); // not necessary</span></div><div class="line">   backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</div><div class="line">   <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums)</span></span>&#123;</div><div class="line">   <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</div><div class="line">      list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">   &#125; <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123; </div><div class="line">         <span class="keyword">if</span>(tempList.contains(nums[i])) <span class="keyword">continue</span>; <span class="comment">// element already exists, skip</span></div><div class="line">         tempList.add(nums[i]);</div><div class="line">         backtrack(list, tempList, nums);</div><div class="line">         tempList.remove(tempList.size() - <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Permutations II (contains duplicates) : <a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="external">https://leetcode.com/problems/permutations-ii/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">boolean</span> [] used)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</div><div class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</div><div class="line">            used[i] = <span class="keyword">true</span>; </div><div class="line">            tempList.add(nums[i]);</div><div class="line">            backtrack(list, tempList, nums, used);</div><div class="line">            used[i] = <span class="keyword">false</span>; </div><div class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Combination Sum : <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="external">https://leetcode.com/problems/combination-sum/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">    <span class="keyword">else</span>&#123; </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</div><div class="line">            tempList.add(nums[i]);</div><div class="line">            backtrack(list, tempList, nums, remain - nums[i], i); <span class="comment">// not i + 1 because we can reuse same elements</span></div><div class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Combination Sum II (can’t reuse same element) : <a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="external">https://leetcode.com/problems/combination-sum-ii/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></div><div class="line">            tempList.add(nums[i]);</div><div class="line">            backtrack(list, tempList, nums, remain - nums[i], i + <span class="number">1</span>);</div><div class="line">            tempList.remove(tempList.size() - <span class="number">1</span>); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Palindrome Partitioning : <a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="external">https://leetcode.com/problems/palindrome-partitioning/</a></p>
<pre><code class="java"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) {
   List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();
   backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), s, <span class="number">0</span>);
   <span class="keyword">return</span> list;
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, <span class="keyword">int</span> start)</span></span>{
   <span class="keyword">if</span>(start == s.length())
      list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));
   <span class="keyword">else</span>{
      <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.length(); i++){
         <span class="keyword">if</span>(isPalindrome(s, start, i)){
            tempList.add(s.substring(start, i + <span class="number">1</span>));
            backtrack(list, tempList, s, i + <span class="number">1</span>);
            tempList.remove(tempList.size() - <span class="number">1</span>);
         }
      }
   }
}

<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>{
   <span class="keyword">while</span>(low &lt; high)
      <span class="keyword">if</span>(s.charAt(low++) != s.charAt(high--)) <span class="keyword">return</span> <span class="keyword">false</span>;
   <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题的时候碰到一个很常见的算法-回溯法，看了一些博客，感觉这个讲得通俗易懂。转过来，后面有些自己的补充。&lt;br&gt;&amp;emsp;&amp;emsp;回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯法" scheme="https://xiaoybboy.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java源码之StringBuffer,StringBuilder</title>
    <link href="https://xiaoybboy.github.io/2017/04/10/Java%E6%BA%90%E7%A0%81%E4%B9%8BStringBuffer-StringBuilder/"/>
    <id>https://xiaoybboy.github.io/2017/04/10/Java源码之StringBuffer-StringBuilder/</id>
    <published>2017-04-10T05:24:17.000Z</published>
    <updated>2017-04-13T01:41:30.427Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java源码" scheme="https://xiaoybboy.github.io/categories/java%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="java源码" scheme="https://xiaoybboy.github.io/tags/java%E6%BA%90%E7%A0%81/"/>
    
      <category term="StringBuffer" scheme="https://xiaoybboy.github.io/tags/StringBuffer/"/>
    
      <category term="StringBuilder" scheme="https://xiaoybboy.github.io/tags/StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>Java源码之HashSet</title>
    <link href="https://xiaoybboy.github.io/2017/04/07/Java%E6%BA%90%E7%A0%81%E4%B9%8BHashSet/"/>
    <id>https://xiaoybboy.github.io/2017/04/07/Java源码之HashSet/</id>
    <published>2017-04-07T03:10:20.000Z</published>
    <updated>2017-04-08T01:35:21.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>1.HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序，特别是它不保证该顺序恒久不变。而且HashSet允许使用 null 元素。<br>2.HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” Set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</div></pre></td></tr></table></figure></p>
<p>3.HashSet通过iterator()返回的迭代器是fail-fast的。<br>4.HashSet的继承关系如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;  </span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;  </div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure></p>
<h1 id="HashSet实现"><a href="#HashSet实现" class="headerlink" title="HashSet实现"></a>HashSet实现</h1><p>HashSet是基于HashMap实现的，底层使用HashMap来保存所有元素，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成.</p>
<h2 id="HashSet属性"><a href="#HashSet属性" class="headerlink" title="HashSet属性"></a>HashSet属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </div><div class="line"><span class="number">2</span>.	  <span class="comment">// Dummy value to associate with an Object in the backing Map </span></div><div class="line"><span class="number">3</span>.	<span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span></div><div class="line"><span class="number">4</span>.	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure>
<p>可以看到，HashSet 实际上是使用 HashMap 来保存数据的。而且主要用的是 HashMap的 key。<br>PRESENT是什么东西呢？看上面的注释。dummy的意思是 挂名代表，傀儡。所以，可知：<br>PRESENT是向map中插入key-value对应的value<br>因为HashSet中只需要用到key，而HashMap是key-value键值对；<br>所以，向map中添加键值对时，键值对的值固定是PRESENT。每个set集合<br>中的元素都是HashMap的key 值（这也就保证了HashSet集合中不能有重复元素），而    它们的value值都是 PRESENT。</p>
<h2 id="HashSet构造函数"><a href="#HashSet构造函数" class="headerlink" title="HashSet构造函数"></a>HashSet构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	 <span class="comment">/**  </span></div><div class="line">2.	     * 默认的无参构造器，构造一个空的HashSet。</div><div class="line">3.	     *  </div><div class="line">4.	     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。  </div><div class="line">5.	     */    </div><div class="line"><span class="number">6</span>.	    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;    </div><div class="line"><span class="number">7</span>.	    		map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();    </div><div class="line"><span class="number">8</span>.	    &#125;    </div><div class="line"><span class="number">9</span>.	    <span class="comment">/**  </span></div><div class="line">10.	     * 构造一个包含指定collection中的元素的新set。  </div><div class="line">11.	     * 实际底层使用默认的加载因子0.75和足以包含指定  </div><div class="line">12.	     * collection中所有元素的初始容量来创建一个HashMap。  </div><div class="line">13.	     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。  </div><div class="line">14.	     */    </div><div class="line"><span class="number">15</span>.	    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    </div><div class="line"><span class="number">16</span>.	     <span class="comment">//为什么是Math.max((int) (c.size()/.75f) + 1, 16)？</span></div><div class="line"><span class="number">17</span>.	    <span class="comment">//实际上默认的HashMap的加载因子是0.75,c.size()/0.75 就是HashMap的实际容量，而 16 是默认的HashMap的初始容量。所以取两者的较大值作为 HashSet的容量。</span></div><div class="line"><span class="number">18</span>.	    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));   </div><div class="line"><span class="number">19</span>.	    <span class="comment">// 使用Collection实现的Iterator迭代器，将集合c的元素一个个加入HashSet中</span></div><div class="line"><span class="number">20</span>.	    	addAll(c);    </div><div class="line"><span class="number">21</span>.	   &#125;    </div><div class="line"><span class="number">22</span>.	    <span class="comment">/**  </span></div><div class="line">23.	     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。  </div><div class="line">24.	     *  </div><div class="line">25.	     * 实际底层以以指定的initialCapacity和loadFactor构造一个空的HashMap。  </div><div class="line">26.	     * <span class="doctag">@param</span> initialCapacity 初始容量。  </div><div class="line">27.	     * <span class="doctag">@param</span> loadFactor 加载因子。  </div><div class="line">28.	    */    </div><div class="line"><span class="number">29</span>.	    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;    </div><div class="line"><span class="number">30</span>.	   		map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);    </div><div class="line"><span class="number">31</span>.	    &#125;    </div><div class="line"><span class="number">32</span>.	    <span class="comment">/**  </span></div><div class="line">33.	     * 以指定的initialCapacity构造一个空的HashSet。  </div><div class="line">34.	    *  </div><div class="line">35.	     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。  </div><div class="line">36.	     * <span class="doctag">@param</span> initialCapacity 初始容量。  </div><div class="line">37.	     */    </div><div class="line"><span class="number">38</span>.	   <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;    </div><div class="line"><span class="number">39</span>.	    		map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity);    </div><div class="line"><span class="number">40</span>.	    &#125;    </div><div class="line"><span class="number">41</span>.	    <span class="comment">/**  </span></div><div class="line">42.	     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。  </div><div class="line">43.	    * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。  </div><div class="line">44.	     *  </div><div class="line">45.	     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。  </div><div class="line">46.     * <span class="doctag">@param</span> initialCapacity 初始容量。  </div><div class="line">47.	     * <span class="doctag">@param</span> loadFactor 加载因子。  </div><div class="line">48.     * <span class="doctag">@param</span> dummy 标记。  没有实际意义</div><div class="line">49.	    */    </div><div class="line"><span class="number">50</span>.	   HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;    </div><div class="line"><span class="number">51</span>.   map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);    </div><div class="line"><span class="number">52</span>.	    &#125;</div></pre></td></tr></table></figure>
<h2 id="HashSet方法"><a href="#HashSet方法" class="headerlink" title="HashSet方法"></a>HashSet方法</h2><p>因为HashSet底层是HashMap实现，所以它的方法大都是直接调用HashMap的方法。</p>
<h3 id="add-remove"><a href="#add-remove" class="headerlink" title="add(),remove()"></a>add(),remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="comment">// 将元素(e)添加到HashSet中，也就是将元素作为Key放入HashMap中public boolean add(E e) &#123;  </span></div><div class="line"><span class="number">2</span>.	      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;  <span class="comment">//可以看到PRESENT是value值。</span></div><div class="line"><span class="number">3</span>.	  &#125;  </div><div class="line"><span class="number">4</span>.	<span class="comment">//  删除HashSet中的元素(o)，其实是在HashMap中删除了以o为key的Entry</span></div><div class="line"><span class="number">5</span>.	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line"><span class="number">6</span>.	      <span class="keyword">return</span> map.remove(o)==PRESENT;  </div><div class="line"><span class="number">7</span>.	  &#125;  </div><div class="line"><span class="number">1</span>.	  <span class="comment">// 清空HashMap,的clear方法清空所有Entry</span></div><div class="line"><span class="number">2</span>.	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">3</span>.	        map.clear();    </div><div class="line"><span class="number">4</span>.	  &#125;</div></pre></td></tr></table></figure>
<p>具体可参考HashMap的源码。</p>
<h3 id="iterator-size-，isEmpty"><a href="#iterator-size-，isEmpty" class="headerlink" title="iterator(),size()，isEmpty()"></a>iterator(),size()，isEmpty()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;  </div><div class="line"><span class="number">2</span>.	     <span class="comment">// 实际上返回的是HashMap的“key集合”的迭代器</span></div><div class="line"><span class="number">3</span>.	       <span class="keyword">return</span> map.keySet().iterator();  </div><div class="line"><span class="number">4</span>.	   &#125;  </div><div class="line"><span class="number">5</span>.	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </div><div class="line"><span class="number">6</span>.	       <span class="keyword">return</span> map.size();  </div><div class="line"><span class="number">7</span>.	   &#125;  </div><div class="line"><span class="number">8</span>.	 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  </div><div class="line"><span class="number">9</span>.	       <span class="keyword">return</span> map.isEmpty(); <span class="comment">//查看map是否是空 </span></div><div class="line"><span class="number">10</span>.	   &#125;  </div><div class="line"><span class="number">11</span>.	   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line"><span class="number">12</span>.	       <span class="keyword">return</span> map.containsKey(o); <span class="comment">//map中是否包含键 0 </span></div><div class="line"><span class="number">13</span>.	   &#125;</div></pre></td></tr></table></figure>
<p>看名字很容易就知道是干嘛的，都是直接用的HashMap的方法。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="comment">/** </span></div><div class="line">2.	     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </div><div class="line">3.	    * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到  HashSet中。 </div><div class="line">4.	     */  </div><div class="line"><span class="number">5</span>.	<span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </div><div class="line"><span class="number">6</span>.	      <span class="keyword">try</span> &#123;  </div><div class="line"><span class="number">7</span>.	          HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();  </div><div class="line"><span class="number">8</span>.	          newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </div><div class="line"><span class="number">9</span>.	          <span class="keyword">return</span> newSet;  </div><div class="line"><span class="number">10</span>.	      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </div><div class="line"><span class="number">11</span>.	          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);  </div><div class="line"><span class="number">12</span>.	      &#125;  </div><div class="line"><span class="number">13</span>.	  &#125;</div></pre></td></tr></table></figure>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	     <span class="comment">// java.io.Serializable的写入流中 </span></div><div class="line"><span class="number">2</span>.	    <span class="comment">// 将HashSet的“总的容量，加载因子，实际容量，所有的元素”都写入到输出流中  </span></div><div class="line"><span class="number">3</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span>  </span></div><div class="line">4.	        <span class="keyword">throws</span> java.io.IOException &#123;  </div><div class="line"><span class="number">5</span>.	        <span class="comment">// Write out any hidden serialization magic  </span></div><div class="line"><span class="number">6</span>.	        s.defaultWriteObject();  </div><div class="line"><span class="number">7</span>.	        s.writeInt(map.capacity());  </div><div class="line"><span class="number">8</span>.	        s.writeFloat(map.loadFactor());  </div><div class="line"><span class="number">9</span>.	        <span class="comment">// Write out size  </span></div><div class="line"><span class="number">10</span>.	        s.writeInt(map.size());  </div><div class="line"><span class="number">11</span>.	        <span class="comment">// Write out all elements in the proper order.  </span></div><div class="line"><span class="number">12</span>.	        <span class="keyword">for</span> (Iterator i=map.keySet().iterator(); i.hasNext(); )  </div><div class="line"><span class="number">13</span>.	            s.writeObject(i.next());  </div><div class="line"><span class="number">14</span>.	    &#125;  </div><div class="line"><span class="number">15</span>.	    <span class="comment">// java.io.Serializable 从流中读取 HashSet对象 </span></div><div class="line"><span class="number">16</span>.	    <span class="comment">// 将HashSet的“总的容量，加载因子，实际容量，所有的元素”依次读出  </span></div><div class="line"><span class="number">17</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span>  </span></div><div class="line">18.	        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;  </div><div class="line"><span class="number">19</span>.	        <span class="comment">// Read in any hidden serialization magic  </span></div><div class="line"><span class="number">20</span>.	        s.defaultReadObject();  </div><div class="line"><span class="number">21</span>.	 </div><div class="line"><span class="number">22</span>.	        <span class="keyword">int</span> capacity = s.readInt();  </div><div class="line"><span class="number">23</span>.	        <span class="keyword">float</span> loadFactor = s.readFloat();  </div><div class="line"><span class="number">24</span>.	        map = (((HashSet)<span class="keyword">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?  </div><div class="line"><span class="number">25</span>.	               <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :  </div><div class="line"><span class="number">26</span>.	               <span class="keyword">new</span> HashMap&lt;E,Object&gt;(capacity, loadFactor));  </div><div class="line"><span class="number">27</span>.	        <span class="comment">// Read in size  </span></div><div class="line"><span class="number">28</span>.	        <span class="keyword">int</span> size = s.readInt();  </div><div class="line"><span class="number">29</span>.	        <span class="comment">// Read in all elements in the proper order.  </span></div><div class="line"><span class="number">30</span>.	        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;  </div><div class="line"><span class="number">31</span>.	            E e = (E) s.readObject();  </div><div class="line"><span class="number">32</span>.	            map.put(e, PRESENT);  </div><div class="line"><span class="number">33</span>.	        &#125;  </div><div class="line"><span class="number">34</span>.	    &#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  总体来说，HashSet是比较简单的，底层是HashMap实现的，使用的都是HashMap的方法。</p>
<h2 id="HashSet遍历："><a href="#HashSet遍历：" class="headerlink" title="HashSet遍历："></a>HashSet遍历：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">      <span class="comment">//遍历  </span></div><div class="line"><span class="number">2</span>.	        Iterator iterator = set.iterator();  </div><div class="line"><span class="number">3</span>.	        <span class="keyword">while</span> (iterator.hasNext()) &#123;  </div><div class="line"><span class="number">4</span>.	            System.out.println(iterator.next());              </div><div class="line"><span class="number">5</span>.	        &#125;     </div><div class="line"><span class="number">6</span>.	          </div><div class="line"><span class="number">7</span>.	        <span class="comment">//或者这样  </span></div><div class="line"><span class="number">8</span>.	        <span class="keyword">for</span> (String s:set) &#123;  </div><div class="line"><span class="number">9</span>.	            System.out.println(s);  </div><div class="line"><span class="number">10</span>.	        &#125;</div></pre></td></tr></table></figure>
<p>要注意的是：当我们要将一个类作为HashMap的key或者存储在HashSet的时候。通过重写hashCode()和equals(Object object)方法很重要，并且保证这两个方法的返回值一致。当两个类的hashCode()返回一致时，应该保证equasl()方法也返回true。<br>HashMap源码整理中…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;1.HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序，特别是它不保证该顺序恒久不变。而且HashSet允许使用 null 元素。&lt;br&gt;2.HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” Set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问：&lt;br&gt;
    
    </summary>
    
      <category term="java集合" scheme="https://xiaoybboy.github.io/categories/java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="java" scheme="https://xiaoybboy.github.io/tags/java/"/>
    
      <category term="HashSet" scheme="https://xiaoybboy.github.io/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>java源码之ArrayList</title>
    <link href="https://xiaoybboy.github.io/2017/04/06/java%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/"/>
    <id>https://xiaoybboy.github.io/2017/04/06/java源码之ArrayList/</id>
    <published>2017-04-06T07:20:38.000Z</published>
    <updated>2017-04-07T03:27:01.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList概述："><a href="#ArrayList概述：" class="headerlink" title="ArrayList概述："></a>ArrayList概述：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>ArrayList是基于数组实现的，Object[] elementData;是一个动态数组，其容量能自动增长。<br><a id="more"></a><br>ArrayList与Collection关系如下图：<br>　　 <img src="http://i.imgur.com/10g3wby.jpg" alt="ArrayList和Collection"></p>
<p>１．ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。<br>２．ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。<br>３．每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。<br>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。 </p>
<h1 id="ArrayList的实现："><a href="#ArrayList的实现：" class="headerlink" title="ArrayList的实现："></a>ArrayList的实现：</h1><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p>
<h2 id="私有属性："><a href="#私有属性：" class="headerlink" title="私有属性："></a>私有属性：</h2><p>ArrayList定义只定义类两个私有属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**  </span></div><div class="line">* The array buffer into which the elements of the ArrayList are stored</div><div class="line">* The capacity of the ArrayList is the length of this array buffer.  </div><div class="line"> */    </div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;    </div><div class="line"></div><div class="line"><span class="comment">/**  </span></div><div class="line">* The size of the ArrayList (the number of elements it contains).  </div><div class="line">* <span class="doctag">@serial</span>  </div><div class="line">*/    </div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure></p>
<p>很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。<br>有个关键字需要解释：transient。<br>Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。被标记为transient的属性在对象被序列化的时候不会被保存。<br>接着回到ArrayList的分析中……</p>
<h2 id="modCount和Array-copyof-，System-arraycopy。"><a href="#modCount和Array-copyof-，System-arraycopy。" class="headerlink" title="modCount和Array.copyof()，System.arraycopy。"></a>modCount和Array.copyof()，System.arraycopy。</h2><p>在父类AbstractList中定义了一个int型的属性：modCount，记录了ArrayList结构性变化的次数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>在ArrayList的所有涉及结构变化的方法中都增加modCount的值，包括：add()、remove()、addAll()、removeRange()及clear()方法。这些方法每调用一次，modCount的值就加1。<br>注：add()及addAll()方法的modCount的值是在其中调用的ensureCapacity()方法中增加的。<br>然后，先了解一个方法，下面到处都会用到。Array.copyof()，System.arraycopy。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;    </div><div class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());    </div><div class="line">&#125;    </div><div class="line">    </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;    </div><div class="line">    T[] copy = ((Object)newType == (Object)Object[].class)    </div><div class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]   <span class="comment">// 类型相同，则重新生成一个大小为newLength的数组实例    </span></div><div class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  <span class="comment">// 类型不同，重新生成一个大小为newLength的新类型数组实例    </span></div><div class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(original.length, newLength)); <span class="comment">//将原数组内容拷贝到新数组中,新数组取最小的数组长度    </span></div><div class="line">    <span class="keyword">return</span> copy;  <span class="comment">// 返回新数组的引用     </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而其中的System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)的声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,  </span></span></div><div class="line">                                        Object dest, <span class="keyword">int</span> destPos,  </div><div class="line">                                        <span class="keyword">int</span> length);</div></pre></td></tr></table></figure></p>
<p>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目标数据中的起始位置。<br>length - 要复制的数组元素的数量。<br>System.arraycopy是一个native方法，是底层使用c++实现的。 </p>
<h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><p>ArrayList提供了三种方式的构造器，可以构造一个默认的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">     * Constructs an empty list with the specified initial capacity. </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </div><div class="line">                <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;  <span class="comment">//初始容量大于0,实例化数组</span></div><div class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;  <span class="comment">//初始容量为0</span></div><div class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;  <span class="comment">//空数组</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+  </div><div class="line">                                               initialCapacity);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** ArrayList无参构造函数。</span></div><div class="line">     * Constructs an empty list with an initial capacity of ten. </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** 创建一个包含collection的ArrayList</span></div><div class="line">     * Constructs a list containing the elements of the specified </div><div class="line">     * collection, in the order they are returned by the collection's </div><div class="line">     * iterator.      */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">         elementData = c.toArray();  <span class="comment">//先转化成数组</span></div><div class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;  <span class="comment">//如果集合不为空</span></div><div class="line">          <span class="comment">// c.toArray might (incorrectly) not return Object[] </span></div><div class="line">          <span class="keyword">if</span> (elementData.getClass() != Object[].class)  </div><div class="line">  			<span class="comment">//给elementData 赋值</span></div><div class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="comment">// 如果是一个空的集合，用空数组来替换</span></div><div class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>有参的两个构造器很好理解，下面说下无参的构造器。<br>EMPTY_ELEMENTDATA是什么的？看名字就知道了，是一个空的数组。DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是一个空数组。那么他们之间有什么区别呢？为什么ArrayList无参构造函数构造的是一个DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空数组呢？因为以前的代码是直接初始化一个长度为10的数组。看上面的注释，我们可以知道，We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added.就是当第一个元素被加入到elementData中时，区分这两者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 默认的初始容量为10 </div><div class="line">    */  </div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;  </div><div class="line">  </div><div class="line">   <span class="comment">/** </span></div><div class="line">    * Shared empty array instance used for empty instances. </div><div class="line">    */  </div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;  </div><div class="line">  </div><div class="line">   <span class="comment">/** </span></div><div class="line">    * Shared empty array instance used for default sized empty instances. We</div><div class="line">    * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when  first element is added. </div><div class="line">    */  </div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>既然如此，我们先看一下add()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line"><span class="number">2</span>.	       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line"><span class="number">3</span>.	       elementData[size++] = e;  </div><div class="line"><span class="number">4</span>.	       <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line"><span class="number">5</span>.	   &#125;</div></pre></td></tr></table></figure>
<p>看第一行，应该就是区分的体现了，下面着重看下这个ensureCapacityInternal()函数。这涉及到下面的数组容量扩充，我们单独说一下。</p>
<h2 id="调整数组容量ensureCapacity："><a href="#调整数组容量ensureCapacity：" class="headerlink" title="调整数组容量ensureCapacity："></a>调整数组容量ensureCapacity：</h2><p>与之前的ArrayList源码改变最大的就是这一部分了，先把三个调整容量的函数都贴出来，下面要多次用到。ensureCapacityInternal是第二个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="comment">/** </span></div><div class="line">2.	     * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if </div><div class="line">3.	     * necessary, to ensure that it can hold at least the number of elements </div><div class="line">4.	     * specified by the minimum capacity argument. </div><div class="line">5.	     * </div><div class="line">6.	     * <span class="doctag">@param</span>   minCapacity   the desired minimum capacity </div><div class="line">7.	     */  </div><div class="line"><span class="number">8</span>.	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="number">9</span>.	        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)  </div><div class="line"><span class="number">10</span>.	            <span class="comment">// any size if not default element table  </span></div><div class="line"><span class="number">11</span>.	            ? <span class="number">0</span>  </div><div class="line"><span class="number">12</span>.	            <span class="comment">// larger than default for default empty table. It's already  </span></div><div class="line"><span class="number">13</span>.	            <span class="comment">// supposed to be at default size.  </span></div><div class="line"><span class="number">14</span>.	            : DEFAULT_CAPACITY;  </div><div class="line"><span class="number">15</span>.	  </div><div class="line"><span class="number">16</span>.	        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;  </div><div class="line"><span class="number">17</span>.	            ensureExplicitCapacity(minCapacity);  </div><div class="line"><span class="number">18</span>.	        &#125;  </div><div class="line"><span class="number">19</span>.	    &#125;  </div><div class="line"><span class="number">20</span>.	  </div><div class="line"><span class="number">21</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="number">22</span>.	        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  </div><div class="line"><span class="number">23</span>.	            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);  </div><div class="line"><span class="number">24</span>.	        &#125;  </div><div class="line"><span class="number">25</span>.	        ensureExplicitCapacity(minCapacity);  </div><div class="line"><span class="number">26</span>.	    &#125;  </div><div class="line"><span class="number">27</span>.	  </div><div class="line"><span class="number">28</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="number">29</span>.	        modCount++;   </div><div class="line"><span class="number">30</span>.	        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  </div><div class="line"><span class="number">31</span>.	            grow(minCapacity);  </div><div class="line"><span class="number">32</span>.	    &#125;  </div><div class="line"></div><div class="line"><span class="number">1</span>.	   <span class="comment">/**  容量扩充，确保数组中至少能包含minimum capacity个元素</span></div><div class="line">2.	     * Increases the capacity to ensure that it can hold at least the </div><div class="line">3.	     * number of elements specified by the minimum capacity argument. </div><div class="line">4.	     * </div><div class="line">5.	     * <span class="doctag">@param</span> minCapacity the desired minimum capacity </div><div class="line">6.	     */  </div><div class="line"><span class="number">7</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="number">8</span>.	        <span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line"><span class="number">9</span>.	      <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//原来容量的1.5倍 </span></div><div class="line"><span class="number">10</span>.	        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </div><div class="line"><span class="number">11</span>.	            newCapacity = minCapacity;  </div><div class="line"><span class="number">12</span>.	        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)  </div><div class="line"><span class="number">13</span>.	            newCapacity = hugeCapacity(minCapacity);  </div><div class="line"><span class="number">14</span>.	        <span class="comment">// minCapacity is usually close to size, so this is a win:  </span></div><div class="line"><span class="number">15</span>.	        elementData = Arrays.copyOf(elementData, newCapacity);  </div><div class="line"><span class="number">16</span>.	    &#125;  </div><div class="line"><span class="number">17</span>.	  <span class="comment">//对大容量数组的处理</span></div><div class="line"><span class="number">18</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="number">19</span>.	        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow  </span></div><div class="line"><span class="number">20</span>.	            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();  </div><div class="line"><span class="number">21</span>.	        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?  </div><div class="line"><span class="number">22</span>.	            Integer.MAX_VALUE :  </div><div class="line"><span class="number">23</span>.	            MAX_ARRAY_SIZE;  </div><div class="line"><span class="number">24</span>.	    &#125;</div></pre></td></tr></table></figure></p>
<p>看ensureCapacityInternal中的下面这一句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">33</span>.	<span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  </div><div class="line"><span class="number">34</span>.	            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);  </div><div class="line"><span class="number">35</span>.	        &#125;</div></pre></td></tr></table></figure></p>
<p>看到了吧，先比较DEFAULT_CAPACITY和minCapacity，取较大的值作为minCapacity，显然，对于无参的构造器的空数组，比较的结果是DEFAULT_CAPACITY(上面有定义是10)，然后接下来执行ensureExplicitCapacity(minCapacity)。再接下来，实际执行扩充的是grow(int minCapacity) 这个函数。上面如果是初始化的时候，容易计算此时的minCapacity = DEFAULT_CAPACITY = 10.所以执行grow的时候，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </div><div class="line">            newCapacity = minCapacity;</div></pre></td></tr></table></figure></p>
<p>会执行这一句，应该空的数组扩充1.5倍之后还是空的。接着往下看，就可以知道其实无参的ArrayList的构造器初始化的是一个长度为10的elementData 数组。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于无参的ArrayList构造器，初始化的其实是一个容量为10的Object[] elementData 数组。每次执行扩充时，最终进行数组容量扩充的是grow（）函数，而且不难看出每次数组扩充后的容量为原来数组容量 的1.5倍。int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</p>
<h2 id="元素存储："><a href="#元素存储：" class="headerlink" title="元素存储："></a>元素存储：</h2><p>ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	  <span class="comment">//两个范围检验函数，查看索引是否越界，越界抛出异常  </span></div><div class="line"><span class="number">2</span>.	  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line"><span class="number">3</span>.	          <span class="keyword">if</span> (index &gt;= size)    </div><div class="line"><span class="number">4</span>.	              <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));  </div><div class="line"><span class="number">5</span>.	      &#125;    </div><div class="line"><span class="number">6</span>.	      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line"><span class="number">7</span>.	          <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)    </div><div class="line"><span class="number">8</span>.	              <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));   </div><div class="line"><span class="number">9</span>.	.     &#125;    </div><div class="line"><span class="number">10</span>.	</div><div class="line"><span class="number">11</span>.	   <span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。      </span></div><div class="line"><span class="number">12</span>.	   <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;      </div><div class="line"><span class="number">13</span>.	      RangeCheck(index);      </div><div class="line"><span class="number">14</span>.	      E oldValue = (E) elementData[index];      </div><div class="line"><span class="number">15</span>.	      elementData[index] = element;      </div><div class="line"><span class="number">16</span>.	      <span class="keyword">return</span> oldValue;      </div><div class="line"><span class="number">17</span>.	   &#125;        </div><div class="line"><span class="number">18</span>.	   <span class="comment">// 将指定的元素添加到此列表的尾部。 上面讲到过这个函数，实现也很简单     </span></div><div class="line"><span class="number">19</span>.	   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line"><span class="number">20</span>.	         ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line"><span class="number">21</span>.	         elementData[size++] = e;  </div><div class="line"><span class="number">22</span>.	         <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line"><span class="number">23</span>.	      &#125;      </div><div class="line"><span class="number">24</span>.	   <span class="comment">// 将指定的元素插入此列表中的指定位置。      </span></div><div class="line"><span class="number">25</span>.	   <span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span></div><div class="line"><span class="number">26</span>.	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </div><div class="line"><span class="number">27</span>.	          rangeCheckForAdd(index);<span class="comment">//索引范围检验  </span></div><div class="line"><span class="number">28</span>.	          ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//  扩充1个单元  </span></div><div class="line"><span class="number">29</span>.	       <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素，      </span></div><div class="line"><span class="number">30</span>.	      <span class="comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。      </span></div><div class="line"><span class="number">31</span>.	      <span class="comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span></div><div class="line"><span class="number">32</span>.	         System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,  </div><div class="line"><span class="number">33</span>.	                          size - index);  </div><div class="line"><span class="number">34</span>.	         elementData[index] = element;<span class="comment">//插入元素  </span></div><div class="line"><span class="number">35</span>.	         size++;  </div><div class="line"><span class="number">36</span>.	     &#125;      </div><div class="line"><span class="number">37</span>.	       </div><div class="line"><span class="number">38</span>.	  <span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span></div><div class="line"><span class="number">39</span>.	 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line"><span class="number">40</span>.	         Object[] a = c.toArray();<span class="comment">//先转换成数组   </span></div><div class="line"><span class="number">41</span>.	         <span class="keyword">int</span> numNew = a.length;  </div><div class="line"><span class="number">42</span>.	        ensureCapacityInternal(size + numNew);  <span class="comment">// 容量扩充            </span></div><div class="line"><span class="number">43</span>.	         System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);<span class="comment">//元素复制  </span></div><div class="line"><span class="number">44</span>.	        size += numNew;  </div><div class="line"><span class="number">45</span>.	         <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line"><span class="number">46</span>.	      &#125;           </div><div class="line"><span class="number">47</span>.	   <span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span></div><div class="line"><span class="number">48</span>.	 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line"><span class="number">49</span>.	          rangeCheckForAdd(index);<span class="comment">//索引检查  </span></div><div class="line"><span class="number">50</span>.	    </div><div class="line"><span class="number">51</span>.	          Object[] a = c.toArray();  </div><div class="line"><span class="number">52</span>.	          <span class="keyword">int</span> numNew = a.length;  </div><div class="line"><span class="number">53</span>.	          ensureCapacityInternal(size + numNew);  <span class="comment">// 容量扩充  </span></div><div class="line"><span class="number">54</span>.	    </div><div class="line"><span class="number">55</span>.	         <span class="keyword">int</span> numMoved = size - index;<span class="comment">//要移动的元素的个数  </span></div><div class="line"><span class="number">56</span>.	         <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">             System.arraycopy(elementData, index, elementData, index + numNew, numMoved);<span class="comment">//复制元素  </span></div><div class="line"><span class="number">58</span>.	   </div><div class="line"><span class="number">59</span>.	         System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </div><div class="line"><span class="number">60</span>.	         size += numNew;  </div><div class="line"><span class="number">61</span>.	         <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line"><span class="number">62</span>.	    &#125;</div></pre></td></tr></table></figure></p>
<p>ArrayList是基于数组实现的，可以看到上面的添加元素的方法，大都需要先进行索引检查（与操作索引相关的），还要进行数组容量的扩充，然后是 System.arraycopy复制元素。具体过程查看上面的注释。</p>
<h2 id="元素读取："><a href="#元素读取：" class="headerlink" title="元素读取："></a>元素读取：</h2><p>这个很简单，直接返回数组i位置上的元素即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回此列表中指定位置上的元素。    </span></div><div class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line">    RangeCheck(index);    </div><div class="line">    <span class="keyword">return</span> (E) elementData[index];    </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="元素删除："><a href="#元素删除：" class="headerlink" title="元素删除："></a>元素删除：</h2><p>ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：</p>
<h3 id="romove-int-index"><a href="#romove-int-index" class="headerlink" title="romove(int index):"></a>romove(int index):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除此列表中指定位置上的元素。    </span></div><div class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line">     RangeCheck(index);    </div><div class="line">     modCount++;    </div><div class="line">     E oldValue = (E) elementData[index];    </div><div class="line">     <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;    </div><div class="line">     <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)    </div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);    </div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work    </span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> oldValue;    </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>首先是检查范围，修改modCount，保留将要被移除的元素，将移除位置之后的元素向前挪动一个位置，将list末尾元素置空（null），返回被移除的元素。</p>
<h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。    </span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;    </div><div class="line">    <span class="comment">// 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。    </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;    </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)    </div><div class="line">           <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;    </div><div class="line">                <span class="comment">// 类似remove(int index)，移除列表中指定位置上的元素。    </span></div><div class="line">                fastRemove(index);    </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;    </div><div class="line">            &#125;    </div><div class="line">    &#125; <span class="keyword">else</span> &#123;    </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)    </div><div class="line">           <span class="keyword">if</span> (o.equals(elementData[index])) &#123;    </div><div class="line">                fastRemove(index);    </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过代码可以看到，当移除成功后返回true，否则返回false。remove(Object o)中通过遍历element寻找是否存在传入对象，一旦找到就调用fastRemove移除对象。为什么找到了元素就知道了index，不通过remove(index)来移除元素呢？因为fastRemove跳过了判断边界的处理，因为找到元素就相当于确定了index不会超过边界，而且fastRemove并不返回被移除的元素。下面是fastRemove的代码，基本和remove(index)一致。方法说明：skips bounds checking and does notreturn the value removed.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line">         modCount++;    </div><div class="line">         <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;    </div><div class="line">         <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)    </div><div class="line">  System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,    numMoved);</div><div class="line">         elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work    </span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="batchRemove"><a href="#batchRemove" class="headerlink" title="batchRemove()"></a>batchRemove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="comment">//保留集合c中的元素，集合外的元素全部删除</span></div><div class="line"><span class="number">2</span>.	      Retains only the elements in <span class="keyword">this</span> list that are contained in the</div><div class="line"><span class="number">3</span>.	     * specified collection.  In other words, removes from <span class="keyword">this</span> list all</div><div class="line"><span class="number">4</span>.	     * of its elements that are not contained in the specified collection.</div><div class="line"><span class="number">5</span>.	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;  </div><div class="line"><span class="number">6</span>.	        Objects.requireNonNull(c);  </div><div class="line"><span class="number">7</span>.	        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);  </div><div class="line"><span class="number">8</span>.	    &#125;  </div><div class="line"><span class="number">9</span>.	  </div><div class="line"><span class="number">10</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;  </div><div class="line"><span class="number">11</span>.	        <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;  </div><div class="line"><span class="number">12</span>.	        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;  </div><div class="line"><span class="number">13</span>.	        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;  </div><div class="line"><span class="number">14</span>.	        <span class="keyword">try</span> &#123;  </div><div class="line"><span class="number">15</span>.	            <span class="keyword">for</span> (; r &lt; size; r++)  </div><div class="line"><span class="number">16</span>.	                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)  </div><div class="line"><span class="number">17</span>.	                    elementData[w++] = elementData[r];  </div><div class="line"><span class="number">18</span>.	        &#125; <span class="keyword">finally</span> &#123;  </div><div class="line"><span class="number">19</span>.	            <span class="comment">// Preserve behavioral compatibility with AbstractCollection,  </span></div><div class="line"><span class="number">20</span>.	            <span class="comment">// even if c.contains() throws.  </span></div><div class="line"><span class="number">21</span>.	            <span class="keyword">if</span> (r != size) &#123;  </div><div class="line"><span class="number">22</span>.	                System.arraycopy(elementData, r,  </div><div class="line"><span class="number">23</span>.	                                 elementData, w,  </div><div class="line"><span class="number">24</span>.	                                 size - r);  </div><div class="line"><span class="number">25</span>.	                w += size - r;  </div><div class="line"><span class="number">26</span>.	            &#125;  </div><div class="line"><span class="number">27</span>.	            <span class="keyword">if</span> (w != size) &#123;  </div><div class="line"><span class="number">28</span>.	                <span class="comment">// clear to let GC do its work  </span></div><div class="line"><span class="number">29</span>.	                <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)  </div><div class="line"><span class="number">30</span>.	                    elementData[i] = <span class="keyword">null</span>;  </div><div class="line"><span class="number">31</span>.	                modCount += size - w;  </div><div class="line"><span class="number">32</span>.	                size = w;  </div><div class="line"><span class="number">33</span>.	                modified = <span class="keyword">true</span>;  </div><div class="line"><span class="number">34</span>.	            &#125;  </div><div class="line"><span class="number">35</span>.	        &#125;  </div><div class="line"><span class="number">36</span>.	        <span class="keyword">return</span> modified;  </div><div class="line"><span class="number">37</span>.	    &#125;</div></pre></td></tr></table></figure>
<h3 id="removeRange-int-fromIndex-int-toIndex"><a href="#removeRange-int-fromIndex-int-toIndex" class="headerlink" title="removeRange(int fromIndex,int toIndex)"></a>removeRange(int fromIndex,int toIndex)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;    </div><div class="line">     modCount++;    </div><div class="line">     <span class="keyword">int</span> numMoved = size - toIndex;    </div><div class="line">         System.arraycopy(elementData, toIndex, elementData, fromIndex,    </div><div class="line">                          numMoved);    </div><div class="line">     </div><div class="line">     <span class="comment">// Let gc do its work    </span></div><div class="line">     <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);    </div><div class="line">    <span class="keyword">while</span> (size != newSize)    </div><div class="line">         elementData[--size] = <span class="keyword">null</span>;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行过程是将elementData从toIndex位置开始的元素向前移动到fromIndex，然后将toIndex位置之后的元素全部置空顺便修改size。<br>这个方法是protected，及受保护的方法，为什么这个方法被定义为protected呢？<br>这是一个解释，但是可能不容易看明白。<a href="http://stackoverflow.com/questions/2289183/why-is-javas-abstractlists-removerange-method-protected" target="_blank" rel="external">http://stackoverflow.com/questions/2289183/why-is-javas-abstractlists-removerange-method-protected</a><br>先看下面这个例子</p>
<ol>
<li>ArrayList<integer> ints = new ArrayList<integer>(Arrays.asList(0, 1, 2,    </integer></integer></li>
<li>3, 4, 5, 6));    </li>
<li>// fromIndex low endpoint (inclusive) of the subList    </li>
<li>// toIndex high endpoint (exclusive) of the subList    </li>
<li>ints.subList(2, 4).clear();    </li>
<li>System.out.println(ints);<br>输出结果是[0, 1, 4, 5, 6]，结果是不是像调用了removeRange(int fromIndex,int toIndex)！哈哈哈，就是这样的。但是为什么效果相同呢？是不是调用了removeRange(int fromIndex,int toIndex)呢？<h2 id="ArrayList和Vector区别："><a href="#ArrayList和Vector区别：" class="headerlink" title="ArrayList和Vector区别："></a>ArrayList和Vector区别：</h2>•    ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。<br>•    Vector提供indexOf(obj, start)接口，ArrayList没有。<br>•    Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。<br>##　trimToSize<br>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSiz方法来实现。代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</div><div class="line">            elementData = (size == <span class="number">0</span>)</div><div class="line">              ? EMPTY_ELEMENTDATA</div><div class="line">              : Arrays.copyOf(elementData, size);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>由于elementData的长度会被拓展，size标记的是其中包含的元素的个数。所以会出现size很小但elementData.length很大的情况，将出现空间的浪费。trimToSize将返回一个新的数组给elementData，元素内容保持不变，length和size相同，节省空间。</p>
<h2 id="转为静态数组toArray"><a href="#转为静态数组toArray" class="headerlink" title="转为静态数组toArray"></a>转为静态数组toArray</h2><p>注意ArrayList的两个转化为静态数组的toArray方法。<br>第一个， 调用Arrays.copyOf将返回一个数组，数组内容是size个elementData的元素，即拷贝elementData从0至size-1位置的元素到新数组并返回.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="keyword">public</span> Object[] toArray() &#123;    </div><div class="line"><span class="number">2</span>.	         <span class="keyword">return</span> Arrays.copyOf(elementData, size);    </div><div class="line"><span class="number">3</span>.	 &#125;</div></pre></td></tr></table></figure></p>
<p>第二个，如果传入数组的长度小于size，返回一个新的数组，大小为size，类型与传入数组相同。所传入数组长度与size相等，则将elementData复制到传入数组中并返回传入的数组。若传入数组长度大于size，除了复制elementData外，还将把返回数组的第size个元素置为空。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;  </div><div class="line">        <span class="keyword">if</span> (a.length &lt; size)  </div><div class="line">            <span class="comment">// Make a new array of a's runtime type, but my contents:  </span></div><div class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());  </div><div class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);  </div><div class="line">        <span class="keyword">if</span> (a.length &gt; size)  </div><div class="line">            a[size] = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">return</span> a;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone(),"></a>clone(),</h2><p>返回此 ArrayList 实例的浅表副本。（不复制这些元素本身。）调用父类的clone方法返回一个对象的副本，将返回对象的elementData数组的内容赋值为原对象elementData数组的内容，将副本的modCount设置为0。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();  </div><div class="line">            v.elementData = Arrays.copyOf(elementData, size);  </div><div class="line">            v.modCount = <span class="number">0</span>;  </div><div class="line">            <span class="keyword">return</span> v;  </div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </div><div class="line">            <span class="comment">// this shouldn't happen, since we are Cloneable  </span></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </div><div class="line">     modCount++;  </div><div class="line">   </div><div class="line">     <span class="comment">// Let gc do its work  </span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </div><div class="line">        elementData[i] = <span class="keyword">null</span>;  </div><div class="line">   </div><div class="line">     size = <span class="number">0</span>;  </div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>clear的时候并没有修改elementData的长度（好不容易申请、拓展来的，凭什么释放，留着搞不好还有用呢。这使得确定不再修改list内容之后最好调用trimToSize来释放掉一些空间），只是将所有元素置为null，size设置为0。</p>
<h2 id="contains-Object"><a href="#contains-Object" class="headerlink" title="contains(Object)"></a>contains(Object)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">	<span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.indexOf方法返回值与0比较来判断对象是否在list中。接着看indexOf。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </div><div class="line">               <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)  </div><div class="line">                    <span class="keyword">return</span> i;  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </div><div class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))  </div><div class="line">                    <span class="keyword">return</span> i;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>2.lastIndexOf，光看名字应该就明白了返回的是传入对象在elementData数组中最后出现的index值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">     <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  </div><div class="line">         <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)  </div><div class="line">             <span class="keyword">return</span> i;  </div><div class="line">     &#125; <span class="keyword">else</span> &#123;  </div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  </div><div class="line">         <span class="keyword">if</span> (o.equals(elementData[i]))  </div><div class="line">             <span class="keyword">return</span> i;  </div><div class="line">    &#125;  </div><div class="line">     <span class="keyword">return</span> -<span class="number">1</span>;  </div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>采用了从后向前遍历element数组，若遇到Object则返回index值，若没有遇到，返回-1.</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>因为实现了java.io.Serializable接口，索引可以进行序列化操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">     * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that </div><div class="line">     * is, serialize it). 把arraylist实例写入一个流中</div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span>  </span></div><div class="line">        <span class="keyword">throws</span> java.io.IOException&#123;  </div><div class="line">        <span class="comment">// Write out element count, and any hidden stuff  </span></div><div class="line">        <span class="keyword">int</span> expectedModCount = modCount;  </div><div class="line">        s.defaultWriteObject();  </div><div class="line">  </div><div class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()  </span></div><div class="line">        s.writeInt(size);  </div><div class="line">  </div><div class="line">        <span class="comment">// Write out all elements in the proper order.  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;  </div><div class="line">            s.writeObject(elementData[i]);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, </div><div class="line">     * deserialize it). 从流中读出一个ArrayList实例</div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span>  </span></div><div class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;  </div><div class="line">        elementData = EMPTY_ELEMENTDATA;  </div><div class="line">  </div><div class="line">        <span class="comment">// Read in size, and any hidden stuff  </span></div><div class="line">        s.defaultReadObject();  </div><div class="line"></div><div class="line">        <span class="comment">// Read in capacity  </span></div><div class="line">        s.readInt(); <span class="comment">// ignored  </span></div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity  </span></div><div class="line">            ensureCapacityInternal(size);  </div><div class="line">  </div><div class="line">            Object[] a = elementData;  </div><div class="line">            <span class="comment">// Read in all elements in the proper order.  </span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;  </div><div class="line">                a[i] = s.readObject();  </div><div class="line">        &#125;  &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h1 id="Fail-Fast机制："><a href="#Fail-Fast机制：" class="headerlink" title="Fail-Fast机制："></a>Fail-Fast机制：</h1><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<h1 id="ArrayList的遍历方式"><a href="#ArrayList的遍历方式" class="headerlink" title="ArrayList的遍历方式"></a>ArrayList的遍历方式</h1><p>ArrayList支持3种遍历方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、通过迭代器遍历：</div><div class="line">Iterator iter = list.iterator();</div><div class="line"><span class="keyword">while</span> (iter.hasNext())</div><div class="line">&#123;</div><div class="line">    System.out.println(iter.next());</div><div class="line">&#125;         </div><div class="line"><span class="number">2</span>、随机访问，通过索引值去遍历，由于ArrayList实现了RandomAccess接口</div><div class="line"><span class="keyword">int</span> size = list.size();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) </div><div class="line">&#123;</div><div class="line">   System.out.println(list.get(i));        </div><div class="line">&#125;      </div><div class="line"><span class="number">3</span>、<span class="keyword">for</span>循环遍历：</div><div class="line"><span class="keyword">for</span>(String str:list)</div><div class="line">&#123;</div><div class="line">  System.out.println(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h1><p>关于ArrayList的源码，给出几点比较重要的总结：<br>1.注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。<br>2.注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。<br>3.ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。<br>首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码：</p>
<pre><code class="java"><span class="number">1</span>.    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) {    
<span class="number">2</span>.        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());    
<span class="number">3</span>.    }
</code></pre>
<p>很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型，其源码如下：</p>
<pre><code class="java"><span class="number">1</span>.    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) {    
<span class="number">2</span>.        T[] copy = ((Object)newType == (Object)Object[].class)    
<span class="number">3</span>.            ? (T[]) <span class="keyword">new</span> Object[newLength]    
<span class="number">4</span>.            : (T[]) Array.newInstance(newType.getComponentType(), newLength);    
<span class="number">5</span>.        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,    
<span class="number">6</span>.                         Math.min(original.length, newLength));    
<span class="number">7</span>.        <span class="keyword">return</span> copy;    
<span class="number">8</span>.    }
</code></pre>
<p>这里可以很明显地看出，该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。<br>下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。<br>4.ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。<br>5.在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。<br>6.数组扩容<br>这是对ArrayList效率影响比较大的一个因素。<br>每 当执行Add、AddRange、Insert、InsertRange等添加元素的方法，都会检查内部数组的容量是否不够了，如果是，它就会以当前容量 的两倍来重新构建一个数组，将旧元素Copy到新数组中，然后丢弃旧数组，在这个临界点的扩容操作，应该来说是比较影响效率的。<br>由于是从word上粘贴过来的，格式有些不太正确，以后慢慢修改吧。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ArrayList概述：&quot;&gt;&lt;a href=&quot;#ArrayList概述：&quot; class=&quot;headerlink&quot; title=&quot;ArrayList概述：&quot;&gt;&lt;/a&gt;ArrayList概述：&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;RandomAccess&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ArrayList是基于数组实现的，Object[] elementData;是一个动态数组，其容量能自动增长。&lt;br&gt;
    
    </summary>
    
      <category term="java集合" scheme="https://xiaoybboy.github.io/categories/java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="java源码" scheme="https://xiaoybboy.github.io/tags/java%E6%BA%90%E7%A0%81/"/>
    
      <category term="ArrayList" scheme="https://xiaoybboy.github.io/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>Java Scanner next()和nextLine()</title>
    <link href="https://xiaoybboy.github.io/2017/04/02/Java-Scanner-next-%E5%92%8CnextLine/"/>
    <id>https://xiaoybboy.github.io/2017/04/02/Java-Scanner-next-和nextLine/</id>
    <published>2017-04-02T05:29:44.000Z</published>
    <updated>2017-04-06T07:10:30.311Z</updated>
    
    <content type="html"><![CDATA[<p>java中使用Scanner类获取数据输入十分方便，Scanner类中next()与nextLine()都可以实现字符串String的获取.它们的区别如下：</p>
<ol>
<li>next() 方法从第一个有效字符（非空格，非换行符），开始扫描。当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容，即获得第一个扫描到的不含空格、换行符的单个字符串。</li>
<li>使用nextLine()时，则可以扫描到一行内容并作为一个字符串而被获取到。可以获取空格。<a id="more"></a>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	System.out.println(<span class="string">"---&gt;Test1:\n"</span>);</div><div class="line">	String nextStr = scanner.next();</div><div class="line">	System.out.println(<span class="string">"scanner.next()得到："</span> + nextStr);</div><div class="line">	String nextlineStr = scanner.nextLine();</div><div class="line">	System.out.println(<span class="string">"scanner.nextLine()得到："</span> + nextlineStr);</div><div class="line"></div><div class="line">	System.out.println(<span class="string">"\n---&gt;Test2:"</span>);</div><div class="line">	String nextlineStr2 = scanner.nextLine();</div><div class="line">	System.out.println(<span class="string">"scanner.nextLine()得到："</span> + nextlineStr2);</div><div class="line">	String nextStr2 = scanner.next();</div><div class="line">	System.out.println(<span class="string">"scanner.next()得到："</span> + nextStr2);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://i.imgur.com/vgRn5UN.png" alt="结果"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中使用Scanner类获取数据输入十分方便，Scanner类中next()与nextLine()都可以实现字符串String的获取.它们的区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;next() 方法从第一个有效字符（非空格，非换行符），开始扫描。当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容，即获得第一个扫描到的不含空格、换行符的单个字符串。&lt;/li&gt;
&lt;li&gt;使用nextLine()时，则可以扫描到一行内容并作为一个字符串而被获取到。可以获取空格。
    
    </summary>
    
      <category term="java" scheme="https://xiaoybboy.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://xiaoybboy.github.io/tags/java/"/>
    
      <category term="Scanner" scheme="https://xiaoybboy.github.io/tags/Scanner/"/>
    
  </entry>
  
  <entry>
    <title>github上ssh配置</title>
    <link href="https://xiaoybboy.github.io/2017/03/31/github%E4%B8%8Assh%E9%85%8D%E7%BD%AE/"/>
    <id>https://xiaoybboy.github.io/2017/03/31/github上ssh配置/</id>
    <published>2017-03-30T20:13:14.000Z</published>
    <updated>2017-04-06T07:10:30.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置-ssh-key"><a href="#配置-ssh-key" class="headerlink" title="配置 ssh key"></a>配置 ssh key</h1><p>使用 git bash 生成 public ssh key，以下是最简单的方法<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa</div><div class="line">C/Documents and Settings/username/.ssh 目录下会生成 id_rsa.pub</div></pre></td></tr></table></figure></p>
<p>将 id_rsa.pub 的内容完全复制到 github Account Setting 里的 ssh key 里即可</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>然后会看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi [yourGithubAccount]! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure></p>
<p>设置用户信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;[yourName]&quot;//用户名</div><div class="line">$ git config --global user.email  &quot;[yourEmail]&quot;//填写自己的邮箱</div></pre></td></tr></table></figure></p>
<p>经过以上步骤，本机已成功连接到 github，为部署打下基础。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置-ssh-key&quot;&gt;&lt;a href=&quot;#配置-ssh-key&quot; class=&quot;headerlink&quot; title=&quot;配置 ssh key&quot;&gt;&lt;/a&gt;配置 ssh key&lt;/h1&gt;&lt;p&gt;使用 git bash 生成 public ssh key，以下是最简单的方法&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://xiaoybboy.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://xiaoybboy.github.io/2017/03/24/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://xiaoybboy.github.io/2017/03/24/栈与队列/</id>
    <published>2017-03-24T08:11:27.000Z</published>
    <updated>2017-04-06T07:10:30.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型.</p>
</div>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>假设两个栈为A和B。</p>
<ol>
<li>入队列的时候，只需要向A栈中入栈即可。</li>
<li>出队列的时候，要先检查B栈是否为空。如果B为空，把A栈中的元素全部放入B栈中。如果B不为空，就从B栈顶弹出一个元素。<br>这样就实现了一个队列先进先出的功能。<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 </div><div class="line"> * &lt;分析&gt;： </div><div class="line"> * 入队：将元素进栈A</div><div class="line"> * 出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈； 如果不为空，栈B直接出栈。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span> </span>&#123;</div><div class="line">	Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">	Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">		stack1.push(node);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> a;</div><div class="line">		<span class="keyword">if</span> (!stack2.isEmpty()) &#123;</div><div class="line">			a = stack2.pop();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">while</span> (!stack1.isEmpty()) &#123;</div><div class="line">				stack2.push(stack1.pop());</div><div class="line">			&#125;</div><div class="line">			a = stack2.pop();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> a;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h1><p>用两个队列实现栈的功能。</p>
<h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h1><p>把B当做一个中转站<br>入栈：将元素进队列A<br>出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素出队列并放入队列B，直到队列A中的元素留下一个，然<br>后队列A出队列，再把队列B中的元素出队列以此放入队列A中。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用两个队列实现栈的功能； 思路 &lt;分析&gt;：把B当做一个中转站 入栈：将元素进队列A</div><div class="line"> * 出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素出队列并放入队列B，直到队列A中的元素留下一</div><div class="line"> * 个，然后队列A出队列，再把 队列B中的元素出队列以此放入队列A中。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueStack</span> </span>&#123;</div><div class="line">	Queue&lt;Integer&gt; queue1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">	Queue&lt;Integer&gt; queue2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">		<span class="comment">// 两个栈都为空时，优先考虑queue1</span></div><div class="line">		<span class="keyword">if</span> (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123;</div><div class="line">			queue1.add(node);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 如果queue1为空，queue2有元素，直接放入queue2</span></div><div class="line">		<span class="keyword">if</span> (queue1.isEmpty()) &#123;</div><div class="line">			queue2.add(node);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (queue2.isEmpty()) &#123;</div><div class="line">			queue1.add(node);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 两个栈都为空时，没有元素可以弹出</span></div><div class="line">		<span class="keyword">if</span> (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 如果queue1为空，queue2有元素， 将queue2的元素依次放入queue1中，直到最后一个元素，我们弹出。</span></div><div class="line">		<span class="keyword">if</span> (queue1.isEmpty()) &#123;</div><div class="line">			<span class="keyword">while</span> (queue2.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">				queue1.add(queue2.poll());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> queue2.poll();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (queue2.isEmpty()) &#123;</div><div class="line">			<span class="keyword">while</span> (queue1.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">				queue2.add(queue1.poll());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> queue1.poll();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> (Integer) <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型.&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://xiaoybboy.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://xiaoybboy.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>青蛙跳台阶</title>
    <link href="https://xiaoybboy.github.io/2017/03/24/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://xiaoybboy.github.io/2017/03/24/青蛙跳台阶/</id>
    <published>2017-03-24T07:49:49.000Z</published>
    <updated>2017-04-06T07:10:30.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</div>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>假设第一次跳了一阶，那么还剩 n-1 阶，有f(n-1)中跳法。 假设第一次跳了2阶，那么还剩 n-2 阶，有f(n-2)中跳法。所以，这是一个斐波那契数列。f(n) = f(n-1)+f(n-2)</p>
</blockquote>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</div><div class="line"> * </div><div class="line"> * 思路：假设第一次跳了一阶，那么还剩 n-1 阶，有f(n-1)中跳法。</div><div class="line"> * </div><div class="line"> * 假设第一次跳了2阶，那么还剩 n-2 阶，有f(n-2)中跳法。</div><div class="line"> * </div><div class="line"> * 所以，这是一个斐波那契数列。f(n) = f(n-1)+f(n-2)</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpFloor</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorSolution</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (target == <span class="number">2</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> f1 = <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> f2 = <span class="number">2</span>;</div><div class="line">		<span class="keyword">int</span> cursum = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</div><div class="line">			cursum = f1 + f2;</div><div class="line">			f1 = f2;</div><div class="line">			f2 = cursum;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> cursum;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ol>
<li>假设第一次跳 1 阶。那么还剩 n-1 阶。一共还剩f(n-1)种跳法。</li>
<li>假设第一次跳 2 阶。那么还剩 n-2 阶。一共还剩f(n-2)种跳法。 。。。</li>
<li>假设第一次跳 n-1 阶。那么还剩 1 阶。一共还剩f(1)种跳法。</li>
<li>假设第一次跳 n 阶。一种跳法。</li>
<li>所以：f(n) = f(n-1)+f(n-2)+…+1; 而且:f(n-1) = f(n-2) +…+1;</li>
<li>所以f(n) = 2f(n-1)</li>
</ol>
</blockquote>
<h1 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</div><div class="line"> * </div><div class="line"> * 思路：同样：假设第一次跳 1 阶。那么还剩 n-1 阶。一共还剩f(n-1)种跳法。</div><div class="line"> * </div><div class="line"> * 假设第一次跳 2 阶。那么还剩 n-2 阶。一共还剩f(n-2)种跳法。 。。。</div><div class="line"> * </div><div class="line"> * 假设第一次跳 n-1 阶。那么还剩 1 阶。一共还剩f(1)种跳法。</div><div class="line"> * </div><div class="line"> * 假设第一次跳 n 阶。一种跳法。</div><div class="line"> * </div><div class="line"> * 所以：f(n) = f(n-1)+f(n-2)+...+1; 而且:f(n-1) = f(n-2) +...+1;</div><div class="line"> * </div><div class="line"> * 所以f(n) = 2f(n-1)</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumoFloor2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorSolution</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> JumpFloorSolution(target - <span class="number">1</span>) * <span class="number">2</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>矩阵覆盖</title>
    <link href="https://xiaoybboy.github.io/2017/03/24/%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96/"/>
    <id>https://xiaoybboy.github.io/2017/03/24/矩阵覆盖/</id>
    <published>2017-03-24T07:30:40.000Z</published>
    <updated>2017-04-06T07:10:30.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
</div>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>有以下几种情形：</p>
<blockquote>
<ol>
<li>target &lt;= 0 大矩形为&lt;= 2*0,直接return 0；</li>
<li>target = 1大矩形为2*1，只有一种摆放方法，return1；</li>
<li>target = 2 大矩形为2*2，有两种摆放方法，return2；</li>
<li>target = n 分为两步考虑：<br>第一次摆放一块 2<em>1 的小矩阵，则摆放方法总共为f(target - 1)<br>√<br>√<br>第一次摆放一块1\</em>2的小矩阵，则摆放方法总共为f(target-2)<br>因为，摆放了一块1*2的小矩阵（用√√表示），对应下方的1*2（用××表示）摆放方法就确定了，所以为f(targte-2)<br>√    √<br>×    ×<br>所以：f(target) =f(target - 1) + f(targte-2)<br>实际上就是一个斐波那契数列。</li>
</ol>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;  </div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;  </div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">2</span>)&#123;  </div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>;  </div><div class="line">        &#125;<span class="keyword">else</span>&#123;  </div><div class="line">            <span class="keyword">return</span> RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何终止一个线程</title>
    <link href="https://xiaoybboy.github.io/2017/03/23/%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B/"/>
    <id>https://xiaoybboy.github.io/2017/03/23/如何终止一个线程/</id>
    <published>2017-03-23T02:04:35.000Z</published>
    <updated>2017-04-06T07:10:30.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA如何让一个线程死亡或结束"><a href="#JAVA如何让一个线程死亡或结束" class="headerlink" title="JAVA如何让一个线程死亡或结束"></a>JAVA如何让一个线程死亡或结束</h1><p>&emsp;&emsp;不推荐使用stop()方法终止线程。，因为stop()方法容易引起死锁。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="comment">/**</span></div><div class="line">2.	 * JAVA里面如何使用一个线程死亡或结束 *</div><div class="line">3.	 */</div><div class="line"><span class="number">4</span>.	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</div><div class="line"><span class="number">5</span>.	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="number">6</span>.	    <span class="comment">// 启动线程</span></div><div class="line"><span class="number">7</span>.	    MyThread thread = <span class="keyword">new</span> MyThread();</div><div class="line"><span class="number">8</span>.	    <span class="keyword">new</span> Thread(thread).start();</div><div class="line"><span class="number">9</span>.	</div><div class="line"><span class="number">10</span>.	    <span class="comment">// 你的其它的工作，此时线程在运行中</span></div><div class="line"><span class="number">11</span>.	</div><div class="line"><span class="number">12</span>.	    <span class="comment">// 你不想让线程干活了，停掉它</span></div><div class="line"><span class="number">13</span>.	    <span class="comment">// 注意，这只是一个标志，具体线程何时停，并不能精确控制</span></div><div class="line"><span class="number">14</span>.	    thread.allDone = <span class="keyword">true</span>;</div><div class="line"><span class="number">15</span>.	  &#125;</div><div class="line"><span class="number">16</span>.	&#125;</div><div class="line"><span class="number">17</span>.	</div><div class="line"><span class="number">18</span>.	<span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="number">19</span>.	  <span class="keyword">boolean</span> **<span class="keyword">volatile</span>** allDone = <span class="keyword">false</span>;</div><div class="line"><span class="number">20</span>.	</div><div class="line"><span class="number">21</span>.	  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">22</span>.	    <span class="comment">// 每次循环都检测标志</span></div><div class="line"><span class="number">23</span>.	    <span class="comment">// 如果设置停止标志时已经在循环里</span></div><div class="line"><span class="number">24</span>.	    <span class="comment">// 则最长需要等待一个循环的时间才能终止</span></div><div class="line"><span class="number">25</span>.	    <span class="keyword">while</span> (!allDone) &#123;</div><div class="line"><span class="number">26</span>.	      <span class="comment">// 循环里的工作</span></div><div class="line"><span class="number">27</span>.	    &#125;</div><div class="line"><span class="number">28</span>.	  &#125;</div><div class="line"><span class="number">29</span>.	&#125;</div></pre></td></tr></table></figure></p>
<p>使用 volatile 标识的变量具有线程可见性。当一个线程修改了这个变量的值，其他线程立即可以知道。所以可以避免多CPU出问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA如何让一个线程死亡或结束&quot;&gt;&lt;a href=&quot;#JAVA如何让一个线程死亡或结束&quot; class=&quot;headerlink&quot; title=&quot;JAVA如何让一个线程死亡或结束&quot;&gt;&lt;/a&gt;JAVA如何让一个线程死亡或结束&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;不推荐使用stop()方法终止线程。，因为stop()方法容易引起死锁。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaoybboy.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://xiaoybboy.github.io/tags/java/"/>
    
      <category term="线程" scheme="https://xiaoybboy.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>求二叉树的深度</title>
    <link href="https://xiaoybboy.github.io/2017/03/21/%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>https://xiaoybboy.github.io/2017/03/21/求二叉树的深度/</id>
    <published>2017-03-21T03:46:41.000Z</published>
    <updated>2017-04-06T07:10:30.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>&emsp;&emsp;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。  </p>
</div>
<a id="more"></a>
# 思路
&emsp;&emsp;递归求解
# 代码

undefined

&emsp;下面是一个跟上面类似的题目。
# 题目描述
<div class="note success"><p>&emsp;&emsp;判断一棵树是不是平衡二叉树。平衡二叉树指左右子树的高度不超过1的二叉树。<br>思路很简单，直接贴代码。</p>
</div>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断一棵树是不是平衡二叉树</div><div class="line"> * </div><div class="line"> * 思路：递归求左右子树的深度，比较判断是否是平衡二叉树</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalancedBinaryTree</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> left = getDepth(root.left);</div><div class="line">		<span class="keyword">int</span> right = getDepth(root.right);</div><div class="line">		<span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 递归求解二叉树的深度</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode node)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> left = getDepth(node.left);</div><div class="line">		<span class="keyword">int</span> right = getDepth(node.right);</div><div class="line">		<span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;&amp;emsp;&amp;emsp;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。  &lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://xiaoybboy.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第一个只出现一次的字符</title>
    <link href="https://xiaoybboy.github.io/2017/03/21/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>https://xiaoybboy.github.io/2017/03/21/第一个只出现一次的字符/</id>
    <published>2017-03-21T03:03:34.000Z</published>
    <updated>2017-04-06T07:10:30.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置.<br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;暴力求解。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置</div><div class="line"> * </div><div class="line"> * 思路：暴力求解</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstNotRepeatingCharSolution</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 用一个map记录每个字符出现的次数</span></div><div class="line">		HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> c = str.charAt(i);</div><div class="line">			<span class="keyword">if</span> (map.containsKey(c)) &#123;</div><div class="line">				<span class="keyword">int</span> times = map.get(c);</div><div class="line">				times += <span class="number">1</span>;</div><div class="line">				map.put(c, times);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				map.put(c, <span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 出现一次的字符 首次出现的索引</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> c2 = str.charAt(i);</div><div class="line">			<span class="keyword">if</span> (map.get(c2) == <span class="number">1</span>) &#123;</div><div class="line">				<span class="keyword">return</span> i;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在一个字符串(1&amp;lt;=字符串长度&amp;lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置.&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第N个丑数</title>
    <link href="https://xiaoybboy.github.io/2017/03/20/%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0/"/>
    <id>https://xiaoybboy.github.io/2017/03/20/第N个丑数/</id>
    <published>2017-03-20T07:18:42.000Z</published>
    <updated>2017-04-06T07:10:30.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note primary"><p>&emsp;&emsp;把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上<br>我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 </p>
</div>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><div class="note success"><p>&emsp;&emsp;暴力求解思路。首先我们要搞清楚怎么求丑数。ugly[]表示丑数数组。</p>
</div>
<ol>
<li>ugly[0]=1;</li>
<li>ugly[1]=1*2;</li>
<li>ugly[3]=1*3;</li>
<li>ugly[4]=1<em>2</em>2;</li>
<li>ugly[5]=1*5;</li>
<li>ugly[6]=1<em>2</em>3;</li>
<li>…<br>&emsp;&emsp;是不是可以找出规律来，我们需要记录 丑数中因子 2,3,5 出现的次数。具体用语言不好描述，可以看出规律。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。</div><div class="line"> * 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetUglyNumber</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[index];</div><div class="line">		result[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;<span class="comment">// i2,i3,i5分别记录丑数的因子中2,3,5的个数</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</div><div class="line">			result[i] = min(result[i2] * <span class="number">2</span>, min(result[i3] * <span class="number">3</span>, result[i5] * <span class="number">5</span>));</div><div class="line">			<span class="keyword">if</span> (result[i] == result[i2] * <span class="number">2</span>) &#123;</div><div class="line">				i2++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (result[i] == result[i3] * <span class="number">3</span>) &#123;</div><div class="line">				i3++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (result[i] == result[i5] * <span class="number">5</span>) &#123;</div><div class="line">				i5++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result[index - <span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> i &gt; j ? j : i;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&amp;emsp;&amp;emsp;把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上&lt;br&gt;我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 &lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>把数组排成最小的数</title>
    <link href="https://xiaoybboy.github.io/2017/03/20/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>https://xiaoybboy.github.io/2017/03/20/把数组排成最小的数/</id>
    <published>2017-03-20T06:52:50.000Z</published>
    <updated>2017-04-06T07:10:30.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br><a id="more"></a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>&emsp;&emsp;不得不说，看了这题的解法，真的佩服！~<br>&emsp;&emsp;先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。<br>为什么需要定制排序，因为字符串 a和b 长度不等的情况。比如 “2” 和 “21” ,显然字符串”2”&lt;”21”,但是把他们链接起来的时候 221&gt;212.所以定制一种规则来排除这种情况。<br>定制排序规则如下：  若ab &gt; ba  则 a &gt; b， 若ab &lt; ba 则 a &lt; b，若ab = ba 则 a = b；<br>这个定制排序很妙！</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</div><div class="line"> * 例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。</div><div class="line"> * </div><div class="line"> * 思路：真的思路太强。</div><div class="line"> * </div><div class="line"> * 先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。  排序规则如下：  若ab &gt;</div><div class="line"> * ba 则 a &gt; b，  若ab &lt; ba 则 a &lt; b， 若ab = ba 则 a = b；  解释说明： * 比如 "3" &lt;"31" 但是</div><div class="line"> * "331" &gt; "313"，所以要将二者拼接起来进行比较</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinNumberArray</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> length = numbers.length;</div><div class="line">		String[] strings = <span class="keyword">new</span> String[length];</div><div class="line">		<span class="comment">// 把整型数转换成字符串</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</div><div class="line">			strings[i] = String.valueOf(numbers[i]);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 对字符串数组进行排序</span></div><div class="line">		Arrays.sort(strings, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</div><div class="line">				String s1 = o1 + o2;</div><div class="line">				String s2 = o2 + o1;</div><div class="line">				<span class="keyword">return</span> s1.compareTo(s2);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="comment">//把排序好的字符串拼接在一起</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</div><div class="line">			builder.append(strings[i]);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> builder.toString();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>连续子数组的最大和</title>
    <link href="https://xiaoybboy.github.io/2017/03/19/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>https://xiaoybboy.github.io/2017/03/19/连续子数组的最大和/</id>
    <published>2017-03-19T07:33:33.000Z</published>
    <updated>2017-04-06T07:10:30.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><div class="note primary"><p>test </p>
</div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo利用Github分支在不同电脑上写博客</title>
    <link href="https://xiaoybboy.github.io/2017/03/19/Hexo%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://xiaoybboy.github.io/2017/03/19/Hexo利用Github分支在不同电脑上写博客/</id>
    <published>2017-03-19T04:15:27.000Z</published>
    <updated>2017-04-06T07:10:30.310Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;利用github的不同分支来分别保存网站静态文件与hexo源码（md原始文件及主题等），实现在不同电脑上都可以自由写博客。</p>
<h1 id="Github-Page"><a href="#Github-Page" class="headerlink" title="Github Page"></a>Github Page</h1><p>&emsp;&emsp;这里假设你已经在github上建好了page的仓库，也就是 “yourusername.github.io”的名字的项目仓库，比如我的 dxjia.github.io 。另外，也假设你在自己的电脑上已经配置好git、hexo、node js等环境。<br><a id="more"></a></p>
<h2 id="新建hexo分支"><a href="#新建hexo分支" class="headerlink" title="新建hexo分支"></a>新建hexo分支</h2><p>&emsp;仓库建好之后，都是默认一个master分支的，Github page要求你的网站文件必须存放在这个master分支上，这个没得选；所以我们需要新建另外一个分支来保存我们的hexo原始文件；master 保存的全是public 文件夹下的内容，这也是 hexo发布到github上的内容，而hexo这个分支，保存的是我们网站的配置 。</p>
<p>如下图在红色输入框内写入新建的branch名hexo后，回车即可建立新的branch-hexo；<br><img src="http://7xqitw.com1.z0.glb.clouddn.com/blog-resgit_hub_new_branch.png" alt=""></p>
<h2 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h2><p>&emsp;&emsp;因为我们写博客更多的是更新这个分支，网站文件所在的master分支则由hexo d命令发布文章的时候进行推送，所以我们将hexo分支设置为默认分支，这样我们在新的电脑环境下git clone该仓库时，自动切到hexo`分支。按下图进行操作。<br><img src="http://7xqitw.com1.z0.glb.clouddn.com/blog-resgit_hub_set_default_branch.png" alt="设置默认分支"></p>
<h2 id="配置hexo-deploy参数"><a href="#配置hexo-deploy参数" class="headerlink" title="配置hexo deploy参数"></a>配置hexo deploy参数</h2><p>&emsp;&emsp;为了保证hexo d命令可以正确部署到master分支，在hexo 的配置文件 _config.yml文件中配置参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/dxjia/dxjia.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;hexo 3.0之后 deploy type，将github改为了git，这样适用性更广了，如果你发现无法hexo d，使用下面的命令安装git deployer插件后重试即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<h2 id="修改推送到hexo分支"><a href="#修改推送到hexo分支" class="headerlink" title="修改推送到hexo分支"></a>修改推送到hexo分支</h2><p>&emsp;&emsp;上一步的deploy参数正确配置后，文章写完使用hexo g -d命令就可以直接部署了，生成的博客静态文件会自动部署到 username.github.io仓库的master分支上，这时候通过浏览器访问<a href="http://username.github.io就可以看到你的博客页面里。" target="_blank" rel="external">http://username.github.io就可以看到你的博客页面里。</a></p>
<p>&emsp;&emsp;网站页面是保存了，但这时候我们还没有保存我们的hexo原始文件，包括我们的文章md文件，我们千辛万苦修改的主题配置等。。。接下来使用下面的步骤将他们都统统推送到hexo分支上去。其中目录下的.gitignore 表示哪些文件或文件夹不提交，根据自己需要配置。<br>如果没有.git文件，先git init。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m “change description”</div><div class="line">git push origin hexo</div></pre></td></tr></table></figure></p>
<p>如果没关联远程仓库，执行第三步会出错。和远程仓库关联执行：git remote add origin &lt;远程仓库地址&gt;<br>这样就OK了，我们的原始文件就都上去了，换电脑也不怕了。</p>
<h1 id="日常写博客"><a href="#日常写博客" class="headerlink" title="日常写博客"></a>日常写博客</h1><p>&emsp;&emsp;有时候我们可能会在不同的电脑上写博客，那在不同的电脑上配置 hexo、git、node.js，以及配置git ssh key等都要折腾一下的，这是免不了的，也是比wordpress等其他博客框架麻烦的一点。</p>
<h2 id="已有环境"><a href="#已有环境" class="headerlink" title="已有环境"></a>已有环境</h2><p>&emsp;&emsp;如果在电脑上已经写过博客，那么可以在已有的工作目录下同步之前写的博客。<br>在你的仓库目录下右键’git bash shell’，起来bash命令行，然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull</div></pre></td></tr></table></figure>
<p>这样你的状态就更新了，之后就是 hexo命令写文章啦。。。<br>写完hexo g -d部署好后，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m “change description”</div><div class="line">git push origin hexo</div></pre></td></tr></table></figure>
<p>推送到hexo分支上去。</p>
<h2 id="新的环境"><a href="#新的环境" class="headerlink" title="新的环境"></a>新的环境</h2><p>&emsp;&emsp;到了新的电脑上时，我们需要将项目先下载到本地，然后再进行hexo初始化。<br><strong>记住不需要hexo init指令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/dxjia/dxjia.github.io.git</div><div class="line">cd dxjia.github.io</div><div class="line">npm install hexo</div><div class="line">npm install</div><div class="line">npm install hexo-deployer-git –save</div></pre></td></tr></table></figure></p>
<p>之后开始写博客，写好部署好之后，别忘记 git add , ….git push origin hexo…推上去。。。<br>&emsp;&emsp;原文地址：<a href="http://dxjia.cn/2016/01/27/hexo-write-everywhere/" title="原文" target="_blank" rel="external">http://dxjia.cn/2016/01/27/hexo-write-everywhere/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;利用github的不同分支来分别保存网站静态文件与hexo源码（md原始文件及主题等），实现在不同电脑上都可以自由写博客。&lt;/p&gt;
&lt;h1 id=&quot;Github-Page&quot;&gt;&lt;a href=&quot;#Github-Page&quot; class=&quot;headerlink&quot; title=&quot;Github Page&quot;&gt;&lt;/a&gt;Github Page&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这里假设你已经在github上建好了page的仓库，也就是 “yourusername.github.io”的名字的项目仓库，比如我的 dxjia.github.io 。另外，也假设你在自己的电脑上已经配置好git、hexo、node js等环境。&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo提交新文章错误</title>
    <link href="https://xiaoybboy.github.io/2017/03/19/hexo%E6%8F%90%E4%BA%A4%E6%96%B0%E6%96%87%E7%AB%A0%E9%94%99%E8%AF%AF/"/>
    <id>https://xiaoybboy.github.io/2017/03/19/hexo提交新文章错误/</id>
    <published>2017-03-19T02:33:53.000Z</published>
    <updated>2017-04-06T07:10:30.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo提交新文章出错"><a href="#hexo提交新文章出错" class="headerlink" title="hexo提交新文章出错"></a>hexo提交新文章出错</h1><p>&emsp;&emsp;提交文章的时候报了下面这个错误，<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ERROR Process failed: _posts/数组中出现次数超过一半的数字.md</div><div class="line">YAMLException: can not read a block mapping entry; a multiline key may not be an                                             implicit key at line 5, column 1:</div><div class="line"></div><div class="line">    ^</div><div class="line">    at generateError (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\                                            js-yaml\loader.js:162:10)</div><div class="line">    at throwError (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js-                                            yaml\loader.js:168:9)</div><div class="line">    at readBlockMapping (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\l                                            ib\js-yaml\loader.js:1045:9)</div><div class="line">    at composeNode (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js                                            -yaml\loader.js:1331:12)</div><div class="line">    at readDocument (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\j                                            s-yaml\loader.js:1493:3)</div><div class="line">    at loadDocuments (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\                                            js-yaml\loader.js:1549:5)</div><div class="line">    at Object.load (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js                                            -yaml\loader.js:1566:19)</div><div class="line">    at parseYAML (F:\Myblog\hexo\node_modules\hexo\node_modules\hexo-front-matte                                            r\lib\front_matter.js:80:21)</div><div class="line">    at parse (F:\Myblog\hexo\node_modules\hexo\node_modules\hexo-front-matter\li                                            b\front_matter.js:56:12)</div><div class="line">    at F:\Myblog\hexo\node_modules\hexo\lib\plugins\processor\post.js:52:18</div><div class="line">    at tryCatcher (F:\Myblog\hexo\node_modules\hexo\node_modules\bluebird\js\rel                                            ease\util.js:16:23)</div><div class="line">    at Promise._settlePromiseFromHandler (F:\Myblog\hexo\node_modules\hexo\node_                                            modules\bluebird\js\release\promise.js:509:35)</div><div class="line">    at Promise._settlePromise (F:\Myblog\hexo\node_modules\hexo\node_modules\blu                                            ebird\js\release\promise.js:569:18)</div><div class="line">    at Promise._settlePromise0 (F:\Myblog\hexo\node_modules\hexo\node_modules\bl                                            uebird\js\release\promise.js:614:10)</div><div class="line">    at Promise._settlePromises (F:\Myblog\hexo\node_modules\hexo\node_modules\bl                                            uebird\js\release\promise.js:693:18)</div><div class="line">    at Promise._fulfill (F:\Myblog\hexo\node_modules\hexo\node_modules\bluebird\                                            js\release\promise.js:638:18)</div><div class="line">    at PromiseArray._resolve (F:\Myblog\hexo\node_modules\hexo\node_modules\blue                                            bird\js\release\promise_array.js:126:19)</div><div class="line">    at PromiseArray._promiseFulfilled (F:\Myblog\hexo\node_modules\hexo\node_mod                                            ules\bluebird\js\release\promise_array.js:144:14)</div><div class="line">    at PromiseArray._iterate (F:\Myblog\hexo\node_modules\hexo\node_modules\blue</div></pre></td></tr></table></figure></p>
<p>仔细排查之后，发现是文章开头的categroies的冒号，写成了中文的冒号。额。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo提交新文章出错&quot;&gt;&lt;a href=&quot;#hexo提交新文章出错&quot; class=&quot;headerlink&quot; title=&quot;hexo提交新文章出错&quot;&gt;&lt;/a&gt;hexo提交新文章出错&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;提交文章的时候报了下面这个错误，&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <link href="https://xiaoybboy.github.io/2017/03/19/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://xiaoybboy.github.io/2017/03/19/数组中出现次数超过一半的数字/</id>
    <published>2017-03-19T01:47:31.000Z</published>
    <updated>2017-04-06T07:10:30.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;对于这个问题提供两个解题思路。还有很多其他解法。</p>
<ol>
<li>利用排序。先对数组进行排序，因为题目已知，有一个数字出现的次数超过了数组长度的一半。显然，排序完成之<br>后中间的那个数组必定是这个数组。复杂度O(nlgn)</li>
<li>充分利用数组中有一个数字出现的次数超过数组长度的一半这个条件。这个数一定是相邻重复出现的次数最多的数。<br>即使是最差情况，隔一个数插入这个数，最终这个数必定会出现在最后一位（还是因为出现次数大于数组长度的一半）。<br>这个算法的复杂度只有O（n），不得不说，这个思路真的巧妙。<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。</div><div class="line"> * 由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</div><div class="line"> * </div><div class="line"> * 思路1：快速排序 思路2：找最大相邻重复出现的元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreThanHalfNumArray</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 第一种思路</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> array</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">		<span class="comment">// 判断数组长度是否为0或者数组为null</span></div><div class="line">		<span class="keyword">if</span> (array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		Arrays.sort(array);<span class="comment">// 快速排序对数组进行排序</span></div><div class="line">		<span class="keyword">int</span> mid = array[(array.length) / <span class="number">2</span>];<span class="comment">// 中间的元素</span></div><div class="line"></div><div class="line">		<span class="comment">// 对mid 进行验证</span></div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (mid == array[i]) &#123;</div><div class="line">				count++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> count &gt; (array.length / <span class="number">2</span>) ? mid : <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 第二种思路，想了很久才想明白。关键是利用有一个数的出现次数大于数组长度的一半这个条件</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">		<span class="comment">// 判断数组长度是否为0或者数组为null</span></div><div class="line">		<span class="keyword">if</span> (array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="comment">// 寻找相邻重复次数最多的元素</span></div><div class="line">		<span class="keyword">int</span> temp = array[<span class="number">0</span>];<span class="comment">// 从第一个元素开始找</span></div><div class="line">		<span class="keyword">int</span> times = <span class="number">1</span>;<span class="comment">// 重复出现的次数</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</div><div class="line">				temp = array[i];<span class="comment">// 最后一次赋值的必定是我们要找的元素</span></div><div class="line">				times = <span class="number">1</span>;</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] == temp) &#123;</div><div class="line">				times++;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				times--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 验证</span></div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (array[i] == temp) &#123;</div><div class="line">				count++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> count &gt; (array.length / <span class="number">2</span>) ? temp : <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;总体来看，第一种方法比较容易想到，时间复杂度较高。第二种方法想了很久才想明白，哎，算法能力<br>有待提高！时间复杂度才O(N)!其他还有很多方法，有待考虑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>按字典序输出一个字符串的全排序</title>
    <link href="https://xiaoybboy.github.io/2017/03/18/%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%BA%8F/"/>
    <id>https://xiaoybboy.github.io/2017/03/18/按字典序输出一个字符串的全排序/</id>
    <published>2017-03-18T08:39:56.000Z</published>
    <updated>2017-04-06T07:10:30.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;大脑短路了，想明白这个竟然花了半小时。这个题目的核心其实是求解一个字符串的全排列。因为字典序只需要用<br>Collection.sort()方法排序一个ArrayList<string> 或者TreeSet就行了。<br>&emsp;主要说下怎么对一个字符串进行全排列。比如说”abcd”怎么全排序呢?直觉告诉我们先把a放第一位，对”bcd”再进行全排列，就是一个递归。然后把b放在第一位，”acd”进行递归。…具体操作下面结合代码说。<br>&emsp;下面就是对全排列的字符串进行排序操作，按字典序输出即可。</string></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串</div><div class="line"> * abc,acb,bac,bca,cab和cba。</div><div class="line"> * </div><div class="line"> * 思路：先求解字符串的全排列，然后对这些全排列进行排序。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPermutationSort</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 保存全排列的结果</span></div><div class="line">		<span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果str不为空           </span></div><div class="line">			Permutation(str.toCharArray(), <span class="number">0</span>, result);<span class="comment">// 获取字符串的全排列  </span></div><div class="line">		&#125;</div><div class="line">		Collections.sort(result);<span class="comment">// 对全排列的字符串进行排序</span></div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> charArray</div><div class="line">	 * <span class="doctag">@param</span> i</div><div class="line">	 * <span class="doctag">@param</span> result</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>[] charArray, <span class="keyword">int</span> i, ArrayList&lt;String&gt; result)</span> </span>&#123;</div><div class="line">		<span class="comment">// 如果 i 是最后一个字符位置</span></div><div class="line">		<span class="keyword">if</span> (i == charArray.length - <span class="number">1</span>) &#123;</div><div class="line">			result.add(String.valueOf(charArray));<span class="comment">// 找到一个全排序</span></div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= charArray.length - <span class="number">1</span>; j++) &#123;</div><div class="line">				<span class="keyword">if</span> (j != i &amp;&amp; charArray[j] == charArray[i])<span class="comment">// 有重复字符时，跳过</span></div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				swap(charArray, i, j);</div><div class="line">				Permutation(charArray, i + <span class="number">1</span>, result);</div><div class="line">				swap(charArray, i, j);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 交换字符数组s的第i个位置和第j个位置的字符</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (s[i] == s[j]) &#123;</div><div class="line">			;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">char</span> c = s[i];</div><div class="line">			s[i] = s[j];</div><div class="line">			s[j] = c;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;回头再看究竟是怎么全排列的吧。就是这个函数 private void Permutation(char[] charArray, int i, ArrayList<string> result) 的递归过程。其中 i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列。当i == charArray.length - 1 时，表示已经到了最后一个字符，那么就找到了一个全排列。下面很好看懂，就是递归向下找，但是为什么要交换两次 charArray i和j 位置的字符呢？<br>&emsp;&emsp;其实拿”abcd”来说，当我们交换 a和b 的位置（第一次交换），然后用b作为首字符寻找全排列。但是下次我们要交换 a和c 的位置，但是这时候 a和b 已经交换了，所以要把 a和b 换回来，才能保证每次交换的顺序没有乱。</string></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
