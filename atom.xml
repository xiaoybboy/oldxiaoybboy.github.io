<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如果一切重来</title>
  <subtitle>小小程序员的成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaoybboy.github.io/"/>
  <updated>2017-03-19T02:37:35.011Z</updated>
  <id>https://xiaoybboy.github.io/</id>
  
  <author>
    <name>Yb Xiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo提交新文章错误</title>
    <link href="https://xiaoybboy.github.io/2017/03/19/hexo%E6%8F%90%E4%BA%A4%E6%96%B0%E6%96%87%E7%AB%A0%E9%94%99%E8%AF%AF/"/>
    <id>https://xiaoybboy.github.io/2017/03/19/hexo提交新文章错误/</id>
    <published>2017-03-19T02:33:53.000Z</published>
    <updated>2017-03-19T02:37:35.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo提交新文章出错"><a href="#hexo提交新文章出错" class="headerlink" title="hexo提交新文章出错"></a>hexo提交新文章出错</h1><p>&emsp;&emsp;提交文章的时候报了下面这个错误，<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ERROR Process failed: _posts/数组中出现次数超过一半的数字.md</div><div class="line">YAMLException: can not read a block mapping entry; a multiline key may not be an                                             implicit key at line 5, column 1:</div><div class="line"></div><div class="line">    ^</div><div class="line">    at generateError (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\                                            js-yaml\loader.js:162:10)</div><div class="line">    at throwError (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js-                                            yaml\loader.js:168:9)</div><div class="line">    at readBlockMapping (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\l                                            ib\js-yaml\loader.js:1045:9)</div><div class="line">    at composeNode (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js                                            -yaml\loader.js:1331:12)</div><div class="line">    at readDocument (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\j                                            s-yaml\loader.js:1493:3)</div><div class="line">    at loadDocuments (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\                                            js-yaml\loader.js:1549:5)</div><div class="line">    at Object.load (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js                                            -yaml\loader.js:1566:19)</div><div class="line">    at parseYAML (F:\Myblog\hexo\node_modules\hexo\node_modules\hexo-front-matte                                            r\lib\front_matter.js:80:21)</div><div class="line">    at parse (F:\Myblog\hexo\node_modules\hexo\node_modules\hexo-front-matter\li                                            b\front_matter.js:56:12)</div><div class="line">    at F:\Myblog\hexo\node_modules\hexo\lib\plugins\processor\post.js:52:18</div><div class="line">    at tryCatcher (F:\Myblog\hexo\node_modules\hexo\node_modules\bluebird\js\rel                                            ease\util.js:16:23)</div><div class="line">    at Promise._settlePromiseFromHandler (F:\Myblog\hexo\node_modules\hexo\node_                                            modules\bluebird\js\release\promise.js:509:35)</div><div class="line">    at Promise._settlePromise (F:\Myblog\hexo\node_modules\hexo\node_modules\blu                                            ebird\js\release\promise.js:569:18)</div><div class="line">    at Promise._settlePromise0 (F:\Myblog\hexo\node_modules\hexo\node_modules\bl                                            uebird\js\release\promise.js:614:10)</div><div class="line">    at Promise._settlePromises (F:\Myblog\hexo\node_modules\hexo\node_modules\bl                                            uebird\js\release\promise.js:693:18)</div><div class="line">    at Promise._fulfill (F:\Myblog\hexo\node_modules\hexo\node_modules\bluebird\                                            js\release\promise.js:638:18)</div><div class="line">    at PromiseArray._resolve (F:\Myblog\hexo\node_modules\hexo\node_modules\blue                                            bird\js\release\promise_array.js:126:19)</div><div class="line">    at PromiseArray._promiseFulfilled (F:\Myblog\hexo\node_modules\hexo\node_mod                                            ules\bluebird\js\release\promise_array.js:144:14)</div><div class="line">    at PromiseArray._iterate (F:\Myblog\hexo\node_modules\hexo\node_modules\blue</div></pre></td></tr></table></figure></p>
<p>仔细排查之后，发现是文章开头的categroies的冒号，写成了中文的冒号。额。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo提交新文章出错&quot;&gt;&lt;a href=&quot;#hexo提交新文章出错&quot; class=&quot;headerlink&quot; title=&quot;hexo提交新文章出错&quot;&gt;&lt;/a&gt;hexo提交新文章出错&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;提交文章的时候报了下面这个错误，&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <link href="https://xiaoybboy.github.io/2017/03/19/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://xiaoybboy.github.io/2017/03/19/数组中出现次数超过一半的数字/</id>
    <published>2017-03-19T01:47:31.000Z</published>
    <updated>2017-03-19T02:33:14.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;对于这个问题提供两个解题思路。还有很多其他解法。</p>
<ol>
<li>利用排序。先对数组进行排序，因为题目已知，有一个数字出现的次数超过了数组长度的一半。显然，排序完成之<br>后中间的那个数组必定是这个数组。复杂度O(nlgn)</li>
<li>充分利用数组中有一个数字出现的次数超过数组长度的一半这个条件。这个数一定是相邻重复出现的次数最多的数。<br>即使是最差情况，隔一个数插入这个数，最终这个数必定会出现在最后一位（还是因为出现次数大于数组长度的一半）。<br>这个算法的复杂度只有O（n），不得不说，这个思路真的巧妙。<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。</div><div class="line"> * 由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</div><div class="line"> * </div><div class="line"> * 思路1：快速排序 思路2：找最大相邻重复出现的元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreThanHalfNumArray</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 第一种思路</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> array</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">		<span class="comment">// 判断数组长度是否为0或者数组为null</span></div><div class="line">		<span class="keyword">if</span> (array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		Arrays.sort(array);<span class="comment">// 快速排序对数组进行排序</span></div><div class="line">		<span class="keyword">int</span> mid = array[(array.length) / <span class="number">2</span>];<span class="comment">// 中间的元素</span></div><div class="line"></div><div class="line">		<span class="comment">// 对mid 进行验证</span></div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (mid == array[i]) &#123;</div><div class="line">				count++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> count &gt; (array.length / <span class="number">2</span>) ? mid : <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 第二种思路，想了很久才想明白。关键是利用有一个数的出现次数大于数组长度的一半这个条件</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">		<span class="comment">// 判断数组长度是否为0或者数组为null</span></div><div class="line">		<span class="keyword">if</span> (array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="comment">// 寻找相邻重复次数最多的元素</span></div><div class="line">		<span class="keyword">int</span> temp = array[<span class="number">0</span>];<span class="comment">// 从第一个元素开始找</span></div><div class="line">		<span class="keyword">int</span> times = <span class="number">1</span>;<span class="comment">// 重复出现的次数</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</div><div class="line">				temp = array[i];<span class="comment">// 最后一次赋值的必定是我们要找的元素</span></div><div class="line">				times = <span class="number">1</span>;</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] == temp) &#123;</div><div class="line">				times++;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				times--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 验证</span></div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (array[i] == temp) &#123;</div><div class="line">				count++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> count &gt; (array.length / <span class="number">2</span>) ? temp : <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;总体来看，第一种方法比较容易想到，时间复杂度较高。第二种方法想了很久才想明白，哎，算法能力<br>有待提高！时间复杂度才O(N)!其他还有很多方法，有待考虑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>按字典序输出一个字符串的全排序</title>
    <link href="https://xiaoybboy.github.io/2017/03/18/%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%BA%8F/"/>
    <id>https://xiaoybboy.github.io/2017/03/18/按字典序输出一个字符串的全排序/</id>
    <published>2017-03-18T08:39:56.000Z</published>
    <updated>2017-03-18T13:29:43.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;大脑短路了，想明白这个竟然花了半小时。这个题目的核心其实是求解一个字符串的全排列。因为字典序只需要用<br>Collection.sort()方法排序一个ArrayList<string> 或者TreeSet就行了。<br>&emsp;主要说下怎么对一个字符串进行全排列。比如说”abcd”怎么全排序呢?直觉告诉我们先把a放第一位，对”bcd”再进行全排列，就是一个递归。然后把b放在第一位，”acd”进行递归。…具体操作下面结合代码说。<br>&emsp;下面就是对全排列的字符串进行排序操作，按字典序输出即可。</string></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串</div><div class="line"> * abc,acb,bac,bca,cab和cba。</div><div class="line"> * </div><div class="line"> * 思路：先求解字符串的全排列，然后对这些全排列进行排序。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPermutationSort</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 保存全排列的结果</span></div><div class="line">		<span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果str不为空           </span></div><div class="line">			Permutation(str.toCharArray(), <span class="number">0</span>, result);<span class="comment">// 获取字符串的全排列  </span></div><div class="line">		&#125;</div><div class="line">		Collections.sort(result);<span class="comment">// 对全排列的字符串进行排序</span></div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> charArray</div><div class="line">	 * <span class="doctag">@param</span> i</div><div class="line">	 * <span class="doctag">@param</span> result</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>[] charArray, <span class="keyword">int</span> i, ArrayList&lt;String&gt; result)</span> </span>&#123;</div><div class="line">		<span class="comment">// 如果 i 是最后一个字符位置</span></div><div class="line">		<span class="keyword">if</span> (i == charArray.length - <span class="number">1</span>) &#123;</div><div class="line">			result.add(String.valueOf(charArray));<span class="comment">// 找到一个全排序</span></div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= charArray.length - <span class="number">1</span>; j++) &#123;</div><div class="line">				<span class="keyword">if</span> (j != i &amp;&amp; charArray[j] == charArray[i])<span class="comment">// 有重复字符时，跳过</span></div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				swap(charArray, i, j);</div><div class="line">				Permutation(charArray, i + <span class="number">1</span>, result);</div><div class="line">				swap(charArray, i, j);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 交换字符数组s的第i个位置和第j个位置的字符</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (s[i] == s[j]) &#123;</div><div class="line">			;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">char</span> c = s[i];</div><div class="line">			s[i] = s[j];</div><div class="line">			s[j] = c;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;回头再看究竟是怎么全排列的吧。就是这个函数 private void Permutation(char[] charArray, int i, ArrayList<string> result) 的递归过程。其中 i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列。当i == charArray.length - 1 时，表示已经到了最后一个字符，那么就找到了一个全排列。下面很好看懂，就是递归向下找，但是为什么要交换两次 charArray i和j 位置的字符呢？<br>&emsp;&emsp;其实拿”abcd”来说，当我们交换 a和b 的位置（第一次交换），然后用b作为首字符寻找全排列。但是下次我们要交换 a和c 的位置，但是这时候 a和b 已经交换了，所以要把 a和b 换回来，才能保证每次交换的顺序没有乱。</string></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树与双向链表</title>
    <link href="https://xiaoybboy.github.io/2017/03/18/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://xiaoybboy.github.io/2017/03/18/二叉搜索树与双向链表/</id>
    <published>2017-03-18T07:07:36.000Z</published>
    <updated>2017-03-18T13:29:52.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;使用递归的思想。步骤如下：<br>&emsp;1. 将左子树构造成双链表，并返回链表头节点。<br>&emsp;2. 定位至左子树双链表最后一个节点。<br>&emsp;3. 如果左子树链表不为空的话，将当前root追加到左子树链表。<br>&emsp;4. 将右子树构造成双链表，并返回链表头节点。<br>&emsp;5. 如果右子树链表不为空的话，将该链表追加到root节点之后。<br>&emsp;6. 根据左子树链表是否为空确定返回的节点。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</div><div class="line"> * 思路：解题思路：</div><div class="line">	1.将左子树构造成双链表，并返回链表头节点。</div><div class="line">	2.定位至左子树双链表最后一个节点。</div><div class="line">	3.如果左子树链表不为空的话，将当前root追加到左子树链表。</div><div class="line">	4.将右子树构造成双链表，并返回链表头节点。</div><div class="line">	5.如果右子树链表不为空的话，将该链表追加到root节点之后。</div><div class="line">	6.根据左子树链表是否为空确定返回的节点。</div><div class="line">	</div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLinkedList</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 如果root的左右子树都为空</span></div><div class="line">		<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> root;</div><div class="line">		&#125;</div><div class="line">		TreeNode left = Convert(root.left);<span class="comment">// 把root节点的左子树转成链表，返回值为链表的头</span></div><div class="line">		TreeNode p = left;</div><div class="line">		<span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</div><div class="line">			p = p.right;<span class="comment">// 循环定位到左子树双链表的最后一个节点</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 如果左子树链表不为空的话，将当前root追加到左子树链表</span></div><div class="line">		<span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</div><div class="line">			p.right = root;<span class="comment">// 把root连接到左子树形成的双向链表中，双向链表，需要左右都连接</span></div><div class="line">			root.left = p;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 同样的，把根节点的右子树也形成双向链表，返回值为链表头</span></div><div class="line">		TreeNode right = Convert(root.right);</div><div class="line">		<span class="comment">// 把右子树的链表连接到上面的左子树和根节点的链表中</span></div><div class="line">		<span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</div><div class="line">			root.right = right;<span class="comment">// 同样把右子树的链表连接上去</span></div><div class="line">			right.left = root;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> left != <span class="keyword">null</span> ? left : root;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <link href="https://xiaoybboy.github.io/2017/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://xiaoybboy.github.io/2017/03/18/二叉树中和为某一值的路径/</id>
    <published>2017-03-18T06:17:10.000Z</published>
    <updated>2017-03-18T13:30:20.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br><a id="more"></a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> listAll;</div><div class="line">        list.add(root.val);</div><div class="line">        target -= root.val;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</div><div class="line">            listAll.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</div><div class="line">        FindPath(root.left, target);</div><div class="line">        FindPath(root.right, target);</div><div class="line">        list.remove(list.size()-<span class="number">1</span>);<span class="comment">//返回父节点继续搜索</span></div><div class="line">        <span class="keyword">return</span> listAll;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>测试字符串中是否包含重复字符</title>
    <link href="https://xiaoybboy.github.io/2017/03/18/%E6%B5%8B%E8%AF%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"/>
    <id>https://xiaoybboy.github.io/2017/03/18/测试字符串中是否包含重复字符/</id>
    <published>2017-03-18T04:07:14.000Z</published>
    <updated>2017-03-18T06:53:42.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;请实现一个算法，确定一个字符串的所有字符全都不同。要求不允许使用额外的存储空间。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;暂时没想到好的思路，只能暴力求解。<br><a id="more"></a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRepeat</span> </span>&#123;  </div><div class="line">    <span class="comment">// 暴力求解，双层循环，一一比较  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkDifferent</span><span class="params">(String iniString)</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;iniString.length();i++) &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;iniString.length();j++) &#123;  </div><div class="line">                <span class="keyword">if</span> (iniString.charAt(i) == iniString.charAt(j))  </div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;请实现一个算法，确定一个字符串的所有字符全都不同。要求不允许使用额外的存储空间。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;暂时没想到好的思路，只能暴力求解。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://xiaoybboy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://xiaoybboy.github.io/2017/03/07/hello-world/"/>
    <id>https://xiaoybboy.github.io/2017/03/07/hello-world/</id>
    <published>2017-03-06T16:00:00.000Z</published>
    <updated>2017-03-18T04:17:52.867Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://xiaoybboy.github.io/tags/github/"/>
    
  </entry>
  
</feed>
