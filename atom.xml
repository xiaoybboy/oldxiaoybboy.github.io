<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如果一切重来</title>
  <subtitle>小小程序员的成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaoybboy.github.io/"/>
  <updated>2017-06-07T02:27:28.771Z</updated>
  <id>https://xiaoybboy.github.io/</id>
  
  <author>
    <name>A Happy Boy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用sklearn优雅地进行数据挖掘</title>
    <link href="https://xiaoybboy.github.io/2017/06/07/%E4%BD%BF%E7%94%A8sklearn%E4%BC%98%E9%9B%85%E5%9C%B0%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    <id>https://xiaoybboy.github.io/2017/06/07/使用sklearn优雅地进行数据挖掘/</id>
    <published>2017-06-07T02:12:24.000Z</published>
    <updated>2017-06-07T02:27:28.771Z</updated>
    
    <content type="html"><![CDATA[<p>今天找资料的时候，发现一个很牛的大神。写的博客是真的好。慢慢的汲取养分。<br>转自：<a href="http://www.cnblogs.com/jasonfreak/p/5448462.html" target="_blank" rel="external">http://www.cnblogs.com/jasonfreak/p/5448462.html</a></p>
<h1 id="使用sklearn进行数据挖掘"><a href="#使用sklearn进行数据挖掘" class="headerlink" title="使用sklearn进行数据挖掘"></a>使用sklearn进行数据挖掘</h1><h2 id="数据挖掘的步骤"><a href="#数据挖掘的步骤" class="headerlink" title="数据挖掘的步骤"></a>数据挖掘的步骤</h2><p>数据挖掘通常包括数据采集，数据分析，特征工程，训练模型，模型评估等步骤。使用sklearn工具可以方便地进行特征工程和模型训练工作，在《使用sklearn做单机特征工程》中，我们最后留下了一些疑问：特征处理类都有三个方法fit、transform和fit_transform，fit方法居然和模型训练方法fit同名（不光同名，参数列表都一样），这难道都是巧合？<br>显然，这不是巧合，这正是sklearn的设计风格。我们能够更加优雅地使用sklearn进行特征工程和模型训练工作。此时，不妨从一个基本的数据挖掘场景入手：<br><img src="http://i.imgur.com/Tru96mm.png" alt=""><br>我们使用sklearn进行虚线框内的工作（sklearn也可以进行文本特征提取）。通过分析sklearn源码，我们可以看到除训练，预测和评估以外，处理其他工作的类都实现了3个方法：fit、transform和fit_transform。从命名中可以看到，fit_transform方法是先调用fit然后调用transform，我们只需要关注fit方法和transform方法即可。</p>
<p>transform方法主要用来对特征进行转换。从可利用信息的角度来说，转换分为无信息转换和有信息转换。无信息转换是指不利用任何其他信息进行转换，比如指数、对数函数转换等。有信息转换从是否利用目标值向量又可分为无监督转换和有监督转换。无监督转换指只利用特征的统计信息的转换，统计信息包括均值、标准差、边界等等，比如标准化、PCA法降维等。有监督转换指既利用了特征信息又利用了目标值信息的转换，比如通过模型选择特征、LDA法降维等。通过总结常用的转换类，我们得到下表：<br><img src="http://i.imgur.com/Eo7KOEI.png" alt=""><br>不难看到，只有有信息的转换类的fit方法才实际有用，显然fit方法的主要工作是获取特征信息和目标值信息，在这点上，fit方法和模型训练时的fit方法就能够联系在一起了：都是通过分析特征和目标值，提取有价值的信息，对于转换类来说是某些统计量，对于模型来说可能是特征的权值系数等。另外，只有有监督的转换类的fit和transform方法才需要特征和目标值两个参数。fit方法无用不代表其没实现，而是除合法性校验以外，其并没有对特征和目标值进行任何处理，Normalizer的fit方法实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None)</span>:</span></div><div class="line"><span class="number">2</span>         <span class="string">"""Do nothing and return the estimator unchanged</span></div><div class="line">3         This method is just there to implement the usual API and hence</div><div class="line">4         work in pipelines.</div><div class="line">5         """</div><div class="line"><span class="number">6</span>         X = check_array(X, accept_sparse=<span class="string">'csr'</span>)</div><div class="line"><span class="number">7</span>         <span class="keyword">return</span> self</div></pre></td></tr></table></figure></p>
<p>基于这些特征处理工作都有共同的方法，那么试想可不可以将他们组合在一起？在本文假设的场景中，我们可以看到这些工作的组合形式有两种：流水线式和并行式。基于流水线组合的工作需要依次进行，前一个工作的输出是后一个工作的输入；基于并行式的工作可以同时进行，其使用同样的输入，所有工作完成后将各自的输出合并之后输出。sklearn提供了包pipeline来完成流水线式和并行式的工作。</p>
<h2 id="数据初貌"><a href="#数据初貌" class="headerlink" title="数据初貌"></a>数据初貌</h2><p>在此，我们仍然使用IRIS数据集来进行说明。为了适应提出的场景，对原数据集需要稍微加工：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> hstack, vstack, array, median, nan</div><div class="line"> <span class="number">2</span> <span class="keyword">from</span> numpy.random <span class="keyword">import</span> choice</div><div class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</div><div class="line"> <span class="number">4</span> </div><div class="line"> <span class="number">5</span> <span class="comment">#特征矩阵加工</span></div><div class="line"> <span class="number">6</span> <span class="comment">#使用vstack增加一行含缺失值的样本(nan, nan, nan, nan)</span></div><div class="line"> <span class="number">7</span> <span class="comment">#使用hstack增加一列表示花的颜色（0-白、1-黄、2-红），花的颜色是随机的，意味着颜色并不影响花的分类</span></div><div class="line"> <span class="number">8</span> iris.data = hstack((choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], size=iris.data.shape[<span class="number">0</span>]+<span class="number">1</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>), vstack((iris.data, array([nan, nan, nan, nan]).reshape(<span class="number">1</span>,<span class="number">-1</span>)))))</div><div class="line"> <span class="number">9</span> <span class="comment">#目标值向量加工</span></div><div class="line"><span class="number">10</span> <span class="comment">#增加一个目标值，对应含缺失值的样本，值为众数</span></div><div class="line"><span class="number">11</span> iris.target = hstack((iris.target, array([median(iris.target)])))</div></pre></td></tr></table></figure></p>
<h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><h2 id="并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。"><a href="#并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。" class="headerlink" title="并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。"></a>并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。</h2><h1 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h1><p>并行处理使得多个特征处理工作能够并行地进行。根据对特征矩阵的读取方式不同，可分为整体并行处理和部分并行处理。整体并行处理，即并行处理的每个工作的输入都是特征矩阵的整体；部分并行处理，即可定义每个工作需要输入的特征矩阵的列。</p>
<h2 id="整体并行处理"><a href="#整体并行处理" class="headerlink" title="整体并行处理"></a>整体并行处理</h2><p>pipeline包提供了FeatureUnion类来进行整体并行处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> log1p</div><div class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</div><div class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</div><div class="line"> <span class="number">4</span> <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> FeatureUnion</div><div class="line"> <span class="number">5</span> </div><div class="line"> <span class="number">6</span> <span class="comment">#新建将整体特征矩阵进行对数函数转换的对象</span></div><div class="line"> <span class="number">7</span> step2_1 = (<span class="string">'ToLog'</span>, FunctionTransformer(log1p))</div><div class="line"> <span class="number">8</span> <span class="comment">#新建将整体特征矩阵进行二值化类的对象</span></div><div class="line"> <span class="number">9</span> step2_2 = (<span class="string">'ToBinary'</span>, Binarizer())</div><div class="line"><span class="number">10</span> <span class="comment">#新建整体并行处理对象</span></div><div class="line"><span class="number">11</span> <span class="comment">#该对象也有fit和transform方法，fit和transform方法均是并行地调用需要并行处理的对象的fit和transform方法</span></div><div class="line"><span class="number">12</span> <span class="comment">#参数transformer_list为需要并行处理的对象列表，该列表为二元组列表，第一元为对象的名称，第二元为对象</span></div><div class="line"><span class="number">13</span> step2 = (<span class="string">'FeatureUnion'</span>, FeatureUnion(transformer_list=[step2_1, step2_2, step2_3]))</div></pre></td></tr></table></figure></p>
<h2 id="部分并行处理"><a href="#部分并行处理" class="headerlink" title="部分并行处理"></a>部分并行处理</h2><p>整体并行处理有其缺陷，在一些场景下，我们只需要对特征矩阵的某些列进行转换，而不是所有列。pipeline并没有提供相应的类（仅OneHotEncoder类实现了该功能），需要我们在FeatureUnion的基础上进行优化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> FeatureUnion, _fit_one_transformer, _fit_transform_one, _transform_one </div><div class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.externals.joblib <span class="keyword">import</span> Parallel, delayed</div><div class="line"> <span class="number">3</span> <span class="keyword">from</span> scipy <span class="keyword">import</span> sparse</div><div class="line"> <span class="number">4</span> <span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"> <span class="number">5</span> </div><div class="line"> <span class="number">6</span> <span class="comment">#部分并行处理，继承FeatureUnion</span></div><div class="line"> <span class="number">7</span> <span class="class"><span class="keyword">class</span> <span class="title">FeatureUnionExt</span><span class="params">(FeatureUnion)</span>:</span></div><div class="line"> <span class="number">8</span>     <span class="comment">#相比FeatureUnion，多了idx_list参数，其表示每个并行工作需要读取的特征矩阵的列</span></div><div class="line"> <span class="number">9</span>     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, transformer_list, idx_list, n_jobs=<span class="number">1</span>, transformer_weights=None)</span>:</span></div><div class="line"><span class="number">10</span>         self.idx_list = idx_list</div><div class="line"><span class="number">11</span>         FeatureUnion.__init__(self, transformer_list=map(<span class="keyword">lambda</span> trans:(trans[<span class="number">0</span>], trans[<span class="number">1</span>]), transformer_list), n_jobs=n_jobs, transformer_weights=transformer_weights)</div><div class="line"><span class="number">12</span> </div><div class="line"><span class="number">13</span>     <span class="comment">#由于只部分读取特征矩阵，方法fit需要重构</span></div><div class="line"><span class="number">14</span>     <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None)</span>:</span></div><div class="line"><span class="number">15</span>         transformer_idx_list = map(<span class="keyword">lambda</span> trans, idx:(trans[<span class="number">0</span>], trans[<span class="number">1</span>], idx), self.transformer_list, self.idx_list)</div><div class="line"><span class="number">16</span>         transformers = Parallel(n_jobs=self.n_jobs)(</div><div class="line"><span class="number">17</span>             <span class="comment">#从特征矩阵中提取部分输入fit方法</span></div><div class="line"><span class="number">18</span>             delayed(_fit_one_transformer)(trans, X[:,idx], y)</div><div class="line"><span class="number">19</span>             <span class="keyword">for</span> name, trans, idx <span class="keyword">in</span> transformer_idx_list)</div><div class="line"><span class="number">20</span>         self._update_transformer_list(transformers)</div><div class="line"><span class="number">21</span>         <span class="keyword">return</span> self</div><div class="line"><span class="number">22</span> </div><div class="line"><span class="number">23</span>     <span class="comment">#由于只部分读取特征矩阵，方法fit_transform需要重构</span></div><div class="line"><span class="number">24</span>     <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, X, y=None, **fit_params)</span>:</span></div><div class="line"><span class="number">25</span>         transformer_idx_list = map(<span class="keyword">lambda</span> trans, idx:(trans[<span class="number">0</span>], trans[<span class="number">1</span>], idx), self.transformer_list, self.idx_list)</div><div class="line"><span class="number">26</span>         result = Parallel(n_jobs=self.n_jobs)(</div><div class="line"><span class="number">27</span>             <span class="comment">#从特征矩阵中提取部分输入fit_transform方法</span></div><div class="line"><span class="number">28</span>             delayed(_fit_transform_one)(trans, name, X[:,idx], y,</div><div class="line"><span class="number">29</span>                                         self.transformer_weights, **fit_params)</div><div class="line"><span class="number">30</span>             <span class="keyword">for</span> name, trans, idx <span class="keyword">in</span> transformer_idx_list)</div><div class="line"><span class="number">31</span> </div><div class="line"><span class="number">32</span>         Xs, transformers = zip(*result)</div><div class="line"><span class="number">33</span>         self._update_transformer_list(transformers)</div><div class="line"><span class="number">34</span>         <span class="keyword">if</span> any(sparse.issparse(f) <span class="keyword">for</span> f <span class="keyword">in</span> Xs):</div><div class="line"><span class="number">35</span>             Xs = sparse.hstack(Xs).tocsr()</div><div class="line"><span class="number">36</span>         <span class="keyword">else</span>:</div><div class="line"><span class="number">37</span>             Xs = np.hstack(Xs)</div><div class="line"><span class="number">38</span>         <span class="keyword">return</span> Xs</div><div class="line"><span class="number">39</span> </div><div class="line"><span class="number">40</span>     <span class="comment">#由于只部分读取特征矩阵，方法transform需要重构</span></div><div class="line"><span class="number">41</span>     <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></div><div class="line"><span class="number">42</span>         transformer_idx_list = map(<span class="keyword">lambda</span> trans, idx:(trans[<span class="number">0</span>], trans[<span class="number">1</span>], idx), self.transformer_list, self.idx_list)</div><div class="line"><span class="number">43</span>         Xs = Parallel(n_jobs=self.n_jobs)(</div><div class="line"><span class="number">44</span>             <span class="comment">#从特征矩阵中提取部分输入transform方法</span></div><div class="line"><span class="number">45</span>             delayed(_transform_one)(trans, name, X[:,idx], self.transformer_weights)</div><div class="line"><span class="number">46</span>             <span class="keyword">for</span> name, trans, idx <span class="keyword">in</span> transformer_idx_list)</div><div class="line"><span class="number">47</span>         <span class="keyword">if</span> any(sparse.issparse(f) <span class="keyword">for</span> f <span class="keyword">in</span> Xs):</div><div class="line"><span class="number">48</span>             Xs = sparse.hstack(Xs).tocsr()</div><div class="line"><span class="number">49</span>         <span class="keyword">else</span>:</div><div class="line"><span class="number">50</span>             Xs = np.hstack(Xs)</div><div class="line"><span class="number">51</span>         <span class="keyword">return</span> Xs</div></pre></td></tr></table></figure></p>
<p>在本文提出的场景中，我们对特征矩阵的第1列（花的颜色）进行定性特征编码，对第2、3、4列进行对数函数转换，对第5列进行定量特征二值化处理。使用FeatureUnionExt类进行部分并行处理的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> log1p</div><div class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</div><div class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</div><div class="line"> <span class="number">4</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</div><div class="line"> <span class="number">5</span> </div><div class="line"> <span class="number">6</span> <span class="comment">#新建将部分特征矩阵进行定性特征编码的对象</span></div><div class="line"> <span class="number">7</span> step2_1 = (<span class="string">'OneHotEncoder'</span>, OneHotEncoder(sparse=<span class="keyword">False</span>))</div><div class="line"> <span class="number">8</span> <span class="comment">#新建将部分特征矩阵进行对数函数转换的对象</span></div><div class="line"> <span class="number">9</span> step2_2 = (<span class="string">'ToLog'</span>, FunctionTransformer(log1p))</div><div class="line"><span class="number">10</span> <span class="comment">#新建将部分特征矩阵进行二值化类的对象</span></div><div class="line"><span class="number">11</span> step2_3 = (<span class="string">'ToBinary'</span>, Binarizer())</div><div class="line"><span class="number">12</span> <span class="comment">#新建部分并行处理对象</span></div><div class="line"><span class="number">13</span> <span class="comment">#参数transformer_list为需要并行处理的对象列表，该列表为二元组列表，第一元为对象的名称，第二元为对象</span></div><div class="line"><span class="number">14</span> <span class="comment">#参数idx_list为相应的需要读取的特征矩阵的列</span></div><div class="line"><span class="number">15</span> step2 = (<span class="string">'FeatureUnionExt'</span>, FeatureUnionExt(transformer_list=[step2_1, step2_2, step2_3], idx_list=[[<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>]]))</div></pre></td></tr></table></figure></p>
<h1 id="流水线处理"><a href="#流水线处理" class="headerlink" title="流水线处理"></a>流水线处理</h1><p>pipeline包提供了Pipeline类来进行流水线处理。流水线上除最后一个工作以外，其他都要执行fit_transform方法，且上一个工作输出作为下一个工作的输入。最后一个工作必须实现fit方法，输入为上一个工作的输出；但是不限定一定有transform方法，因为流水线的最后一个工作可能是训练！<br>根据本文提出的场景，结合并行处理，构建完整的流水线的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> log1p</div><div class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer</div><div class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</div><div class="line"> <span class="number">4</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</div><div class="line"> <span class="number">5</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</div><div class="line"> <span class="number">6</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</div><div class="line"> <span class="number">7</span> <span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</div><div class="line"> <span class="number">8</span> <span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</div><div class="line"> <span class="number">9</span> <span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</div><div class="line"><span class="number">10</span> <span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</div><div class="line"><span class="number">11</span> <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</div><div class="line"><span class="number">12</span> </div><div class="line"><span class="number">13</span> <span class="comment">#新建计算缺失值的对象</span></div><div class="line"><span class="number">14</span> step1 = (<span class="string">'Imputer'</span>, Imputer())</div><div class="line"><span class="number">15</span> <span class="comment">#新建将部分特征矩阵进行定性特征编码的对象</span></div><div class="line"><span class="number">16</span> step2_1 = (<span class="string">'OneHotEncoder'</span>, OneHotEncoder(sparse=<span class="keyword">False</span>))</div><div class="line"><span class="number">17</span> <span class="comment">#新建将部分特征矩阵进行对数函数转换的对象</span></div><div class="line"><span class="number">18</span> step2_2 = (<span class="string">'ToLog'</span>, FunctionTransformer(log1p))</div><div class="line"><span class="number">19</span> <span class="comment">#新建将部分特征矩阵进行二值化类的对象</span></div><div class="line"><span class="number">20</span> step2_3 = (<span class="string">'ToBinary'</span>, Binarizer())</div><div class="line"><span class="number">21</span> <span class="comment">#新建部分并行处理对象，返回值为每个并行工作的输出的合并</span></div><div class="line"><span class="number">22</span> step2 = (<span class="string">'FeatureUnionExt'</span>, FeatureUnionExt(transformer_list=[step2_1, step2_2, step2_3], idx_list=[[<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>]]))</div><div class="line"><span class="number">23</span> <span class="comment">#新建无量纲化对象</span></div><div class="line"><span class="number">24</span> step3 = (<span class="string">'MinMaxScaler'</span>, MinMaxScaler())</div><div class="line"><span class="number">25</span> <span class="comment">#新建卡方校验选择特征的对象</span></div><div class="line"><span class="number">26</span> step4 = (<span class="string">'SelectKBest'</span>, SelectKBest(chi2, k=<span class="number">3</span>))</div><div class="line"><span class="number">27</span> <span class="comment">#新建PCA降维的对象</span></div><div class="line"><span class="number">28</span> step5 = (<span class="string">'PCA'</span>, PCA(n_components=<span class="number">2</span>))</div><div class="line"><span class="number">29</span> <span class="comment">#新建逻辑回归的对象，其为待训练的模型作为流水线的最后一步</span></div><div class="line"><span class="number">30</span> step6 = (<span class="string">'LogisticRegression'</span>, LogisticRegression(penalty=<span class="string">'l2'</span>))</div><div class="line"><span class="number">31</span> <span class="comment">#新建流水线处理对象</span></div><div class="line"><span class="number">32</span> <span class="comment">#参数steps为需要流水线处理的对象列表，该列表为二元组列表，第一元为对象的名称，第二元为对象</span></div><div class="line"><span class="number">33</span> pipeline = Pipeline(steps=[step1, step2, step3, step4, step5, step6])</div></pre></td></tr></table></figure></p>
<h1 id="自动化调参"><a href="#自动化调参" class="headerlink" title="自动化调参"></a>自动化调参</h1><p>网格搜索为自动化调参的常见技术之一，grid_search包提供了自动化调参的工具，包括GridSearchCV类。对组合好的对象进行训练以及调参的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> GridSearchCV</div><div class="line"><span class="number">2</span> </div><div class="line"><span class="number">3</span> <span class="comment">#新建网格搜索对象</span></div><div class="line"><span class="number">4</span> <span class="comment">#第一参数为待训练的模型</span></div><div class="line"><span class="number">5</span>  <span class="comment">#param_grid为待调参数组成的网格，字典格式，键为参数名称（格式“对象名称__子对象名称__参数名称”），值为可取的参数值列表</span></div><div class="line"><span class="number">6</span>  grid_search = GridSearchCV(pipeline, param_grid=&#123;<span class="string">'FeatureUnionExt__ToBinary__threshold'</span>:[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>], <span class="string">'LogisticRegression__C'</span>:[<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.8</span>]&#125;)</div><div class="line"><span class="number">7</span> <span class="comment">#训练以及调参</span></div><div class="line"><span class="number">8</span> grid_search.fit(iris.data, iris.target)</div></pre></td></tr></table></figure></p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>externals.joblib包提供了dump和load方法来持久化和加载内存数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="comment">#持久化数据</span></div><div class="line"><span class="number">2</span> <span class="comment">#第一个参数为内存中的对象</span></div><div class="line"><span class="number">3</span> <span class="comment">#第二个参数为保存在文件系统中的名称</span></div><div class="line"><span class="number">4</span> <span class="comment">#第三个参数为压缩级别，0为不压缩，3为合适的压缩级别</span></div><div class="line"><span class="number">5</span> dump(grid_search, <span class="string">'grid_search.dmp'</span>, compress=<span class="number">3</span>)</div><div class="line"><span class="number">6</span> <span class="comment">#从文件系统中加载数据到内存中</span></div><div class="line"><span class="number">7</span> grid_search = load(<span class="string">'grid_search.dmp'</span>)</div></pre></td></tr></table></figure></p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="http://i.imgur.com/U20pnnw.png" alt=""><br>注意：组合和持久化都会涉及pickle技术，在sklearn的技术文档中有说明，将lambda定义的函数作为FunctionTransformer的自定义转换函数将不能pickle化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>2015年我设计了一个基于sklearn的自动化特征工程的工具，其以Mysql数据库作为原始数据源，提供了“灵活的”特征提取、特征处理的配置方法，同时重新封装了数据、特征和模型，以方便调度系统识别。说灵活，其实也只是通过配置文件的方式定义每个特征的提取和处理的sql语句。但是纯粹使用sql语句来进行特征处理是很勉强的，除去特征提取以外，我又造了一回轮子，原来sklearn提供了这么优秀的特征处理、工作组合等功能。所以，我在这个博客中先不提任何算法和模型，先从数据挖掘工作的第一步开始，使用基于Python的各个工具把大部分步骤都走了一遍（抱歉，我暂时忽略了特征提取），希望这样的梳理能够少让初学者走弯路吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天找资料的时候，发现一个很牛的大神。写的博客是真的好。慢慢的汲取养分。&lt;br&gt;转自：&lt;a href=&quot;http://www.cnblogs.com/jasonfreak/p/5448462.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http
    
    </summary>
    
      <category term="sklearn笔记" scheme="https://xiaoybboy.github.io/categories/sklearn%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据挖掘" scheme="https://xiaoybboy.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="sklearn" scheme="https://xiaoybboy.github.io/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>用sklearn做数据预处理</title>
    <link href="https://xiaoybboy.github.io/2017/06/06/%E7%94%A8sklearn%E5%81%9A%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>https://xiaoybboy.github.io/2017/06/06/用sklearn做数据预处理/</id>
    <published>2017-06-06T06:57:48.000Z</published>
    <updated>2017-06-06T08:03:38.260Z</updated>
    
    <content type="html"><![CDATA[<p>用sklearn做机器学习的时候，一直都是用的时候再去网上找资料，结果每次都要重新找，很麻烦。终于下决心好好总结一下，平时经常用的一些sklearn的东西（或其他相关知识），希望能写成一个系列的笔记。</p>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这次就总结下sklearn数据预处理。主要是别人博客的知识，汇总一下。<br>sklearn是一个常用的机器学习库，其中的sklearn.preprocessing模块包含了常用的预处理函数，包括数据的清洗，如缺失值和零值的填充，数据标准化，二值化和哑编码等。</p>
<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="1-标准化（均值去除和按方差比例缩放）"><a href="#1-标准化（均值去除和按方差比例缩放）" class="headerlink" title="1.标准化（均值去除和按方差比例缩放）"></a>1.标准化（均值去除和按方差比例缩放）</h2><p>将数据转化为均值为零，方差为一的数据，形如标准正态分布（高斯分布）。实际操作中，经常忽略特征数据的分布形状，移除每个特征均值，划分离散特征的标准差，从而等级化，进而实现数据中心化。在利用机器学习算法（例如SVM）的过程中，如果目标函数中的一个特征的方差的阶数的量级高于其他特征的方差，那么这一特征就会在目标函数中占主导地位，从而“淹没”其他特征的作用。<br>数据标准化的意义：</p>
<ol>
<li>消除量纲影响和变量自身变异大小和数值大小的影响。</li>
<li>数据同趋化，主要解决不同性质数据问题，对不同性质指标直接加总不能正确反映不同作用力的综合结果<h3 id="Z-score标准化"><a href="#Z-score标准化" class="headerlink" title="Z-score标准化"></a>Z-score标准化</h3>基于原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。<br>公式为：(X-mean)/std  （mean为均值，std为标准差）<br>计算时对每个属性/每列分别进行。<br>将数据按期属性（按列进行）减去其均值，并处以其方差。得到的结果是，对于每个属性/每列来说所有数据都聚集在0附近，方差为1。<br>用sklearn实现有两种方式：<br>1.使用sklearn.preprocessing.scale()函数，可以直接将给定数据进行标准化。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</div><div class="line"><span class="meta">... </span>              [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line"><span class="meta">... </span>              [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled = preprocessing.scale(X)</div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled                                          </div><div class="line">array([[ <span class="number">0.</span>  ..., <span class="number">-1.22</span>...,  <span class="number">1.33</span>...],</div><div class="line">       [ <span class="number">1.22</span>...,  <span class="number">0.</span>  ..., <span class="number">-0.26</span>...],</div><div class="line">       [<span class="number">-1.22</span>...,  <span class="number">1.22</span>..., <span class="number">-1.06</span>...]])</div><div class="line"> </div><div class="line">&gt;&gt;&gt;<span class="comment">#处理后数据的均值和方差</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled.mean(axis=<span class="number">0</span>)</div><div class="line">array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])<span class="comment">#零均值</span></div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled.std(axis=<span class="number">0</span>)</div><div class="line">array([ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>])<span class="comment">#单位方差</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>2.使用sklearn.preprocessing.StandardScaler类，使用该类的好处在于可以保存训练集中的参数（均值、方差）直接使用其对象转换测试集数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>scaler = preprocessing.StandardScaler().fit(X)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>scaler</div><div class="line">StandardScaler(copy=<span class="keyword">True</span>, with_mean=<span class="keyword">True</span>, with_std=<span class="keyword">True</span>)</div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.mean_                                      </div><div class="line">array([ <span class="number">1.</span> ...,  <span class="number">0.</span> ...,  <span class="number">0.33</span>...])</div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.std_                                       </div><div class="line">array([ <span class="number">0.81</span>...,  <span class="number">0.81</span>...,  <span class="number">1.24</span>...])</div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.transform(X)                               </div><div class="line">array([[ <span class="number">0.</span>  ..., <span class="number">-1.22</span>...,  <span class="number">1.33</span>...],</div><div class="line">       [ <span class="number">1.22</span>...,  <span class="number">0.</span>  ..., <span class="number">-0.26</span>...],</div><div class="line">       [<span class="number">-1.22</span>...,  <span class="number">1.22</span>..., <span class="number">-1.06</span>...]])</div><div class="line"> </div><div class="line"> </div><div class="line">&gt;&gt;&gt;<span class="comment">#可以直接使用训练集对测试集数据进行转换</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.transform([[<span class="number">-1.</span>,  <span class="number">1.</span>, <span class="number">0.</span>]])                </div><div class="line">array([[<span class="number">-2.44</span>...,  <span class="number">1.22</span>..., <span class="number">-0.26</span>...]])</div></pre></td></tr></table></figure></p>
<h3 id="MinMax标准化-最小最大值标准化"><a href="#MinMax标准化-最小最大值标准化" class="headerlink" title="MinMax标准化(最小最大值标准化)"></a>MinMax标准化(最小最大值标准化)</h3><p>将数据缩放至给定的最小值与最大值之间，通常是０与１之间，可用MinMaxScaler实现。或者将最大的绝对值缩放至单位大小，可用MaxAbsScaler实现。<br>对原始数据的线性变换，使结果落到[0,1]区间，转换函数如下：<br>x ＝ (x - min)/(max - min)<br>max: 样本数据的最大值<br>min: 为样本数据的最小值<br>使用这种方法的目的包括：<br>1、对于方差非常小的属性可以增强其稳定性。<br>2、维持稀疏矩阵中为0的条目。<br>sklearn实现MinMax标准化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</div><div class="line"><span class="meta">... </span>                    [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line"><span class="meta">... </span>                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>min_max_scaler = preprocessing.MinMaxScaler()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_train_minmax = min_max_scaler.fit_transform(X_train)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_train_minmax</div><div class="line">array([[ <span class="number">0.5</span>       ,  <span class="number">0.</span>        ,  <span class="number">1.</span>        ],</div><div class="line">       [ <span class="number">1.</span>        ,  <span class="number">0.5</span>       ,  <span class="number">0.33333333</span>],</div><div class="line">       [ <span class="number">0.</span>        ,  <span class="number">1.</span>        ,  <span class="number">0.</span>        ]])</div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#将相同的缩放应用到测试集数据中</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_test = np.array([[ <span class="number">-3.</span>, <span class="number">-1.</span>,  <span class="number">4.</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_test_minmax = min_max_scaler.transform(X_test)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_test_minmax</div><div class="line">array([[<span class="number">-1.5</span>       ,  <span class="number">0.</span>        ,  <span class="number">1.66666667</span>]])</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#缩放因子等属性</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>min_max_scaler.scale_                             </div><div class="line">array([ <span class="number">0.5</span>       ,  <span class="number">0.5</span>       ,  <span class="number">0.33</span>...])</div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>min_max_scaler.min_                               </div><div class="line">array([ <span class="number">0.</span>        ,  <span class="number">0.5</span>       ,  <span class="number">0.33</span>...])</div></pre></td></tr></table></figure></p>
<p>MinMaxScaler()默认的缩放范围是（0,1）。在构造类对象的时候也可以直接指定最大最小值的范围：feature_range=(min, max)<br>例如：min_max_scaler = preprocessing.MinMaxScaler(feature_range=(min, max))</p>
<h3 id="MaxAbsScaler（绝对值最大标准化）"><a href="#MaxAbsScaler（绝对值最大标准化）" class="headerlink" title="MaxAbsScaler（绝对值最大标准化）"></a>MaxAbsScaler（绝对值最大标准化）</h3><p>与上述标准化方法相似，但是它通过除以最大值将训练集缩放至[-1,1]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],  </div><div class="line">                     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],  </div><div class="line">                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])  </div><div class="line">max_abs_scaler = preprocessing.MaxAbsScaler()  </div><div class="line">X_train_maxabs = max_abs_scaler.fit_transform(X_train)  </div><div class="line"><span class="comment"># doctest +NORMALIZE_WHITESPACE^, out: array([[ 0.5, -1.,  1. ], [ 1. , 0. ,  0. ],       [ 0. ,  1. , -0.5]])  </span></div><div class="line">X_test = np.array([[ <span class="number">-3.</span>, <span class="number">-1.</span>,  <span class="number">4.</span>]])  </div><div class="line">X_test_maxabs = max_abs_scaler.transform(X_test) <span class="comment">#out: array([[-1.5, -1. ,  2. ]])  </span></div><div class="line">max_abs_scaler.scale_  <span class="comment">#out: array([ 2.,  1.,  2.])</span></div></pre></td></tr></table></figure></p>
<h2 id="正则化（Normalization）规范化"><a href="#正则化（Normalization）规范化" class="headerlink" title="正则化（Normalization）规范化"></a>正则化（Normalization）规范化</h2><p>这个本人理解的不是很透，先把别人的结论放上来。而且从找到的资料来看，这个翻译比较模糊。<br>文档上说：Normalization is the process of scaling individual samples to have unit norm.<br>正则化的过程是将每个样本缩放到单位范数（每个样本的范数为1），如果后面要使用如二次型（点积）或者其它核方法计算两个样本之间的相似性这个方法会很有用。<br>将样本缩放成单位向量，标准化数据是针对特征来说的，而现在正则化是对样本来做的，是用样本数据除以他的范式。<br>sklearn实现使用preprocessing.normalize(x, norm = ‘l1’)方法，具体的参数说明详见sklearn文档<br><a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" target="_blank" rel="external">http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize</a><br>1.使用preprocessing.normalize()函数对指定数据进行转换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</div><div class="line"><span class="meta">... </span>     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line"><span class="meta">... </span>     [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_normalized = preprocessing.normalize(X, norm=<span class="string">'l2'</span>)</div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_normalized                                      </div><div class="line">array([[ <span class="number">0.40</span>..., <span class="number">-0.40</span>...,  <span class="number">0.81</span>...],</div><div class="line">       [ <span class="number">1.</span>  ...,  <span class="number">0.</span>  ...,  <span class="number">0.</span>  ...],</div><div class="line">       [ <span class="number">0.</span>  ...,  <span class="number">0.70</span>..., <span class="number">-0.70</span>...]])</div></pre></td></tr></table></figure></p>
<p>2.使用processing.Normalizer()类实现对训练集和测试集的拟合和转换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer = preprocessing.Normalizer().fit(X)  <span class="comment"># fit does nothing</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer</div><div class="line">Normalizer(copy=<span class="keyword">True</span>, norm=<span class="string">'l2'</span>)</div><div class="line"> </div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer.transform(X)                            </div><div class="line">array([[ <span class="number">0.40</span>..., <span class="number">-0.40</span>...,  <span class="number">0.81</span>...],</div><div class="line">       [ <span class="number">1.</span>  ...,  <span class="number">0.</span>  ...,  <span class="number">0.</span>  ...],</div><div class="line">       [ <span class="number">0.</span>  ...,  <span class="number">0.70</span>..., <span class="number">-0.70</span>...]])</div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer.transform([[<span class="number">-1.</span>,  <span class="number">1.</span>, <span class="number">0.</span>]])             </div><div class="line">array([[<span class="number">-0.70</span>...,  <span class="number">0.70</span>...,  <span class="number">0.</span>  ...]])</div></pre></td></tr></table></figure></p>
<p>对于l2 norm,变换后每个样本的各维特征的平方和为1。类似地，L1 norm则是变换后每个样本的各维特征的绝对值和为1。还有max norm，则是将每个样本的各维特征除以该样本各维特征的最大值.</p>
<h2 id="二值化（Binarization）"><a href="#二值化（Binarization）" class="headerlink" title="二值化（Binarization）"></a>二值化（Binarization）</h2><p>将数值型数据转化为布尔型的二值数据，可以设置一个阈值（threshold）<br>在sklearn中，sklearn.preprocessing.Binarizer函数可以实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</div><div class="line"><span class="meta">... </span>     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line"><span class="meta">... </span>     [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]]</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer = preprocessing.Binarizer().fit(X)  <span class="comment"># fit does nothing</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer</div><div class="line">Binarizer(copy=<span class="keyword">True</span>, threshold=<span class="number">0.0</span>)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer.transform(X)</div><div class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>]])</div></pre></td></tr></table></figure></p>
<p>而且还可以调整阈值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer = preprocessing.Binarizer(threshold=<span class="number">1.1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer.transform(X)</div><div class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</div></pre></td></tr></table></figure></p>
<h2 id="标签预处理（Label-preprocessing）"><a href="#标签预处理（Label-preprocessing）" class="headerlink" title="标签预处理（Label preprocessing）"></a>标签预处理（Label preprocessing）</h2><h3 id="标签二值化（Label-binarization）"><a href="#标签二值化（Label-binarization）" class="headerlink" title="标签二值化（Label binarization）"></a>标签二值化（Label binarization）</h3><p>LabelBinarizer通常用于通过一个多类标签（label）列表，创建一个label指示器矩阵<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lb = preprocessing.LabelBinarizer()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lb.fit([<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>])</div><div class="line">LabelBinarizer(neg_label=<span class="number">0</span>, pos_label=<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lb.classes_</div><div class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lb.transform([<span class="number">1</span>, <span class="number">6</span>])</div><div class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</div><div class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</div></pre></td></tr></table></figure></p>
<p>上例中每个实例中只有一个标签（label），LabelBinarizer也支持每个实例数据显示多个标签：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lb.fit_transform([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>,)]) <span class="comment">#(1,2)实例中就包含两个label</span></div><div class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</div><div class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lb.classes_</div><div class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div></pre></td></tr></table></figure></p>
<h3 id="标签编码（Label-encoding）"><a href="#标签编码（Label-encoding）" class="headerlink" title="标签编码（Label encoding）"></a>标签编码（Label encoding）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>le = preprocessing.LabelEncoder()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>le.fit([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>])</div><div class="line">LabelEncoder()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>le.classes_</div><div class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>le.transform([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>])</div><div class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>le.inverse_transform([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</div><div class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>])</div></pre></td></tr></table></figure>
<p>也可以用于非数值类型的标签到数值类型标签的转化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>le = preprocessing.LabelEncoder()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>le.fit([<span class="string">"paris"</span>, <span class="string">"paris"</span>, <span class="string">"tokyo"</span>, <span class="string">"amsterdam"</span>])</div><div class="line">LabelEncoder()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(le.classes_)</div><div class="line">[<span class="string">'amsterdam'</span>, <span class="string">'paris'</span>, <span class="string">'tokyo'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>le.transform([<span class="string">"tokyo"</span>, <span class="string">"tokyo"</span>, <span class="string">"paris"</span>])</div><div class="line">array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(le.inverse_transform([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]))</div><div class="line">[<span class="string">'tokyo'</span>, <span class="string">'tokyo'</span>, <span class="string">'paris'</span>]</div></pre></td></tr></table></figure></p>
<h2 id="离散变量编码"><a href="#离散变量编码" class="headerlink" title="离散变量编码"></a>离散变量编码</h2><p>例如性别有‘男’， ‘女’，然而计算机的许多模型都只能在数值型数据当中进行计算，如果我们简单的将‘男’为1，‘女’为0，虽然也可以完成转换，但是在转换的过程当中我们引入了大小关系，就是‘女’ &lt; ‘男’，这会对后续模型应用造成不必要的困扰。<br>解决方法为OneHotEncode，就是将其转化为二进制串，除了当前值所在位置为1，其他全部为0，如[0,0,1,0,0], [0,1,0,0,0].。性别可表示为男为[1,0]，女为[0,1]，这样一个性别特征就转化成了两个特征。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(&#123;<span class="string">'pet'</span>: [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'dog'</span>, <span class="string">'fish'</span>],<span class="string">'age'</span>: [<span class="number">4</span> , <span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>],</div><div class="line"><span class="string">'salary'</span>:[<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>]&#125;)</div><div class="line"><span class="comment">#例如有数据比较大，OneHotEncoder会生成非常多的特征，或者为字符串数据，先转化为数字，所以先用LabelEncoder处理。</span></div><div class="line">label = preprocessing.LabelEncoder()</div><div class="line">df[<span class="string">'pet'</span>] = label.fit_transform(df[<span class="string">'pet'</span>])</div><div class="line">one_hot = preprocessing.OneHotEncoder(sparse = <span class="keyword">False</span>)</div><div class="line"><span class="keyword">print</span> one_hot.fit_transform(df[[<span class="string">'pet'</span>]])</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">before</div><div class="line">   age  pet  salary</div><div class="line">0    4    0       4</div><div class="line">1    6    1       5</div><div class="line">2    3    1       1</div><div class="line">3    3    2       1</div><div class="line">after</div><div class="line">[[ 1.  0.  0.]</div><div class="line"> [ 0.  1.  0.]</div><div class="line"> [ 0.  1.  0.]</div><div class="line"> [ 0.  0.  1.]]</div></pre></td></tr></table></figure>
<h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>sklearn中的Imputer类提供了一些基本的方法来处理缺失值，如使用均值、中位值或者缺失值所在列中频繁出现的值来替换。<br>例如使用均值来处理的实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>imp = Imputer(missing_values=<span class="string">'NaN'</span>, strategy=<span class="string">'mean'</span>, axis=<span class="number">0</span>)  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>imp.fit([[<span class="number">1</span>, <span class="number">2</span>], [np.nan, <span class="number">3</span>], [<span class="number">7</span>, <span class="number">6</span>]])  </div><div class="line">Imputer(axis=<span class="number">0</span>, copy=<span class="keyword">True</span>, missing_values=<span class="string">'NaN'</span>, strategy=<span class="string">'mean'</span>, verbose=<span class="number">0</span>)  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[np.nan, <span class="number">2</span>], [<span class="number">6</span>, np.nan], [<span class="number">7</span>, <span class="number">6</span>]]  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(imp.transform(X))                             </div><div class="line">[[ <span class="number">4.</span>          <span class="number">2.</span>        ]  </div><div class="line"> [ <span class="number">6.</span>          <span class="number">3.666</span>...]  </div><div class="line"> [ <span class="number">7.</span>          <span class="number">6.</span>        ]]</div></pre></td></tr></table></figure></p>
<p>Imputer也支持稀疏矩阵作为输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> sp</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X = sp.csc_matrix([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>], [<span class="number">7</span>, <span class="number">6</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>imp = Imputer(missing_values=<span class="number">0</span>, strategy=<span class="string">'mean'</span>, axis=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>imp.fit(X)</div><div class="line">Imputer(axis=<span class="number">0</span>, copy=<span class="keyword">True</span>, missing_values=<span class="number">0</span>, strategy=<span class="string">'mean'</span>, verbose=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X_test = sp.csc_matrix([[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">6</span>, <span class="number">0</span>], [<span class="number">7</span>, <span class="number">6</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(imp.transform(X_test))                      </div><div class="line">[[ <span class="number">4.</span>          <span class="number">2.</span>        ]</div><div class="line"> [ <span class="number">6.</span>          <span class="number">3.666</span>...]</div><div class="line"> [ <span class="number">7.</span>          <span class="number">6.</span>        ]]</div></pre></td></tr></table></figure></p>
<h2 id="维度拓展"><a href="#维度拓展" class="headerlink" title="维度拓展"></a>维度拓展</h2><p>考虑复杂化非线性特征，就是生成多项式特征，例如(x1,x2)−&gt;(x1,x2,x21,x1x2,x22)，会使特征数量增加<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">poly = PolynomialFeatures(<span class="number">2</span>)<span class="comment">#参数为阶数</span></div><div class="line">poly.fit_transform(X) </div><div class="line"><span class="string">'''</span></div><div class="line">before </div><div class="line">[[0, 1],</div><div class="line"> [2, 3],</div><div class="line"> [4, 5]]</div><div class="line">after</div><div class="line">[[  1.,   0.,   1.,   0.,   0.,   1.],</div><div class="line"> [  1.,   2.,   3.,   4.,   6.,   9.],</div><div class="line"> [  1.,   4.,   5.,  16.,  20.,  25.]]</div></pre></td></tr></table></figure></p>
<p>参考：<br><a href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-normalization" target="_blank" rel="external">http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-normalization</a><br><a href="http://blog.csdn.net/u010787640/article/details/60956164" target="_blank" rel="external">http://blog.csdn.net/u010787640/article/details/60956164</a><br><a href="http://blog.csdn.net/shmily_skx/article/details/52946414" target="_blank" rel="external">http://blog.csdn.net/shmily_skx/article/details/52946414</a><br><a href="http://www.cnblogs.com/chaosimple/p/4153167.html" target="_blank" rel="external">http://www.cnblogs.com/chaosimple/p/4153167.html</a><br><a href="http://blog.csdn.net/csmqq/article/details/51461696" target="_blank" rel="external">http://blog.csdn.net/csmqq/article/details/51461696</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用sklearn做机器学习的时候，一直都是用的时候再去网上找资料，结果每次都要重新找，很麻烦。终于下决心好好总结一下，平时经常用的一些sklearn的东西（或其他相关知识），希望能写成一个系列的笔记。&lt;/p&gt;
&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=
    
    </summary>
    
      <category term="sklearn学习" scheme="https://xiaoybboy.github.io/categories/sklearn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://xiaoybboy.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="sklearn" scheme="https://xiaoybboy.github.io/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>记一次坑爹的windows下安装xgboost的经历</title>
    <link href="https://xiaoybboy.github.io/2017/06/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9D%91%E7%88%B9%E7%9A%84windows%E4%B8%8B%E5%AE%89%E8%A3%85xgboost%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>https://xiaoybboy.github.io/2017/06/05/记一次坑爹的windows下安装xgboost的经历/</id>
    <published>2017-06-05T07:51:28.000Z</published>
    <updated>2017-06-05T08:19:25.301Z</updated>
    
    <content type="html"><![CDATA[<p>近来做一个比赛，一个识别鼠标轨迹是人还是机器的二分类问题。自己用SVM和神经网络等传统的机器学习的方法都试过了，但是提交之后的结果发现并不好。正好前几天研究过几个别人做的其他比赛的解决方案，发现用的boosting方法比较多,其中尤其是xgboost。于是打算再用xgboost的模型做一下，看看结果怎么样。<br>但是，安装xgboost的过程并不轻松。试了好几种方法，最后花了一下午时间，终于安装成功。<br><a id="more"></a></p>
<h1 id="1-使用纯命令行安装"><a href="#1-使用纯命令行安装" class="headerlink" title="1.使用纯命令行安装"></a>1.使用纯命令行安装</h1><p>参考：<a href="http://www.th7.cn/system/win/201603/157092.shtml" target="_blank" rel="external">http://www.th7.cn/system/win/201603/157092.shtml</a><br><a href="http://blog.csdn.net/ychanmy/article/details/50972530" target="_blank" rel="external">http://blog.csdn.net/ychanmy/article/details/50972530</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git clone --recursive https://github.com/dmlc/xgboost$ cd xgboost</div><div class="line">$ git submodule init</div><div class="line">$ git submodule update</div><div class="line">$cp make/mingw64.mk config.mk</div><div class="line">$make -j4</div><div class="line"></div><div class="line">$cd python-package</div><div class="line">$python setup.py install</div></pre></td></tr></table></figure></p>
<p>但是，为毛别人都能成功，我就是一直报错呢，而且google不到答案，哎。。。<br><img src="http://i.imgur.com/wMngVUt.png" alt=""><br>看来这个东西看人品的，没办法，找其他的办法吧！</p>
<h1 id="2-使用旧版本的xgboost"><a href="#2-使用旧版本的xgboost" class="headerlink" title="2.使用旧版本的xgboost"></a>2.使用旧版本的xgboost</h1><p>最终，在<a href="http://m.blog.csdn.net/article/details?id=53118803找到一个可用的解决方法。" target="_blank" rel="external">http://m.blog.csdn.net/article/details?id=53118803找到一个可用的解决方法。</a><br>下载旧版本的xgboost,<a href="http://download.csdn.net/detail/zhuqiuhui/9476012" target="_blank" rel="external">http://download.csdn.net/detail/zhuqiuhui/9476012</a><br>然后就很简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$cd xgboost</div><div class="line">$make -j4</div><div class="line"></div><div class="line">$cd python-package</div><div class="line">$python setup.py install</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/9VfyKQV.png" alt=""><br>终于！不知道旧版本的xgbosot有没有什么问题，先用用试试吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近来做一个比赛，一个识别鼠标轨迹是人还是机器的二分类问题。自己用SVM和神经网络等传统的机器学习的方法都试过了，但是提交之后的结果发现并不好。正好前几天研究过几个别人做的其他比赛的解决方案，发现用的boosting方法比较多,其中尤其是xgboost。于是打算再用xgboost的模型做一下，看看结果怎么样。&lt;br&gt;但是，安装xgboost的过程并不轻松。试了好几种方法，最后花了一下午时间，终于安装成功。&lt;br&gt;
    
    </summary>
    
      <category term="大数据比赛" scheme="https://xiaoybboy.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="xgboost" scheme="https://xiaoybboy.github.io/tags/xgboost/"/>
    
  </entry>
  
  <entry>
    <title>sklearn PCA降维</title>
    <link href="https://xiaoybboy.github.io/2017/06/01/sklearn-PCA%E9%99%8D%E7%BB%B4/"/>
    <id>https://xiaoybboy.github.io/2017/06/01/sklearn-PCA降维/</id>
    <published>2017-06-01T10:01:31.000Z</published>
    <updated>2017-06-06T06:58:53.935Z</updated>
    
    <content type="html"><![CDATA[<p>对于太多的特征，一般需要进行降维处理。PCA是最常用的降维的方法，sklearn提供了PCA降维的方法。</p>
<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class sklearn.decomposition.PCA(n_components=None, copy=True, whiten=False, svd_solver=&apos;auto&apos;, tol=0.0, iterated_power=&apos;auto&apos;, random_state=None)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h1><ol>
<li>n_components:<br>意义：PCA算法中所要保留的主成分个数n，也即保留下来的特征个数n<br>类型：int 或者 string，缺省时默认为None，所有成分被保留。<br> 赋值为int，比如n_components=1，将把原始数据降到一个维度。<br> 赋值为string，比如n_components=’mle’，将自动选取特征个数n，使得满足所要求的方差百分比。</li>
<li>copy:<br>类型：bool，True或者False，缺省时默认为True。<br>意义：表示是否在运行算法时，将原始训练数据复制一份。若为True，则运行PCA算法后，原始训练数据的值不            会有任何改变，因为是在原始数据的副本上进行运算；若为False，则运行PCA算法后，原始训练数据的              值会改，因为是在原始数据上进行降维计算。</li>
<li>whiten:<br>类型：bool，缺省时默认为False<br>意义：白化，使得每个特征具有相同的方差。</li>
</ol>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>和参数差不多，参考<a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html" target="_blank" rel="external">http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html</a></p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>fit(X[, y]) —— Fit the model with X.<br>fit_transform(X[, y])—— Fit the model with X and apply the dimensionality reduction on X.<br>get_covariance() —— Compute data covariance with the generative model.<br>get_params([deep]) —— Get parameters for this estimator.<br>get_precision() —— Compute data precision matrix with the generative model.<br>inverse_transform(X) —— Transform data back to its original space, i.e.,<br>score(X[, y]) —— Return the average log-likelihood of all samples<br>score_samples(X) —— Return the log-likelihood of each sample<br>set_params(**params) —— Set the parameters of this estimator.<br>transform(X) —— Apply the dimensionality reduction on X.<br>详细说明：</p>
<ol>
<li>fit(X,y=None)<br>fit()可以说是scikit-learn中通用的方法，每个需要训练的算法都会有fit()方法，它其实就是算法中的“训练”这一步骤。因为PCA是无监督学习算法，此处y自然等于None。</li>
<li>fit(X)，表示用数据X来训练PCA模型。<br>函数返回值：调用fit方法的对象本身。比如pca.fit(X)，表示用X对pca这个对象进行训练。</li>
<li>fit_transform(X)<br>用X来训练PCA模型，同时返回降维后的数据。<br>newX=pca.fit_transform(X)，newX就是降维后的数据。</li>
<li>inverse_transform()<br>将降维后的数据转换成原始数据，X=pca.inverse_transform(newX)</li>
<li>transform(X)<br>将数据X转换成降维后的数据。当模型训练好后，对于新输入的数据，都可以用transform方法来降维。<br>此外，还有get_covariance()、get_precision()、get_params(deep=True)、score(X, y=None)等方法，参考上面的英文。<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1>以一组二维的数据data为例，data如下，一共12个样本（x,y），其实就是分布在直线y=x上的点，并且聚集在x=1、2、3、4上，各3个。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>data  </div><div class="line">array([[ <span class="number">1.</span>  ,  <span class="number">1.</span>  ],  </div><div class="line">       [ <span class="number">0.9</span> ,  <span class="number">0.95</span>],  </div><div class="line">       [ <span class="number">1.01</span>,  <span class="number">1.03</span>],  </div><div class="line">       [ <span class="number">2.</span>  ,  <span class="number">2.</span>  ],  </div><div class="line">       [ <span class="number">2.03</span>,  <span class="number">2.06</span>],  </div><div class="line">       [ <span class="number">1.98</span>,  <span class="number">1.89</span>],  </div><div class="line">       [ <span class="number">3.</span>  ,  <span class="number">3.</span>  ],  </div><div class="line">       [ <span class="number">3.03</span>,  <span class="number">3.05</span>],  </div><div class="line">       [ <span class="number">2.89</span>,  <span class="number">3.1</span> ],  </div><div class="line">       [ <span class="number">4.</span>  ,  <span class="number">4.</span>  ],  </div><div class="line">       [ <span class="number">4.06</span>,  <span class="number">4.02</span>],  </div><div class="line">       [ <span class="number">3.97</span>,  <span class="number">4.01</span>]])</div></pre></td></tr></table></figure>
</li>
</ol>
<p>data这组数据，有两个特征，因为两个特征是近似相等的，所以用一个特征就能表示了，即可以降到一维。下面就来看看怎么用sklearn中的PCA算法包。<br>（1）n_components设置为1，copy默认为True，可以看到原始数据data并未改变，newData是一维的，并且明显地将原始数据分成了四类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA   </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pca=PCA(n_components=<span class="number">1</span>)  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>newData=pca.fit_transform(data)  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>newData  </div><div class="line">array([[<span class="number">-2.12015916</span>],  </div><div class="line">       [<span class="number">-2.22617682</span>],  </div><div class="line">       [<span class="number">-2.09185561</span>],  </div><div class="line">       [<span class="number">-0.70594692</span>],  </div><div class="line">       [<span class="number">-0.64227841</span>],  </div><div class="line">       [<span class="number">-0.79795758</span>],  </div><div class="line">       [ <span class="number">0.70826533</span>],  </div><div class="line">       [ <span class="number">0.76485312</span>],  </div><div class="line">       [ <span class="number">0.70139695</span>],  </div><div class="line">       [ <span class="number">2.12247757</span>],  </div><div class="line">       [ <span class="number">2.17900746</span>],  </div><div class="line">       [ <span class="number">2.10837406</span>]])  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data  </div><div class="line">array([[ <span class="number">1.</span>  ,  <span class="number">1.</span>  ],  </div><div class="line">       [ <span class="number">0.9</span> ,  <span class="number">0.95</span>],  </div><div class="line">       [ <span class="number">1.01</span>,  <span class="number">1.03</span>],  </div><div class="line">       [ <span class="number">2.</span>  ,  <span class="number">2.</span>  ],  </div><div class="line">       [ <span class="number">2.03</span>,  <span class="number">2.06</span>],  </div><div class="line">       [ <span class="number">1.98</span>,  <span class="number">1.89</span>],  </div><div class="line">       [ <span class="number">3.</span>  ,  <span class="number">3.</span>  ],  </div><div class="line">       [ <span class="number">3.03</span>,  <span class="number">3.05</span>],  </div><div class="line">       [ <span class="number">2.89</span>,  <span class="number">3.1</span> ],  </div><div class="line">       [ <span class="number">4.</span>  ,  <span class="number">4.</span>  ],  </div><div class="line">       [ <span class="number">4.06</span>,  <span class="number">4.02</span>],  </div><div class="line">       [ <span class="number">3.97</span>,  <span class="number">4.01</span>]])</div></pre></td></tr></table></figure></p>
<p>（2）将copy设置为False，原始数据data将发生改变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>pca=PCA(n_components=<span class="number">1</span>,copy=<span class="keyword">False</span>)  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>newData=pca.fit_transform(data)  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data  </div><div class="line">array([[<span class="number">-1.48916667</span>, <span class="number">-1.50916667</span>],  </div><div class="line">       [<span class="number">-1.58916667</span>, <span class="number">-1.55916667</span>],  </div><div class="line">       [<span class="number">-1.47916667</span>, <span class="number">-1.47916667</span>],  </div><div class="line">       [<span class="number">-0.48916667</span>, <span class="number">-0.50916667</span>],  </div><div class="line">       [<span class="number">-0.45916667</span>, <span class="number">-0.44916667</span>],  </div><div class="line">       [<span class="number">-0.50916667</span>, <span class="number">-0.61916667</span>],  </div><div class="line">       [ <span class="number">0.51083333</span>,  <span class="number">0.49083333</span>],  </div><div class="line">       [ <span class="number">0.54083333</span>,  <span class="number">0.54083333</span>],  </div><div class="line">       [ <span class="number">0.40083333</span>,  <span class="number">0.59083333</span>],  </div><div class="line">       [ <span class="number">1.51083333</span>,  <span class="number">1.49083333</span>],  </div><div class="line">       [ <span class="number">1.57083333</span>,  <span class="number">1.51083333</span>],  </div><div class="line">       [ <span class="number">1.48083333</span>,  <span class="number">1.50083333</span>]])</div></pre></td></tr></table></figure></p>
<p>（3）n_components设置为’mle’，看看效果，自动降到了1维。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>pca=PCA(n_components=<span class="string">'mle'</span>)  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>newData=pca.fit_transform(data)  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>newData  </div><div class="line">array([[<span class="number">-2.12015916</span>],  </div><div class="line">       [<span class="number">-2.22617682</span>],  </div><div class="line">       [<span class="number">-2.09185561</span>],  </div><div class="line">       [<span class="number">-0.70594692</span>],  </div><div class="line">       [<span class="number">-0.64227841</span>],  </div><div class="line">       [<span class="number">-0.79795758</span>],  </div><div class="line">       [ <span class="number">0.70826533</span>],  </div><div class="line">       [ <span class="number">0.76485312</span>],  </div><div class="line">       [ <span class="number">0.70139695</span>],  </div><div class="line">       [ <span class="number">2.12247757</span>],  </div><div class="line">       [ <span class="number">2.17900746</span>],  </div><div class="line">       [ <span class="number">2.10837406</span>]])</div></pre></td></tr></table></figure></p>
<p>（4）对象的属性值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>pca.n_components  </div><div class="line"><span class="number">1</span>  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pca.explained_variance_ratio_  </div><div class="line">array([ <span class="number">0.99910873</span>])  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pca.explained_variance_  </div><div class="line">array([ <span class="number">2.55427003</span>])  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pca.get_params  </div><div class="line">&lt;bound method PCA.get_params of PCA(copy=<span class="keyword">True</span>, n_components=<span class="number">1</span>, whiten=<span class="keyword">False</span>)&gt;</div></pre></td></tr></table></figure></p>
<p>我们所训练的pca对象的n_components值为1，即保留1个特征，该特征的方差为2.55427003，占所有特征的方差百分比为0.99910873，意味着几乎保留了所有的信息。get_params返回各个参数的值。<br>（5）对象的方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>newA=pca.transform(A)</div><div class="line">```  </div><div class="line">对新的数据A，用已训练好的pca模型进行降维。</div><div class="line">```python</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pca.set_params(copy=<span class="keyword">False</span>)  </div><div class="line">PCA(copy=<span class="keyword">False</span>, n_components=<span class="number">1</span>, whiten=<span class="keyword">False</span>)</div></pre></td></tr></table></figure></p>
<p>设置参数。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>在一个论坛上看到的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#导入数值计算库</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="comment">#导入科学计算库</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="comment">#导入数据预处理库</span></div><div class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</div><div class="line"><span class="comment">#导入PCA算法库</span></div><div class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</div><div class="line"></div><div class="line"><span class="comment">#读取贷款状态数据从创建名为LoanStats3a的数据表</span></div><div class="line">LoanStats3a=pd.DataFrame(pd.read_csv(<span class="string">'LoanStats3a.csv'</span>))</div><div class="line"> </div><div class="line"><span class="comment">#查看数据表内容</span></div><div class="line">LoanStats3a.head()</div><div class="line"></div><div class="line"><span class="comment">#删除包含空值的特征</span></div><div class="line">LoanStats3a=LoanStats3a.dropna()</div><div class="line"></div><div class="line"><span class="comment">#设置特征表X</span></div><div class="line"><span class="comment">#将贷款数据表中的贷款特征数据单独提取出来，用于后面的降维操作。</span></div><div class="line">X = np.array(LoanStats3a[[<span class="string">'loan_amnt'</span>, <span class="string">'funded_amnt_inv'</span>, <span class="string">'installment'</span>,</div><div class="line"><span class="string">'annual_inc'</span>, <span class="string">'dti'</span>, <span class="string">'delinq_2yrs'</span>, <span class="string">'inq_last_6mths'</span>, <span class="string">'open_acc'</span>,</div><div class="line"><span class="string">'pub_rec'</span>, <span class="string">'revol_bal'</span>, <span class="string">'total_acc'</span>, <span class="string">'out_prncp'</span>, <span class="string">'out_prncp_inv'</span>,</div><div class="line"><span class="string">'total_pymnt'</span>, <span class="string">'total_pymnt_inv'</span>, <span class="string">'total_rec_prncp'</span>, <span class="string">'total_rec_int'</span>,</div><div class="line"><span class="string">'total_rec_late_fee'</span>, <span class="string">'recoveries'</span>, <span class="string">'collection_recovery_fee'</span>,</div><div class="line"><span class="string">'last_pymnt_amnt'</span>]])</div><div class="line"></div><div class="line"><span class="comment">#对特征数据进行标准化处理,去除不同数据的单位限制，将它们转化为无量纲的纯数值。</span></div><div class="line">sc = StandardScaler()</div><div class="line">X_std = sc.fit_transform(X)</div><div class="line"></div><div class="line"><span class="comment">#创建PCA对象，n_components=3</span></div><div class="line">pca = decomposition.PCA(n_components=<span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="comment">#使用PCA对特征进行降维</span></div><div class="line">X_std_pca = pca.fit_transform(X_std)</div><div class="line"></div><div class="line"><span class="comment">#下面的写法与上面相同,下面进行了白化变换，数据还原之后进行了方差的归一化</span></div><div class="line">pca=PCA(n_components=<span class="number">6</span>,whiten=<span class="keyword">True</span>)</div><div class="line">pca.fit(X_std)</div><div class="line">newData=pca.transform(X_std)</div><div class="line">X=pca.inverse_transform(newData)</div></pre></td></tr></table></figure></p>
<p>本文参考：<a href="http://blog.csdn.net/u012162613/article/details/42192293" target="_blank" rel="external">http://blog.csdn.net/u012162613/article/details/42192293</a><br>        <a href="http://www.aboutyun.com/thread-21655-1-1.html" target="_blank" rel="external">http://www.aboutyun.com/thread-21655-1-1.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于太多的特征，一般需要进行降维处理。PCA是最常用的降维的方法，sklearn提供了PCA降维的方法。&lt;/p&gt;
&lt;h1 id=&quot;函数原型&quot;&gt;&lt;a href=&quot;#函数原型&quot; class=&quot;headerlink&quot; title=&quot;函数原型&quot;&gt;&lt;/a&gt;函数原型&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;class sklearn.decomposition.PCA(n_components=None, copy=True, whiten=False, svd_solver=&amp;apos;auto&amp;apos;, tol=0.0, iterated_power=&amp;apos;auto&amp;apos;, random_state=None)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="sklearn学习" scheme="https://xiaoybboy.github.io/categories/sklearn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://xiaoybboy.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="sklearn" scheme="https://xiaoybboy.github.io/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>lightgbm python接口的安装</title>
    <link href="https://xiaoybboy.github.io/2017/05/31/lightgbm-python%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>https://xiaoybboy.github.io/2017/05/31/lightgbm-python接口的安装/</id>
    <published>2017-05-31T10:32:15.000Z</published>
    <updated>2017-05-31T10:55:34.637Z</updated>
    
    <content type="html"><![CDATA[<p>最近看一些大数据比赛大神们开源的解决方案，发现他们经常使用所谓数据挖掘三驾马车。恶补了一下boosting方法.现在把lightgbm的python接口的安装过程记录下来，免得以后忘了。<br>LightGBM（Light Gradient Boosting Machine）是一个基于决策树算法的快速的、分布式的、高性能 gradient boosting（GBDT、GBRT、GBM 或 MART）框架，可被用于排行、分类以及其他许多机器学习任务中。<br>开源项目地址： <a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="external">https://github.com/Microsoft/LightGBM</a><br><a id="more"></a><br>优势：</p>
<blockquote>
<p>更快的训练效率<br>低内存使用<br>更好的准确率<br>支持并行学习<br>可处理大规模数据</p>
</blockquote>
<h1 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1.下载源码"></a>1.下载源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone --recursive https://github.com/Microsoft/LightGBM</div></pre></td></tr></table></figure>
<h1 id="2-编译dll"><a href="#2-编译dll" class="headerlink" title="2.编译dll"></a>2.编译dll</h1><p>进入下载的LightGBM目录下，用VS打开windows/LightGBM.sln，生成时选择DLL和x64，然后进行编译。dll文件就会在windows/x64/DLL/目录里。<br><img src="http://i.imgur.com/lRW0CwU.png" alt=""></p>
<h1 id="3-安装python包"><a href="#3-安装python包" class="headerlink" title="3.安装python包"></a>3.安装python包</h1><p>进入目录python-package，执行命令<br><code>python setup.py install</code></p>
<h1 id="4-测试是否安装成功"><a href="#4-测试是否安装成功" class="headerlink" title="4.测试是否安装成功"></a>4.测试是否安装成功</h1><p>进入examples\python-guide，执行样例<br><code>python .\simple_example.py</code><br>如果没有报错，那就说明安装成功了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看一些大数据比赛大神们开源的解决方案，发现他们经常使用所谓数据挖掘三驾马车。恶补了一下boosting方法.现在把lightgbm的python接口的安装过程记录下来，免得以后忘了。&lt;br&gt;LightGBM（Light Gradient Boosting Machine）是一个基于决策树算法的快速的、分布式的、高性能 gradient boosting（GBDT、GBRT、GBM 或 MART）框架，可被用于排行、分类以及其他许多机器学习任务中。&lt;br&gt;开源项目地址： &lt;a href=&quot;https://github.com/Microsoft/LightGBM&quot;&gt;https://github.com/Microsoft/LightGBM&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://xiaoybboy.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://xiaoybboy.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://xiaoybboy.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>hexo个人域名配置</title>
    <link href="https://xiaoybboy.github.io/2017/05/31/hexo%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/"/>
    <id>https://xiaoybboy.github.io/2017/05/31/hexo个人域名配置/</id>
    <published>2017-05-31T09:20:02.000Z</published>
    <updated>2017-05-31T10:26:15.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-在万网上购买域名"><a href="#1-在万网上购买域名" class="headerlink" title="1.在万网上购买域名"></a>1.在万网上购买域名</h1><p><a href="https://wanwang.aliyun.com" target="_blank" rel="external">https://wanwang.aliyun.com</a>  或者其他域名购买网站</p>
<h1 id="2-配置域名解析"><a href="#2-配置域名解析" class="headerlink" title="2.配置域名解析"></a>2.配置域名解析</h1><p>进入你的管理后台<br><a id="more"></a><br><img src="http://i.imgur.com/8TZJ4q9.png" alt="管理后台"></p>
<h1 id="3-添加域名解析"><a href="#3-添加域名解析" class="headerlink" title="3.添加域名解析"></a>3.添加域名解析</h1><p>按下图所示添加域名解析。<br><img src="http://i.imgur.com/sRLsOBt.png" alt="添加域名解析"><br>其中，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。</p>
<h1 id="4-创建CNAME文件"><a href="#4-创建CNAME文件" class="headerlink" title="4.创建CNAME文件"></a>4.创建CNAME文件</h1><p> 这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：xiaoyb.me。</p>
<h1 id="5-发布并访问"><a href="#5-发布并访问" class="headerlink" title="5.发布并访问"></a>5.发布并访问</h1><p>重新发布hexo d -g然后就可以访问你的新域名了。<br>快点试试吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-在万网上购买域名&quot;&gt;&lt;a href=&quot;#1-在万网上购买域名&quot; class=&quot;headerlink&quot; title=&quot;1.在万网上购买域名&quot;&gt;&lt;/a&gt;1.在万网上购买域名&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://wanwang.aliyun.com&quot;&gt;https://wanwang.aliyun.com&lt;/a&gt;  或者其他域名购买网站&lt;/p&gt;
&lt;h1 id=&quot;2-配置域名解析&quot;&gt;&lt;a href=&quot;#2-配置域名解析&quot; class=&quot;headerlink&quot; title=&quot;2.配置域名解析&quot;&gt;&lt;/a&gt;2.配置域名解析&lt;/h1&gt;&lt;p&gt;进入你的管理后台&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/tags/hexo/"/>
    
      <category term="域名" scheme="https://xiaoybboy.github.io/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>为什么新生代需要两个Survivor区</title>
    <link href="https://xiaoybboy.github.io/2017/04/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B0%E7%94%9F%E4%BB%A3%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AASurvivor%E5%8C%BA/"/>
    <id>https://xiaoybboy.github.io/2017/04/12/为什么新生代需要两个Survivor区/</id>
    <published>2017-04-12T14:14:32.000Z</published>
    <updated>2017-04-13T01:57:05.158Z</updated>
    
    <content type="html"><![CDATA[<p>在JVM的新生代内存中，为什么除了Eden区，还要设置两个Survivor区？</p>
<h1 id="为什么要有Survivor区"><a href="#为什么要有Survivor区" class="headerlink" title="为什么要有Survivor区"></a>为什么要有Survivor区</h1><p>先不去想为什么有两个Survivor区，第一个问题是，设置Survivor区的意义在哪里？<br><a id="more"></a><br>堆内存分类<br><img src="http://i.imgur.com/SYmUFnA.png" alt="堆内存分类"><br>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。你也许会问，执行时间长有什么坏处？频发的Full GC消耗的时间是非常可观的，这一点会影响大型程序的执行和响应速度，更不要说某些连接会因为超时发生连接错误了。</p>
<p>好，那我们来想想在没有Survivor的情况下，有没有什么解决办法，可以避免上述情况：<br><img src="http://i.imgur.com/e1qd82c.png" alt=""><br>显而易见，没有Survivor的话，上述两种解决方案都不能从根本上解决问题。</p>
<p>我们可以得到第一条结论：<font color="red" size="2"><strong>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</strong></font></p>
<h1 id="为什么要设置两个Survivor区"><a href="#为什么要设置两个Survivor区" class="headerlink" title="为什么要设置两个Survivor区"></a>为什么要设置两个Survivor区</h1><font color="red" size="2"><strong>设置两个Survivor区最大的好处就是解决了碎片化</strong></font>

<p>下面我们来分析一下。</p>
<p>为什么一个Survivor区不行？第一部分中，我们知道了必须设置Survivor区。假设现在只有一个survivor区，我们来模拟一下流程：<br>刚刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，下一次Eden满了的时候，问题来了，此时进行Minor GC，Eden和Survivor各有一些存活对象，如果此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。<br>我绘制了一幅图来表明这个过程。其中色块代表对象，白色框分别代表Eden区（大）和Survivor区（小）。Eden区理所当然大一些，否则新建对象很快就导致Eden区满，进而触发Minor GC，有悖于初衷。<br><img src="http://i.imgur.com/NmSEUK3.png" alt=""><br>一个Survivor区带来碎片化</p>
<p>碎片化带来的风险是极大的，严重影响Java程序的性能。堆空间被散布的对象占据不连续的内存，最直接的结果就是，堆中没有足够大的连续内存空间，接下去如果程序需要给一个内存需求很大的对象分配内存。。。画面太美不敢看。。。这就好比我们爬山的时候，背包里所有东西紧挨着放，最后就可能省出一块完整的空间放相机。如果每件行李之间隔一点空隙乱放，很可能最后就要一路把相机挂在脖子上了。</p>
<p>那么，顺理成章的，应该建立两块Survivor区，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。下图中每部分的意义和上一张图一样，就不加注释了。<br><img src="http://i.imgur.com/Y0x3nl1.png" alt=""><br>两块Survivor避免碎片化<br>上述机制最大的好处就是，整个过程中，永远有一个survivor space是空的，另一个非空的survivor space无碎片。</p>
<p>那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满，因此，我认为两块Survivor区是经过权衡之后的最佳方案。</p>
<p>转自：<a href="http://blog.csdn.net/antony9118/article/details/51425581" target="_blank" rel="external">http://blog.csdn.net/antony9118/article/details/51425581</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JVM的新生代内存中，为什么除了Eden区，还要设置两个Survivor区？&lt;/p&gt;
&lt;h1 id=&quot;为什么要有Survivor区&quot;&gt;&lt;a href=&quot;#为什么要有Survivor区&quot; class=&quot;headerlink&quot; title=&quot;为什么要有Survivor区&quot;&gt;&lt;/a&gt;为什么要有Survivor区&lt;/h1&gt;&lt;p&gt;先不去想为什么有两个Survivor区，第一个问题是，设置Survivor区的意义在哪里？&lt;br&gt;
    
    </summary>
    
      <category term="java虚拟机" scheme="https://xiaoybboy.github.io/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java虚拟机" scheme="https://xiaoybboy.github.io/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="垃圾回收" scheme="https://xiaoybboy.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法详解</title>
    <link href="https://xiaoybboy.github.io/2017/04/11/%E5%9B%9E%E6%9C%94%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://xiaoybboy.github.io/2017/04/11/回朔算法详解/</id>
    <published>2017-04-11T03:47:08.000Z</published>
    <updated>2017-04-11T04:32:56.989Z</updated>
    
    <content type="html"><![CDATA[<p>刷题的时候碰到一个很常见的算法-回溯法，看了一些博客，感觉这个讲得通俗易懂。转过来，后面有些自己的补充。<br>&emsp;&emsp;回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。<br><a id="more"></a><br>首先我们来看一道题目：<br>Combinations：Given two integers n and k,return all possible combinations of k numbersout of 1 … n. For example, If n = 4 and k =2, a solution is:</p>
<p>[<br> [2,4],<br> [3,4],<br> [2,3],<br> [1,2],<br> [1,3],<br> [1,4],<br>]<br>（做一个白话版的描述，给你两个整数 n和k，从1-n中选择k个数字的组合。比如n=4，那么从1,2,3,4中选取两个数字的组合，包括图上所述的四种。）<br>然后我们看看题目给出的框架：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要求返回的类型是List<list<integer>&gt; 也就是说将所有可能的组合list（由整数构成）放入另一个list（由list构成）中。<br>现在进行套路教学：要求返回List<list<integer>&gt;，那我就给你一个List<list<integer>&gt;，因此</list<integer></list<integer></list<integer></p>
<ol>
<li>定义一个全局List<list<integer>&gt; result=new ArrayList<list<integer>&gt;();</list<integer></list<integer></li>
<li>定义一个辅助的方法（函数）public void backtracking(int n,int k, List<integer>list){}<br>n k 总是要有的吧，加上这两个参数，前面提到List<integer> 是数字的组合，也是需要的吧，这三个是必须的，没问题吧。（可以尝试性地写参数，最后不需要的删除）</integer></integer></li>
<li>接着就是我们的重头戏了，如何实现这个算法？对于n=4，k=2，1,2,3,4中选2个数字，我们可以做如下尝试，加入先选择1，那我们只需要再选择一个数字，注意这时候k=1了（此时只需要选择1个数字啦）。当然，我们也可以先选择2,3 或者4，通俗化一点，我们可以选择（1-n）的所有数字，这个是可以用一个循环来描述？每次选择一个加入我们的链表list中，下一次只要再选择k-1个数字。那什么时候结束呢？当然是k<0的时候啦，这时候都选完了。 有了上面的分析，我们可以开始填写public="" void="" backtracking(int="" n,int="" k,="" list<integer=""> list){}中的内容。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> start,List&lt;Integer&gt; list)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>)    <span class="keyword">return</span>;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;  <span class="comment">//k==0表示已经找到了k个数字的组合，这时候加入全局result中  </span></div><div class="line">            result.add(<span class="keyword">new</span> ArrayList(list));  </div><div class="line">        &#125;<span class="keyword">else</span>&#123;  </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)&#123;  </div><div class="line">                list.add(i);<span class="comment">//尝试性的加入i  </span></div><div class="line">                <span class="comment">//开始回溯啦，下一次要找的数字减少一个所以用k-1，i+1见后面分析  </span></div><div class="line">                backtracking(n,k-<span class="number">1</span>,i+<span class="number">1</span>,list);  </div><div class="line">                <span class="comment">//（留白，有用=。=）  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</0的时候啦，这时候都选完了。></li>
</ol>
<p>观察一下上述代码，我们加入了一个start变量，它是i的起点。为什么要加入它呢？比如我们第一次加入了1，下一次搜索的时候还能再搜索1了么？肯定不可以啊！我们必须从他的下一个数字开始，也就是2 、3或者4啦。所以start就是一个开始标记这个很重要啦！<br>这时候我们在主方法中加入backtracking(n,k,1,list);调试后发现答案不对啊！为什么我的答案比他长那么多？</p>
<p>回溯回溯当然要退回再走啦，你不退回，当然又臭又长了！所以我们要在刚才代码注释留白处加上退回语句。仔细分析刚才的过程，我们每次找到了1,2这一对答案以后，下一次希望2退出然后让3进来，1 3就是我们要找的下一个组合。如果不回退，找到了2 ，3又进来，找到了3，4又进来，所以就出现了我们的错误答案。正确的做法就是加上：list.remove(list.size()-1);他的作用就是每次清除一个空位 让后续元素加入。寻找成功，最后一个元素要退位，寻找不到，方法不可行，那么我们回退，也要移除最后一个元素。<br>所以完整的程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </div><div class="line">   List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();  </div><div class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;  </div><div class="line">       List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </div><div class="line">       backtracking(n,k,<span class="number">1</span>,list);  </div><div class="line">       <span class="keyword">return</span> result;  </div><div class="line">    &#125;  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> start,List&lt;Integer&gt;list)</span></span>&#123;  </div><div class="line">       <span class="keyword">if</span>(k&lt;<span class="number">0</span>) <span class="keyword">return</span> ;  </div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;  </div><div class="line">           result.add(<span class="keyword">new</span> ArrayList(list));  </div><div class="line">       &#125;<span class="keyword">else</span>&#123;  </div><div class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)&#123;  </div><div class="line">                list.add(i);  </div><div class="line">                backtracking(n,k-<span class="number">1</span>,i+<span class="number">1</span>,list);  </div><div class="line">                list.remove(list.size()-<span class="number">1</span>);  </div><div class="line">            &#125;  </div><div class="line">       &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是不是有点想法了？那么我们操刀一下。<br>Combination Sum<br>Given a set ofcandidate numbers (C) and a target number (T), findall unique combinations in C where thecandidate numbers sums toT.<br>The same repeated numbermay be chosen from C unlimited numberof times.<br>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>For example,given candidate set [2, 3, 6, 7] and target 7,<br>A solution set is:<br>[<br> [7],<br> [2,2, 3]<br>]<br>（容我啰嗦地白话下，给你一个正数数组candidate[],一个目标值target，寻找里面所有的不重复组合，让其和等于target，给你[2,3,6,7] 2+2+3=7 ,7=7,所以可能组合为[2,2,3],[7]）<br>按照前述的套路走一遍：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target) &#123;</div><div class="line">       Arrays.sort(candidates);</div><div class="line">       List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,)</span></span>&#123;       </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>全局List<list<integer>&gt; result先定义</list<integer></li>
<li>回溯backtracking方法要定义，数组candidates 目标target 开头start 辅助链表List<integer> list都加上。</integer></li>
<li>分析算法：以[2,3,6,7]  每次尝试加入数组任何一个值，用循环来描述，表示依次选定一个值<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(inti=start;i&lt;candidates.length;i++)&#123;</div><div class="line">       list.add(candidates[i]);</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>接下来回溯方法再调用。比如第一次选了2，下次还能再选2是吧，所以每次start都可以从当前i开始（ps：如果不允许重复，从i+1开始）。第一次选择2，下一次要凑的数就不是7了，而是7-2，也就是5，一般化就是remain=target-candidates[i],所以回溯方法为：<br>backtracking(candidates,target-candidates[i],i,list);<br>然后加上退回语句：list.remove(list.size()-1);<br>那么什么时候找到的解符合要求呢？自然是remain（注意区分初始的target）=0了，表示之前的组合恰好能凑出target。如果remain<0 表示凑的数太大了，组合不可行，要回退。当remain="">0 说明凑的还不够，继续凑。<br>所以完整方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </div><div class="line">    List&lt;List&lt;Integer&gt;&gt; result=newArrayList&lt;List&lt;Integer&gt;&gt;();  </div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt;combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;  </div><div class="line">        Arrays.sort(candidates);<span class="comment">//所给数组可能无序，排序保证解按照非递减组合  </span></div><div class="line">        List&lt;Integer&gt; list=newArrayList&lt;Integer&gt;();  </div><div class="line">        backtracking(candidates,target,<span class="number">0</span>,list);<span class="comment">//给定target，start=0表示从数组第一个开始  </span></div><div class="line">        <span class="keyword">return</span> result;<span class="comment">//返回解的组合链表  </span></div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[]candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,List&lt;Integer&gt; list)</span></span>&#123;  </div><div class="line">         </div><div class="line">            <span class="keyword">if</span>(target&lt;<span class="number">0</span>)    <span class="keyword">return</span>;<span class="comment">//凑过头了  </span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;  </div><div class="line">                result.add(newArrayList&lt;&gt;(list));<span class="comment">//正好凑出答案，开心地加入解的链表    </span></div><div class="line">            &#125;<span class="keyword">else</span>&#123;  </div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.length;i++)&#123;<span class="comment">//循环试探每个数  </span></div><div class="line">                    list.add(candidates[i]);<span class="comment">//尝试加入  </span></div><div class="line">           			<span class="comment">//下一次凑target-candidates[i]，允许重复，还是从i开始  </span></div><div class="line">                   backtracking(candidates,target-candidates[i],i,list);                     </div><div class="line">           		   list.remove(list.size()-<span class="number">1</span>);<span class="comment">//回退  </span></div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">         </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></0></p>
<p>是不是觉得还是有迹可循的？下一篇博客将部分回溯算法拿出来，供大家更好地发现其中的套路。<br>This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.</p>
<p>Subsets : <a href="https://leetcode.com/problems/subsets/" target="_blank" rel="external">https://leetcode.com/problems/subsets/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</div><div class="line">        tempList.add(nums[i]);</div><div class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</div><div class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Subsets II (contains duplicates) : <a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="external">https://leetcode.com/problems/subsets-ii/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></div><div class="line">        tempList.add(nums[i]);</div><div class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</div><div class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Permutations : <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="external">https://leetcode.com/problems/permutations/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">   List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">   <span class="comment">// Arrays.sort(nums); // not necessary</span></div><div class="line">   backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</div><div class="line">   <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums)</span></span>&#123;</div><div class="line">   <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</div><div class="line">      list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">   &#125; <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123; </div><div class="line">         <span class="keyword">if</span>(tempList.contains(nums[i])) <span class="keyword">continue</span>; <span class="comment">// element already exists, skip</span></div><div class="line">         tempList.add(nums[i]);</div><div class="line">         backtrack(list, tempList, nums);</div><div class="line">         tempList.remove(tempList.size() - <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Permutations II (contains duplicates) : <a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="external">https://leetcode.com/problems/permutations-ii/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">boolean</span> [] used)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</div><div class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</div><div class="line">            used[i] = <span class="keyword">true</span>; </div><div class="line">            tempList.add(nums[i]);</div><div class="line">            backtrack(list, tempList, nums, used);</div><div class="line">            used[i] = <span class="keyword">false</span>; </div><div class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Combination Sum : <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="external">https://leetcode.com/problems/combination-sum/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">    <span class="keyword">else</span>&#123; </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</div><div class="line">            tempList.add(nums[i]);</div><div class="line">            backtrack(list, tempList, nums, remain - nums[i], i); <span class="comment">// not i + 1 because we can reuse same elements</span></div><div class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Combination Sum II (can’t reuse same element) : <a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="external">https://leetcode.com/problems/combination-sum-ii/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></div><div class="line">            tempList.add(nums[i]);</div><div class="line">            backtrack(list, tempList, nums, remain - nums[i], i + <span class="number">1</span>);</div><div class="line">            tempList.remove(tempList.size() - <span class="number">1</span>); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Palindrome Partitioning : <a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="external">https://leetcode.com/problems/palindrome-partitioning/</a></p>
<pre><code class="java"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) {
   List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();
   backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), s, <span class="number">0</span>);
   <span class="keyword">return</span> list;
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, <span class="keyword">int</span> start)</span></span>{
   <span class="keyword">if</span>(start == s.length())
      list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));
   <span class="keyword">else</span>{
      <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.length(); i++){
         <span class="keyword">if</span>(isPalindrome(s, start, i)){
            tempList.add(s.substring(start, i + <span class="number">1</span>));
            backtrack(list, tempList, s, i + <span class="number">1</span>);
            tempList.remove(tempList.size() - <span class="number">1</span>);
         }
      }
   }
}

<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>{
   <span class="keyword">while</span>(low &lt; high)
      <span class="keyword">if</span>(s.charAt(low++) != s.charAt(high--)) <span class="keyword">return</span> <span class="keyword">false</span>;
   <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题的时候碰到一个很常见的算法-回溯法，看了一些博客，感觉这个讲得通俗易懂。转过来，后面有些自己的补充。&lt;br&gt;&amp;emsp;&amp;emsp;回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯法" scheme="https://xiaoybboy.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java源码之StringBuffer,StringBuilder</title>
    <link href="https://xiaoybboy.github.io/2017/04/10/Java%E6%BA%90%E7%A0%81%E4%B9%8BStringBuffer-StringBuilder/"/>
    <id>https://xiaoybboy.github.io/2017/04/10/Java源码之StringBuffer-StringBuilder/</id>
    <published>2017-04-10T05:24:17.000Z</published>
    <updated>2017-04-13T01:41:30.427Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java源码" scheme="https://xiaoybboy.github.io/categories/java%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="java源码" scheme="https://xiaoybboy.github.io/tags/java%E6%BA%90%E7%A0%81/"/>
    
      <category term="StringBuffer" scheme="https://xiaoybboy.github.io/tags/StringBuffer/"/>
    
      <category term="StringBuilder" scheme="https://xiaoybboy.github.io/tags/StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>Java源码之HashSet</title>
    <link href="https://xiaoybboy.github.io/2017/04/07/Java%E6%BA%90%E7%A0%81%E4%B9%8BHashSet/"/>
    <id>https://xiaoybboy.github.io/2017/04/07/Java源码之HashSet/</id>
    <published>2017-04-07T03:10:20.000Z</published>
    <updated>2017-04-08T01:35:21.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>1.HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序，特别是它不保证该顺序恒久不变。而且HashSet允许使用 null 元素。<br>2.HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” Set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</div></pre></td></tr></table></figure></p>
<p>3.HashSet通过iterator()返回的迭代器是fail-fast的。<br>4.HashSet的继承关系如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;  </span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;  </div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure></p>
<h1 id="HashSet实现"><a href="#HashSet实现" class="headerlink" title="HashSet实现"></a>HashSet实现</h1><p>HashSet是基于HashMap实现的，底层使用HashMap来保存所有元素，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成.</p>
<h2 id="HashSet属性"><a href="#HashSet属性" class="headerlink" title="HashSet属性"></a>HashSet属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </div><div class="line"><span class="number">2</span>.	  <span class="comment">// Dummy value to associate with an Object in the backing Map </span></div><div class="line"><span class="number">3</span>.	<span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span></div><div class="line"><span class="number">4</span>.	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure>
<p>可以看到，HashSet 实际上是使用 HashMap 来保存数据的。而且主要用的是 HashMap的 key。<br>PRESENT是什么东西呢？看上面的注释。dummy的意思是 挂名代表，傀儡。所以，可知：<br>PRESENT是向map中插入key-value对应的value<br>因为HashSet中只需要用到key，而HashMap是key-value键值对；<br>所以，向map中添加键值对时，键值对的值固定是PRESENT。每个set集合<br>中的元素都是HashMap的key 值（这也就保证了HashSet集合中不能有重复元素），而    它们的value值都是 PRESENT。</p>
<h2 id="HashSet构造函数"><a href="#HashSet构造函数" class="headerlink" title="HashSet构造函数"></a>HashSet构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	 <span class="comment">/**  </span></div><div class="line">2.	     * 默认的无参构造器，构造一个空的HashSet。</div><div class="line">3.	     *  </div><div class="line">4.	     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。  </div><div class="line">5.	     */    </div><div class="line"><span class="number">6</span>.	    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;    </div><div class="line"><span class="number">7</span>.	    		map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();    </div><div class="line"><span class="number">8</span>.	    &#125;    </div><div class="line"><span class="number">9</span>.	    <span class="comment">/**  </span></div><div class="line">10.	     * 构造一个包含指定collection中的元素的新set。  </div><div class="line">11.	     * 实际底层使用默认的加载因子0.75和足以包含指定  </div><div class="line">12.	     * collection中所有元素的初始容量来创建一个HashMap。  </div><div class="line">13.	     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。  </div><div class="line">14.	     */    </div><div class="line"><span class="number">15</span>.	    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    </div><div class="line"><span class="number">16</span>.	     <span class="comment">//为什么是Math.max((int) (c.size()/.75f) + 1, 16)？</span></div><div class="line"><span class="number">17</span>.	    <span class="comment">//实际上默认的HashMap的加载因子是0.75,c.size()/0.75 就是HashMap的实际容量，而 16 是默认的HashMap的初始容量。所以取两者的较大值作为 HashSet的容量。</span></div><div class="line"><span class="number">18</span>.	    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));   </div><div class="line"><span class="number">19</span>.	    <span class="comment">// 使用Collection实现的Iterator迭代器，将集合c的元素一个个加入HashSet中</span></div><div class="line"><span class="number">20</span>.	    	addAll(c);    </div><div class="line"><span class="number">21</span>.	   &#125;    </div><div class="line"><span class="number">22</span>.	    <span class="comment">/**  </span></div><div class="line">23.	     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。  </div><div class="line">24.	     *  </div><div class="line">25.	     * 实际底层以以指定的initialCapacity和loadFactor构造一个空的HashMap。  </div><div class="line">26.	     * <span class="doctag">@param</span> initialCapacity 初始容量。  </div><div class="line">27.	     * <span class="doctag">@param</span> loadFactor 加载因子。  </div><div class="line">28.	    */    </div><div class="line"><span class="number">29</span>.	    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;    </div><div class="line"><span class="number">30</span>.	   		map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);    </div><div class="line"><span class="number">31</span>.	    &#125;    </div><div class="line"><span class="number">32</span>.	    <span class="comment">/**  </span></div><div class="line">33.	     * 以指定的initialCapacity构造一个空的HashSet。  </div><div class="line">34.	    *  </div><div class="line">35.	     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。  </div><div class="line">36.	     * <span class="doctag">@param</span> initialCapacity 初始容量。  </div><div class="line">37.	     */    </div><div class="line"><span class="number">38</span>.	   <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;    </div><div class="line"><span class="number">39</span>.	    		map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity);    </div><div class="line"><span class="number">40</span>.	    &#125;    </div><div class="line"><span class="number">41</span>.	    <span class="comment">/**  </span></div><div class="line">42.	     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。  </div><div class="line">43.	    * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。  </div><div class="line">44.	     *  </div><div class="line">45.	     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。  </div><div class="line">46.     * <span class="doctag">@param</span> initialCapacity 初始容量。  </div><div class="line">47.	     * <span class="doctag">@param</span> loadFactor 加载因子。  </div><div class="line">48.     * <span class="doctag">@param</span> dummy 标记。  没有实际意义</div><div class="line">49.	    */    </div><div class="line"><span class="number">50</span>.	   HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;    </div><div class="line"><span class="number">51</span>.   map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);    </div><div class="line"><span class="number">52</span>.	    &#125;</div></pre></td></tr></table></figure>
<h2 id="HashSet方法"><a href="#HashSet方法" class="headerlink" title="HashSet方法"></a>HashSet方法</h2><p>因为HashSet底层是HashMap实现，所以它的方法大都是直接调用HashMap的方法。</p>
<h3 id="add-remove"><a href="#add-remove" class="headerlink" title="add(),remove()"></a>add(),remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="comment">// 将元素(e)添加到HashSet中，也就是将元素作为Key放入HashMap中public boolean add(E e) &#123;  </span></div><div class="line"><span class="number">2</span>.	      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;  <span class="comment">//可以看到PRESENT是value值。</span></div><div class="line"><span class="number">3</span>.	  &#125;  </div><div class="line"><span class="number">4</span>.	<span class="comment">//  删除HashSet中的元素(o)，其实是在HashMap中删除了以o为key的Entry</span></div><div class="line"><span class="number">5</span>.	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line"><span class="number">6</span>.	      <span class="keyword">return</span> map.remove(o)==PRESENT;  </div><div class="line"><span class="number">7</span>.	  &#125;  </div><div class="line"><span class="number">1</span>.	  <span class="comment">// 清空HashMap,的clear方法清空所有Entry</span></div><div class="line"><span class="number">2</span>.	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">3</span>.	        map.clear();    </div><div class="line"><span class="number">4</span>.	  &#125;</div></pre></td></tr></table></figure>
<p>具体可参考HashMap的源码。</p>
<h3 id="iterator-size-，isEmpty"><a href="#iterator-size-，isEmpty" class="headerlink" title="iterator(),size()，isEmpty()"></a>iterator(),size()，isEmpty()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;  </div><div class="line"><span class="number">2</span>.	     <span class="comment">// 实际上返回的是HashMap的“key集合”的迭代器</span></div><div class="line"><span class="number">3</span>.	       <span class="keyword">return</span> map.keySet().iterator();  </div><div class="line"><span class="number">4</span>.	   &#125;  </div><div class="line"><span class="number">5</span>.	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </div><div class="line"><span class="number">6</span>.	       <span class="keyword">return</span> map.size();  </div><div class="line"><span class="number">7</span>.	   &#125;  </div><div class="line"><span class="number">8</span>.	 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  </div><div class="line"><span class="number">9</span>.	       <span class="keyword">return</span> map.isEmpty(); <span class="comment">//查看map是否是空 </span></div><div class="line"><span class="number">10</span>.	   &#125;  </div><div class="line"><span class="number">11</span>.	   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line"><span class="number">12</span>.	       <span class="keyword">return</span> map.containsKey(o); <span class="comment">//map中是否包含键 0 </span></div><div class="line"><span class="number">13</span>.	   &#125;</div></pre></td></tr></table></figure>
<p>看名字很容易就知道是干嘛的，都是直接用的HashMap的方法。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="comment">/** </span></div><div class="line">2.	     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </div><div class="line">3.	    * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到  HashSet中。 </div><div class="line">4.	     */  </div><div class="line"><span class="number">5</span>.	<span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </div><div class="line"><span class="number">6</span>.	      <span class="keyword">try</span> &#123;  </div><div class="line"><span class="number">7</span>.	          HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();  </div><div class="line"><span class="number">8</span>.	          newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </div><div class="line"><span class="number">9</span>.	          <span class="keyword">return</span> newSet;  </div><div class="line"><span class="number">10</span>.	      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </div><div class="line"><span class="number">11</span>.	          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);  </div><div class="line"><span class="number">12</span>.	      &#125;  </div><div class="line"><span class="number">13</span>.	  &#125;</div></pre></td></tr></table></figure>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	     <span class="comment">// java.io.Serializable的写入流中 </span></div><div class="line"><span class="number">2</span>.	    <span class="comment">// 将HashSet的“总的容量，加载因子，实际容量，所有的元素”都写入到输出流中  </span></div><div class="line"><span class="number">3</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span>  </span></div><div class="line">4.	        <span class="keyword">throws</span> java.io.IOException &#123;  </div><div class="line"><span class="number">5</span>.	        <span class="comment">// Write out any hidden serialization magic  </span></div><div class="line"><span class="number">6</span>.	        s.defaultWriteObject();  </div><div class="line"><span class="number">7</span>.	        s.writeInt(map.capacity());  </div><div class="line"><span class="number">8</span>.	        s.writeFloat(map.loadFactor());  </div><div class="line"><span class="number">9</span>.	        <span class="comment">// Write out size  </span></div><div class="line"><span class="number">10</span>.	        s.writeInt(map.size());  </div><div class="line"><span class="number">11</span>.	        <span class="comment">// Write out all elements in the proper order.  </span></div><div class="line"><span class="number">12</span>.	        <span class="keyword">for</span> (Iterator i=map.keySet().iterator(); i.hasNext(); )  </div><div class="line"><span class="number">13</span>.	            s.writeObject(i.next());  </div><div class="line"><span class="number">14</span>.	    &#125;  </div><div class="line"><span class="number">15</span>.	    <span class="comment">// java.io.Serializable 从流中读取 HashSet对象 </span></div><div class="line"><span class="number">16</span>.	    <span class="comment">// 将HashSet的“总的容量，加载因子，实际容量，所有的元素”依次读出  </span></div><div class="line"><span class="number">17</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span>  </span></div><div class="line">18.	        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;  </div><div class="line"><span class="number">19</span>.	        <span class="comment">// Read in any hidden serialization magic  </span></div><div class="line"><span class="number">20</span>.	        s.defaultReadObject();  </div><div class="line"><span class="number">21</span>.	 </div><div class="line"><span class="number">22</span>.	        <span class="keyword">int</span> capacity = s.readInt();  </div><div class="line"><span class="number">23</span>.	        <span class="keyword">float</span> loadFactor = s.readFloat();  </div><div class="line"><span class="number">24</span>.	        map = (((HashSet)<span class="keyword">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?  </div><div class="line"><span class="number">25</span>.	               <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :  </div><div class="line"><span class="number">26</span>.	               <span class="keyword">new</span> HashMap&lt;E,Object&gt;(capacity, loadFactor));  </div><div class="line"><span class="number">27</span>.	        <span class="comment">// Read in size  </span></div><div class="line"><span class="number">28</span>.	        <span class="keyword">int</span> size = s.readInt();  </div><div class="line"><span class="number">29</span>.	        <span class="comment">// Read in all elements in the proper order.  </span></div><div class="line"><span class="number">30</span>.	        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;  </div><div class="line"><span class="number">31</span>.	            E e = (E) s.readObject();  </div><div class="line"><span class="number">32</span>.	            map.put(e, PRESENT);  </div><div class="line"><span class="number">33</span>.	        &#125;  </div><div class="line"><span class="number">34</span>.	    &#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  总体来说，HashSet是比较简单的，底层是HashMap实现的，使用的都是HashMap的方法。</p>
<h2 id="HashSet遍历："><a href="#HashSet遍历：" class="headerlink" title="HashSet遍历："></a>HashSet遍历：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">      <span class="comment">//遍历  </span></div><div class="line"><span class="number">2</span>.	        Iterator iterator = set.iterator();  </div><div class="line"><span class="number">3</span>.	        <span class="keyword">while</span> (iterator.hasNext()) &#123;  </div><div class="line"><span class="number">4</span>.	            System.out.println(iterator.next());              </div><div class="line"><span class="number">5</span>.	        &#125;     </div><div class="line"><span class="number">6</span>.	          </div><div class="line"><span class="number">7</span>.	        <span class="comment">//或者这样  </span></div><div class="line"><span class="number">8</span>.	        <span class="keyword">for</span> (String s:set) &#123;  </div><div class="line"><span class="number">9</span>.	            System.out.println(s);  </div><div class="line"><span class="number">10</span>.	        &#125;</div></pre></td></tr></table></figure>
<p>要注意的是：当我们要将一个类作为HashMap的key或者存储在HashSet的时候。通过重写hashCode()和equals(Object object)方法很重要，并且保证这两个方法的返回值一致。当两个类的hashCode()返回一致时，应该保证equasl()方法也返回true。<br>HashMap源码整理中…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;1.HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序，特别是它不保证该顺序恒久不变。而且HashSet允许使用 null 元素。&lt;br&gt;2.HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” Set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问：&lt;br&gt;
    
    </summary>
    
      <category term="java集合" scheme="https://xiaoybboy.github.io/categories/java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="java" scheme="https://xiaoybboy.github.io/tags/java/"/>
    
      <category term="HashSet" scheme="https://xiaoybboy.github.io/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>java源码之ArrayList</title>
    <link href="https://xiaoybboy.github.io/2017/04/06/java%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/"/>
    <id>https://xiaoybboy.github.io/2017/04/06/java源码之ArrayList/</id>
    <published>2017-04-06T07:20:38.000Z</published>
    <updated>2017-04-07T03:27:01.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList概述："><a href="#ArrayList概述：" class="headerlink" title="ArrayList概述："></a>ArrayList概述：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>ArrayList是基于数组实现的，Object[] elementData;是一个动态数组，其容量能自动增长。<br><a id="more"></a><br>ArrayList与Collection关系如下图：<br>　　 <img src="http://i.imgur.com/10g3wby.jpg" alt="ArrayList和Collection"></p>
<p>１．ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。<br>２．ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。<br>３．每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。<br>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。 </p>
<h1 id="ArrayList的实现："><a href="#ArrayList的实现：" class="headerlink" title="ArrayList的实现："></a>ArrayList的实现：</h1><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p>
<h2 id="私有属性："><a href="#私有属性：" class="headerlink" title="私有属性："></a>私有属性：</h2><p>ArrayList定义只定义类两个私有属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**  </span></div><div class="line">* The array buffer into which the elements of the ArrayList are stored</div><div class="line">* The capacity of the ArrayList is the length of this array buffer.  </div><div class="line"> */    </div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;    </div><div class="line"></div><div class="line"><span class="comment">/**  </span></div><div class="line">* The size of the ArrayList (the number of elements it contains).  </div><div class="line">* <span class="doctag">@serial</span>  </div><div class="line">*/    </div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure></p>
<p>很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。<br>有个关键字需要解释：transient。<br>Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。被标记为transient的属性在对象被序列化的时候不会被保存。<br>接着回到ArrayList的分析中……</p>
<h2 id="modCount和Array-copyof-，System-arraycopy。"><a href="#modCount和Array-copyof-，System-arraycopy。" class="headerlink" title="modCount和Array.copyof()，System.arraycopy。"></a>modCount和Array.copyof()，System.arraycopy。</h2><p>在父类AbstractList中定义了一个int型的属性：modCount，记录了ArrayList结构性变化的次数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>在ArrayList的所有涉及结构变化的方法中都增加modCount的值，包括：add()、remove()、addAll()、removeRange()及clear()方法。这些方法每调用一次，modCount的值就加1。<br>注：add()及addAll()方法的modCount的值是在其中调用的ensureCapacity()方法中增加的。<br>然后，先了解一个方法，下面到处都会用到。Array.copyof()，System.arraycopy。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;    </div><div class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());    </div><div class="line">&#125;    </div><div class="line">    </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;    </div><div class="line">    T[] copy = ((Object)newType == (Object)Object[].class)    </div><div class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]   <span class="comment">// 类型相同，则重新生成一个大小为newLength的数组实例    </span></div><div class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  <span class="comment">// 类型不同，重新生成一个大小为newLength的新类型数组实例    </span></div><div class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(original.length, newLength)); <span class="comment">//将原数组内容拷贝到新数组中,新数组取最小的数组长度    </span></div><div class="line">    <span class="keyword">return</span> copy;  <span class="comment">// 返回新数组的引用     </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而其中的System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)的声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,  </span></span></div><div class="line">                                        Object dest, <span class="keyword">int</span> destPos,  </div><div class="line">                                        <span class="keyword">int</span> length);</div></pre></td></tr></table></figure></p>
<p>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目标数据中的起始位置。<br>length - 要复制的数组元素的数量。<br>System.arraycopy是一个native方法，是底层使用c++实现的。 </p>
<h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><p>ArrayList提供了三种方式的构造器，可以构造一个默认的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">     * Constructs an empty list with the specified initial capacity. </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </div><div class="line">                <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;  <span class="comment">//初始容量大于0,实例化数组</span></div><div class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;  <span class="comment">//初始容量为0</span></div><div class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;  <span class="comment">//空数组</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+  </div><div class="line">                                               initialCapacity);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** ArrayList无参构造函数。</span></div><div class="line">     * Constructs an empty list with an initial capacity of ten. </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** 创建一个包含collection的ArrayList</span></div><div class="line">     * Constructs a list containing the elements of the specified </div><div class="line">     * collection, in the order they are returned by the collection's </div><div class="line">     * iterator.      */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">         elementData = c.toArray();  <span class="comment">//先转化成数组</span></div><div class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;  <span class="comment">//如果集合不为空</span></div><div class="line">          <span class="comment">// c.toArray might (incorrectly) not return Object[] </span></div><div class="line">          <span class="keyword">if</span> (elementData.getClass() != Object[].class)  </div><div class="line">  			<span class="comment">//给elementData 赋值</span></div><div class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="comment">// 如果是一个空的集合，用空数组来替换</span></div><div class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>有参的两个构造器很好理解，下面说下无参的构造器。<br>EMPTY_ELEMENTDATA是什么的？看名字就知道了，是一个空的数组。DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是一个空数组。那么他们之间有什么区别呢？为什么ArrayList无参构造函数构造的是一个DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空数组呢？因为以前的代码是直接初始化一个长度为10的数组。看上面的注释，我们可以知道，We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added.就是当第一个元素被加入到elementData中时，区分这两者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 默认的初始容量为10 </div><div class="line">    */  </div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;  </div><div class="line">  </div><div class="line">   <span class="comment">/** </span></div><div class="line">    * Shared empty array instance used for empty instances. </div><div class="line">    */  </div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;  </div><div class="line">  </div><div class="line">   <span class="comment">/** </span></div><div class="line">    * Shared empty array instance used for default sized empty instances. We</div><div class="line">    * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when  first element is added. </div><div class="line">    */  </div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>既然如此，我们先看一下add()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line"><span class="number">2</span>.	       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line"><span class="number">3</span>.	       elementData[size++] = e;  </div><div class="line"><span class="number">4</span>.	       <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line"><span class="number">5</span>.	   &#125;</div></pre></td></tr></table></figure>
<p>看第一行，应该就是区分的体现了，下面着重看下这个ensureCapacityInternal()函数。这涉及到下面的数组容量扩充，我们单独说一下。</p>
<h2 id="调整数组容量ensureCapacity："><a href="#调整数组容量ensureCapacity：" class="headerlink" title="调整数组容量ensureCapacity："></a>调整数组容量ensureCapacity：</h2><p>与之前的ArrayList源码改变最大的就是这一部分了，先把三个调整容量的函数都贴出来，下面要多次用到。ensureCapacityInternal是第二个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="comment">/** </span></div><div class="line">2.	     * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if </div><div class="line">3.	     * necessary, to ensure that it can hold at least the number of elements </div><div class="line">4.	     * specified by the minimum capacity argument. </div><div class="line">5.	     * </div><div class="line">6.	     * <span class="doctag">@param</span>   minCapacity   the desired minimum capacity </div><div class="line">7.	     */  </div><div class="line"><span class="number">8</span>.	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="number">9</span>.	        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)  </div><div class="line"><span class="number">10</span>.	            <span class="comment">// any size if not default element table  </span></div><div class="line"><span class="number">11</span>.	            ? <span class="number">0</span>  </div><div class="line"><span class="number">12</span>.	            <span class="comment">// larger than default for default empty table. It's already  </span></div><div class="line"><span class="number">13</span>.	            <span class="comment">// supposed to be at default size.  </span></div><div class="line"><span class="number">14</span>.	            : DEFAULT_CAPACITY;  </div><div class="line"><span class="number">15</span>.	  </div><div class="line"><span class="number">16</span>.	        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;  </div><div class="line"><span class="number">17</span>.	            ensureExplicitCapacity(minCapacity);  </div><div class="line"><span class="number">18</span>.	        &#125;  </div><div class="line"><span class="number">19</span>.	    &#125;  </div><div class="line"><span class="number">20</span>.	  </div><div class="line"><span class="number">21</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="number">22</span>.	        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  </div><div class="line"><span class="number">23</span>.	            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);  </div><div class="line"><span class="number">24</span>.	        &#125;  </div><div class="line"><span class="number">25</span>.	        ensureExplicitCapacity(minCapacity);  </div><div class="line"><span class="number">26</span>.	    &#125;  </div><div class="line"><span class="number">27</span>.	  </div><div class="line"><span class="number">28</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="number">29</span>.	        modCount++;   </div><div class="line"><span class="number">30</span>.	        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  </div><div class="line"><span class="number">31</span>.	            grow(minCapacity);  </div><div class="line"><span class="number">32</span>.	    &#125;  </div><div class="line"></div><div class="line"><span class="number">1</span>.	   <span class="comment">/**  容量扩充，确保数组中至少能包含minimum capacity个元素</span></div><div class="line">2.	     * Increases the capacity to ensure that it can hold at least the </div><div class="line">3.	     * number of elements specified by the minimum capacity argument. </div><div class="line">4.	     * </div><div class="line">5.	     * <span class="doctag">@param</span> minCapacity the desired minimum capacity </div><div class="line">6.	     */  </div><div class="line"><span class="number">7</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="number">8</span>.	        <span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line"><span class="number">9</span>.	      <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//原来容量的1.5倍 </span></div><div class="line"><span class="number">10</span>.	        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </div><div class="line"><span class="number">11</span>.	            newCapacity = minCapacity;  </div><div class="line"><span class="number">12</span>.	        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)  </div><div class="line"><span class="number">13</span>.	            newCapacity = hugeCapacity(minCapacity);  </div><div class="line"><span class="number">14</span>.	        <span class="comment">// minCapacity is usually close to size, so this is a win:  </span></div><div class="line"><span class="number">15</span>.	        elementData = Arrays.copyOf(elementData, newCapacity);  </div><div class="line"><span class="number">16</span>.	    &#125;  </div><div class="line"><span class="number">17</span>.	  <span class="comment">//对大容量数组的处理</span></div><div class="line"><span class="number">18</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="number">19</span>.	        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow  </span></div><div class="line"><span class="number">20</span>.	            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();  </div><div class="line"><span class="number">21</span>.	        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?  </div><div class="line"><span class="number">22</span>.	            Integer.MAX_VALUE :  </div><div class="line"><span class="number">23</span>.	            MAX_ARRAY_SIZE;  </div><div class="line"><span class="number">24</span>.	    &#125;</div></pre></td></tr></table></figure></p>
<p>看ensureCapacityInternal中的下面这一句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">33</span>.	<span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  </div><div class="line"><span class="number">34</span>.	            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);  </div><div class="line"><span class="number">35</span>.	        &#125;</div></pre></td></tr></table></figure></p>
<p>看到了吧，先比较DEFAULT_CAPACITY和minCapacity，取较大的值作为minCapacity，显然，对于无参的构造器的空数组，比较的结果是DEFAULT_CAPACITY(上面有定义是10)，然后接下来执行ensureExplicitCapacity(minCapacity)。再接下来，实际执行扩充的是grow(int minCapacity) 这个函数。上面如果是初始化的时候，容易计算此时的minCapacity = DEFAULT_CAPACITY = 10.所以执行grow的时候，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </div><div class="line">            newCapacity = minCapacity;</div></pre></td></tr></table></figure></p>
<p>会执行这一句，应该空的数组扩充1.5倍之后还是空的。接着往下看，就可以知道其实无参的ArrayList的构造器初始化的是一个长度为10的elementData 数组。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于无参的ArrayList构造器，初始化的其实是一个容量为10的Object[] elementData 数组。每次执行扩充时，最终进行数组容量扩充的是grow（）函数，而且不难看出每次数组扩充后的容量为原来数组容量 的1.5倍。int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</p>
<h2 id="元素存储："><a href="#元素存储：" class="headerlink" title="元素存储："></a>元素存储：</h2><p>ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	  <span class="comment">//两个范围检验函数，查看索引是否越界，越界抛出异常  </span></div><div class="line"><span class="number">2</span>.	  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line"><span class="number">3</span>.	          <span class="keyword">if</span> (index &gt;= size)    </div><div class="line"><span class="number">4</span>.	              <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));  </div><div class="line"><span class="number">5</span>.	      &#125;    </div><div class="line"><span class="number">6</span>.	      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line"><span class="number">7</span>.	          <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)    </div><div class="line"><span class="number">8</span>.	              <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));   </div><div class="line"><span class="number">9</span>.	.     &#125;    </div><div class="line"><span class="number">10</span>.	</div><div class="line"><span class="number">11</span>.	   <span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。      </span></div><div class="line"><span class="number">12</span>.	   <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;      </div><div class="line"><span class="number">13</span>.	      RangeCheck(index);      </div><div class="line"><span class="number">14</span>.	      E oldValue = (E) elementData[index];      </div><div class="line"><span class="number">15</span>.	      elementData[index] = element;      </div><div class="line"><span class="number">16</span>.	      <span class="keyword">return</span> oldValue;      </div><div class="line"><span class="number">17</span>.	   &#125;        </div><div class="line"><span class="number">18</span>.	   <span class="comment">// 将指定的元素添加到此列表的尾部。 上面讲到过这个函数，实现也很简单     </span></div><div class="line"><span class="number">19</span>.	   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line"><span class="number">20</span>.	         ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line"><span class="number">21</span>.	         elementData[size++] = e;  </div><div class="line"><span class="number">22</span>.	         <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line"><span class="number">23</span>.	      &#125;      </div><div class="line"><span class="number">24</span>.	   <span class="comment">// 将指定的元素插入此列表中的指定位置。      </span></div><div class="line"><span class="number">25</span>.	   <span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span></div><div class="line"><span class="number">26</span>.	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </div><div class="line"><span class="number">27</span>.	          rangeCheckForAdd(index);<span class="comment">//索引范围检验  </span></div><div class="line"><span class="number">28</span>.	          ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//  扩充1个单元  </span></div><div class="line"><span class="number">29</span>.	       <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素，      </span></div><div class="line"><span class="number">30</span>.	      <span class="comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。      </span></div><div class="line"><span class="number">31</span>.	      <span class="comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span></div><div class="line"><span class="number">32</span>.	         System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,  </div><div class="line"><span class="number">33</span>.	                          size - index);  </div><div class="line"><span class="number">34</span>.	         elementData[index] = element;<span class="comment">//插入元素  </span></div><div class="line"><span class="number">35</span>.	         size++;  </div><div class="line"><span class="number">36</span>.	     &#125;      </div><div class="line"><span class="number">37</span>.	       </div><div class="line"><span class="number">38</span>.	  <span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span></div><div class="line"><span class="number">39</span>.	 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line"><span class="number">40</span>.	         Object[] a = c.toArray();<span class="comment">//先转换成数组   </span></div><div class="line"><span class="number">41</span>.	         <span class="keyword">int</span> numNew = a.length;  </div><div class="line"><span class="number">42</span>.	        ensureCapacityInternal(size + numNew);  <span class="comment">// 容量扩充            </span></div><div class="line"><span class="number">43</span>.	         System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);<span class="comment">//元素复制  </span></div><div class="line"><span class="number">44</span>.	        size += numNew;  </div><div class="line"><span class="number">45</span>.	         <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line"><span class="number">46</span>.	      &#125;           </div><div class="line"><span class="number">47</span>.	   <span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span></div><div class="line"><span class="number">48</span>.	 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line"><span class="number">49</span>.	          rangeCheckForAdd(index);<span class="comment">//索引检查  </span></div><div class="line"><span class="number">50</span>.	    </div><div class="line"><span class="number">51</span>.	          Object[] a = c.toArray();  </div><div class="line"><span class="number">52</span>.	          <span class="keyword">int</span> numNew = a.length;  </div><div class="line"><span class="number">53</span>.	          ensureCapacityInternal(size + numNew);  <span class="comment">// 容量扩充  </span></div><div class="line"><span class="number">54</span>.	    </div><div class="line"><span class="number">55</span>.	         <span class="keyword">int</span> numMoved = size - index;<span class="comment">//要移动的元素的个数  </span></div><div class="line"><span class="number">56</span>.	         <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">             System.arraycopy(elementData, index, elementData, index + numNew, numMoved);<span class="comment">//复制元素  </span></div><div class="line"><span class="number">58</span>.	   </div><div class="line"><span class="number">59</span>.	         System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </div><div class="line"><span class="number">60</span>.	         size += numNew;  </div><div class="line"><span class="number">61</span>.	         <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line"><span class="number">62</span>.	    &#125;</div></pre></td></tr></table></figure></p>
<p>ArrayList是基于数组实现的，可以看到上面的添加元素的方法，大都需要先进行索引检查（与操作索引相关的），还要进行数组容量的扩充，然后是 System.arraycopy复制元素。具体过程查看上面的注释。</p>
<h2 id="元素读取："><a href="#元素读取：" class="headerlink" title="元素读取："></a>元素读取：</h2><p>这个很简单，直接返回数组i位置上的元素即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回此列表中指定位置上的元素。    </span></div><div class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line">    RangeCheck(index);    </div><div class="line">    <span class="keyword">return</span> (E) elementData[index];    </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="元素删除："><a href="#元素删除：" class="headerlink" title="元素删除："></a>元素删除：</h2><p>ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：</p>
<h3 id="romove-int-index"><a href="#romove-int-index" class="headerlink" title="romove(int index):"></a>romove(int index):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除此列表中指定位置上的元素。    </span></div><div class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line">     RangeCheck(index);    </div><div class="line">     modCount++;    </div><div class="line">     E oldValue = (E) elementData[index];    </div><div class="line">     <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;    </div><div class="line">     <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)    </div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);    </div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work    </span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> oldValue;    </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>首先是检查范围，修改modCount，保留将要被移除的元素，将移除位置之后的元素向前挪动一个位置，将list末尾元素置空（null），返回被移除的元素。</p>
<h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。    </span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;    </div><div class="line">    <span class="comment">// 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。    </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;    </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)    </div><div class="line">           <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;    </div><div class="line">                <span class="comment">// 类似remove(int index)，移除列表中指定位置上的元素。    </span></div><div class="line">                fastRemove(index);    </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;    </div><div class="line">            &#125;    </div><div class="line">    &#125; <span class="keyword">else</span> &#123;    </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)    </div><div class="line">           <span class="keyword">if</span> (o.equals(elementData[index])) &#123;    </div><div class="line">                fastRemove(index);    </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过代码可以看到，当移除成功后返回true，否则返回false。remove(Object o)中通过遍历element寻找是否存在传入对象，一旦找到就调用fastRemove移除对象。为什么找到了元素就知道了index，不通过remove(index)来移除元素呢？因为fastRemove跳过了判断边界的处理，因为找到元素就相当于确定了index不会超过边界，而且fastRemove并不返回被移除的元素。下面是fastRemove的代码，基本和remove(index)一致。方法说明：skips bounds checking and does notreturn the value removed.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line">         modCount++;    </div><div class="line">         <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;    </div><div class="line">         <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)    </div><div class="line">  System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,    numMoved);</div><div class="line">         elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work    </span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="batchRemove"><a href="#batchRemove" class="headerlink" title="batchRemove()"></a>batchRemove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="comment">//保留集合c中的元素，集合外的元素全部删除</span></div><div class="line"><span class="number">2</span>.	      Retains only the elements in <span class="keyword">this</span> list that are contained in the</div><div class="line"><span class="number">3</span>.	     * specified collection.  In other words, removes from <span class="keyword">this</span> list all</div><div class="line"><span class="number">4</span>.	     * of its elements that are not contained in the specified collection.</div><div class="line"><span class="number">5</span>.	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;  </div><div class="line"><span class="number">6</span>.	        Objects.requireNonNull(c);  </div><div class="line"><span class="number">7</span>.	        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);  </div><div class="line"><span class="number">8</span>.	    &#125;  </div><div class="line"><span class="number">9</span>.	  </div><div class="line"><span class="number">10</span>.	    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;  </div><div class="line"><span class="number">11</span>.	        <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;  </div><div class="line"><span class="number">12</span>.	        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;  </div><div class="line"><span class="number">13</span>.	        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;  </div><div class="line"><span class="number">14</span>.	        <span class="keyword">try</span> &#123;  </div><div class="line"><span class="number">15</span>.	            <span class="keyword">for</span> (; r &lt; size; r++)  </div><div class="line"><span class="number">16</span>.	                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)  </div><div class="line"><span class="number">17</span>.	                    elementData[w++] = elementData[r];  </div><div class="line"><span class="number">18</span>.	        &#125; <span class="keyword">finally</span> &#123;  </div><div class="line"><span class="number">19</span>.	            <span class="comment">// Preserve behavioral compatibility with AbstractCollection,  </span></div><div class="line"><span class="number">20</span>.	            <span class="comment">// even if c.contains() throws.  </span></div><div class="line"><span class="number">21</span>.	            <span class="keyword">if</span> (r != size) &#123;  </div><div class="line"><span class="number">22</span>.	                System.arraycopy(elementData, r,  </div><div class="line"><span class="number">23</span>.	                                 elementData, w,  </div><div class="line"><span class="number">24</span>.	                                 size - r);  </div><div class="line"><span class="number">25</span>.	                w += size - r;  </div><div class="line"><span class="number">26</span>.	            &#125;  </div><div class="line"><span class="number">27</span>.	            <span class="keyword">if</span> (w != size) &#123;  </div><div class="line"><span class="number">28</span>.	                <span class="comment">// clear to let GC do its work  </span></div><div class="line"><span class="number">29</span>.	                <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)  </div><div class="line"><span class="number">30</span>.	                    elementData[i] = <span class="keyword">null</span>;  </div><div class="line"><span class="number">31</span>.	                modCount += size - w;  </div><div class="line"><span class="number">32</span>.	                size = w;  </div><div class="line"><span class="number">33</span>.	                modified = <span class="keyword">true</span>;  </div><div class="line"><span class="number">34</span>.	            &#125;  </div><div class="line"><span class="number">35</span>.	        &#125;  </div><div class="line"><span class="number">36</span>.	        <span class="keyword">return</span> modified;  </div><div class="line"><span class="number">37</span>.	    &#125;</div></pre></td></tr></table></figure>
<h3 id="removeRange-int-fromIndex-int-toIndex"><a href="#removeRange-int-fromIndex-int-toIndex" class="headerlink" title="removeRange(int fromIndex,int toIndex)"></a>removeRange(int fromIndex,int toIndex)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;    </div><div class="line">     modCount++;    </div><div class="line">     <span class="keyword">int</span> numMoved = size - toIndex;    </div><div class="line">         System.arraycopy(elementData, toIndex, elementData, fromIndex,    </div><div class="line">                          numMoved);    </div><div class="line">     </div><div class="line">     <span class="comment">// Let gc do its work    </span></div><div class="line">     <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);    </div><div class="line">    <span class="keyword">while</span> (size != newSize)    </div><div class="line">         elementData[--size] = <span class="keyword">null</span>;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行过程是将elementData从toIndex位置开始的元素向前移动到fromIndex，然后将toIndex位置之后的元素全部置空顺便修改size。<br>这个方法是protected，及受保护的方法，为什么这个方法被定义为protected呢？<br>这是一个解释，但是可能不容易看明白。<a href="http://stackoverflow.com/questions/2289183/why-is-javas-abstractlists-removerange-method-protected" target="_blank" rel="external">http://stackoverflow.com/questions/2289183/why-is-javas-abstractlists-removerange-method-protected</a><br>先看下面这个例子</p>
<ol>
<li>ArrayList<integer> ints = new ArrayList<integer>(Arrays.asList(0, 1, 2,    </integer></integer></li>
<li>3, 4, 5, 6));    </li>
<li>// fromIndex low endpoint (inclusive) of the subList    </li>
<li>// toIndex high endpoint (exclusive) of the subList    </li>
<li>ints.subList(2, 4).clear();    </li>
<li>System.out.println(ints);<br>输出结果是[0, 1, 4, 5, 6]，结果是不是像调用了removeRange(int fromIndex,int toIndex)！哈哈哈，就是这样的。但是为什么效果相同呢？是不是调用了removeRange(int fromIndex,int toIndex)呢？<h2 id="ArrayList和Vector区别："><a href="#ArrayList和Vector区别：" class="headerlink" title="ArrayList和Vector区别："></a>ArrayList和Vector区别：</h2>•    ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。<br>•    Vector提供indexOf(obj, start)接口，ArrayList没有。<br>•    Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。<br>##　trimToSize<br>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSiz方法来实现。代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</div><div class="line">            elementData = (size == <span class="number">0</span>)</div><div class="line">              ? EMPTY_ELEMENTDATA</div><div class="line">              : Arrays.copyOf(elementData, size);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>由于elementData的长度会被拓展，size标记的是其中包含的元素的个数。所以会出现size很小但elementData.length很大的情况，将出现空间的浪费。trimToSize将返回一个新的数组给elementData，元素内容保持不变，length和size相同，节省空间。</p>
<h2 id="转为静态数组toArray"><a href="#转为静态数组toArray" class="headerlink" title="转为静态数组toArray"></a>转为静态数组toArray</h2><p>注意ArrayList的两个转化为静态数组的toArray方法。<br>第一个， 调用Arrays.copyOf将返回一个数组，数组内容是size个elementData的元素，即拷贝elementData从0至size-1位置的元素到新数组并返回.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="keyword">public</span> Object[] toArray() &#123;    </div><div class="line"><span class="number">2</span>.	         <span class="keyword">return</span> Arrays.copyOf(elementData, size);    </div><div class="line"><span class="number">3</span>.	 &#125;</div></pre></td></tr></table></figure></p>
<p>第二个，如果传入数组的长度小于size，返回一个新的数组，大小为size，类型与传入数组相同。所传入数组长度与size相等，则将elementData复制到传入数组中并返回传入的数组。若传入数组长度大于size，除了复制elementData外，还将把返回数组的第size个元素置为空。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;  </div><div class="line">        <span class="keyword">if</span> (a.length &lt; size)  </div><div class="line">            <span class="comment">// Make a new array of a's runtime type, but my contents:  </span></div><div class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());  </div><div class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);  </div><div class="line">        <span class="keyword">if</span> (a.length &gt; size)  </div><div class="line">            a[size] = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">return</span> a;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone(),"></a>clone(),</h2><p>返回此 ArrayList 实例的浅表副本。（不复制这些元素本身。）调用父类的clone方法返回一个对象的副本，将返回对象的elementData数组的内容赋值为原对象elementData数组的内容，将副本的modCount设置为0。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();  </div><div class="line">            v.elementData = Arrays.copyOf(elementData, size);  </div><div class="line">            v.modCount = <span class="number">0</span>;  </div><div class="line">            <span class="keyword">return</span> v;  </div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </div><div class="line">            <span class="comment">// this shouldn't happen, since we are Cloneable  </span></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </div><div class="line">     modCount++;  </div><div class="line">   </div><div class="line">     <span class="comment">// Let gc do its work  </span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </div><div class="line">        elementData[i] = <span class="keyword">null</span>;  </div><div class="line">   </div><div class="line">     size = <span class="number">0</span>;  </div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>clear的时候并没有修改elementData的长度（好不容易申请、拓展来的，凭什么释放，留着搞不好还有用呢。这使得确定不再修改list内容之后最好调用trimToSize来释放掉一些空间），只是将所有元素置为null，size设置为0。</p>
<h2 id="contains-Object"><a href="#contains-Object" class="headerlink" title="contains(Object)"></a>contains(Object)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">	<span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.indexOf方法返回值与0比较来判断对象是否在list中。接着看indexOf。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </div><div class="line">               <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)  </div><div class="line">                    <span class="keyword">return</span> i;  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </div><div class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))  </div><div class="line">                    <span class="keyword">return</span> i;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>2.lastIndexOf，光看名字应该就明白了返回的是传入对象在elementData数组中最后出现的index值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">     <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  </div><div class="line">         <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)  </div><div class="line">             <span class="keyword">return</span> i;  </div><div class="line">     &#125; <span class="keyword">else</span> &#123;  </div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  </div><div class="line">         <span class="keyword">if</span> (o.equals(elementData[i]))  </div><div class="line">             <span class="keyword">return</span> i;  </div><div class="line">    &#125;  </div><div class="line">     <span class="keyword">return</span> -<span class="number">1</span>;  </div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>采用了从后向前遍历element数组，若遇到Object则返回index值，若没有遇到，返回-1.</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>因为实现了java.io.Serializable接口，索引可以进行序列化操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">     * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that </div><div class="line">     * is, serialize it). 把arraylist实例写入一个流中</div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span>  </span></div><div class="line">        <span class="keyword">throws</span> java.io.IOException&#123;  </div><div class="line">        <span class="comment">// Write out element count, and any hidden stuff  </span></div><div class="line">        <span class="keyword">int</span> expectedModCount = modCount;  </div><div class="line">        s.defaultWriteObject();  </div><div class="line">  </div><div class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()  </span></div><div class="line">        s.writeInt(size);  </div><div class="line">  </div><div class="line">        <span class="comment">// Write out all elements in the proper order.  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;  </div><div class="line">            s.writeObject(elementData[i]);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, </div><div class="line">     * deserialize it). 从流中读出一个ArrayList实例</div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span>  </span></div><div class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;  </div><div class="line">        elementData = EMPTY_ELEMENTDATA;  </div><div class="line">  </div><div class="line">        <span class="comment">// Read in size, and any hidden stuff  </span></div><div class="line">        s.defaultReadObject();  </div><div class="line"></div><div class="line">        <span class="comment">// Read in capacity  </span></div><div class="line">        s.readInt(); <span class="comment">// ignored  </span></div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity  </span></div><div class="line">            ensureCapacityInternal(size);  </div><div class="line">  </div><div class="line">            Object[] a = elementData;  </div><div class="line">            <span class="comment">// Read in all elements in the proper order.  </span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;  </div><div class="line">                a[i] = s.readObject();  </div><div class="line">        &#125;  &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h1 id="Fail-Fast机制："><a href="#Fail-Fast机制：" class="headerlink" title="Fail-Fast机制："></a>Fail-Fast机制：</h1><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<h1 id="ArrayList的遍历方式"><a href="#ArrayList的遍历方式" class="headerlink" title="ArrayList的遍历方式"></a>ArrayList的遍历方式</h1><p>ArrayList支持3种遍历方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、通过迭代器遍历：</div><div class="line">Iterator iter = list.iterator();</div><div class="line"><span class="keyword">while</span> (iter.hasNext())</div><div class="line">&#123;</div><div class="line">    System.out.println(iter.next());</div><div class="line">&#125;         </div><div class="line"><span class="number">2</span>、随机访问，通过索引值去遍历，由于ArrayList实现了RandomAccess接口</div><div class="line"><span class="keyword">int</span> size = list.size();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) </div><div class="line">&#123;</div><div class="line">   System.out.println(list.get(i));        </div><div class="line">&#125;      </div><div class="line"><span class="number">3</span>、<span class="keyword">for</span>循环遍历：</div><div class="line"><span class="keyword">for</span>(String str:list)</div><div class="line">&#123;</div><div class="line">  System.out.println(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h1><p>关于ArrayList的源码，给出几点比较重要的总结：<br>1.注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。<br>2.注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。<br>3.ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。<br>首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码：</p>
<pre><code class="java"><span class="number">1</span>.    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) {    
<span class="number">2</span>.        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());    
<span class="number">3</span>.    }
</code></pre>
<p>很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型，其源码如下：</p>
<pre><code class="java"><span class="number">1</span>.    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) {    
<span class="number">2</span>.        T[] copy = ((Object)newType == (Object)Object[].class)    
<span class="number">3</span>.            ? (T[]) <span class="keyword">new</span> Object[newLength]    
<span class="number">4</span>.            : (T[]) Array.newInstance(newType.getComponentType(), newLength);    
<span class="number">5</span>.        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,    
<span class="number">6</span>.                         Math.min(original.length, newLength));    
<span class="number">7</span>.        <span class="keyword">return</span> copy;    
<span class="number">8</span>.    }
</code></pre>
<p>这里可以很明显地看出，该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。<br>下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。<br>4.ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。<br>5.在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。<br>6.数组扩容<br>这是对ArrayList效率影响比较大的一个因素。<br>每 当执行Add、AddRange、Insert、InsertRange等添加元素的方法，都会检查内部数组的容量是否不够了，如果是，它就会以当前容量 的两倍来重新构建一个数组，将旧元素Copy到新数组中，然后丢弃旧数组，在这个临界点的扩容操作，应该来说是比较影响效率的。<br>由于是从word上粘贴过来的，格式有些不太正确，以后慢慢修改吧。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ArrayList概述：&quot;&gt;&lt;a href=&quot;#ArrayList概述：&quot; class=&quot;headerlink&quot; title=&quot;ArrayList概述：&quot;&gt;&lt;/a&gt;ArrayList概述：&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;RandomAccess&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ArrayList是基于数组实现的，Object[] elementData;是一个动态数组，其容量能自动增长。&lt;br&gt;
    
    </summary>
    
      <category term="java集合" scheme="https://xiaoybboy.github.io/categories/java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="java源码" scheme="https://xiaoybboy.github.io/tags/java%E6%BA%90%E7%A0%81/"/>
    
      <category term="ArrayList" scheme="https://xiaoybboy.github.io/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>Java Scanner next()和nextLine()</title>
    <link href="https://xiaoybboy.github.io/2017/04/02/Java-Scanner-next-%E5%92%8CnextLine/"/>
    <id>https://xiaoybboy.github.io/2017/04/02/Java-Scanner-next-和nextLine/</id>
    <published>2017-04-02T05:29:44.000Z</published>
    <updated>2017-04-06T07:10:30.311Z</updated>
    
    <content type="html"><![CDATA[<p>java中使用Scanner类获取数据输入十分方便，Scanner类中next()与nextLine()都可以实现字符串String的获取.它们的区别如下：</p>
<ol>
<li>next() 方法从第一个有效字符（非空格，非换行符），开始扫描。当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容，即获得第一个扫描到的不含空格、换行符的单个字符串。</li>
<li>使用nextLine()时，则可以扫描到一行内容并作为一个字符串而被获取到。可以获取空格。<a id="more"></a>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	System.out.println(<span class="string">"---&gt;Test1:\n"</span>);</div><div class="line">	String nextStr = scanner.next();</div><div class="line">	System.out.println(<span class="string">"scanner.next()得到："</span> + nextStr);</div><div class="line">	String nextlineStr = scanner.nextLine();</div><div class="line">	System.out.println(<span class="string">"scanner.nextLine()得到："</span> + nextlineStr);</div><div class="line"></div><div class="line">	System.out.println(<span class="string">"\n---&gt;Test2:"</span>);</div><div class="line">	String nextlineStr2 = scanner.nextLine();</div><div class="line">	System.out.println(<span class="string">"scanner.nextLine()得到："</span> + nextlineStr2);</div><div class="line">	String nextStr2 = scanner.next();</div><div class="line">	System.out.println(<span class="string">"scanner.next()得到："</span> + nextStr2);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://i.imgur.com/vgRn5UN.png" alt="结果"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中使用Scanner类获取数据输入十分方便，Scanner类中next()与nextLine()都可以实现字符串String的获取.它们的区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;next() 方法从第一个有效字符（非空格，非换行符），开始扫描。当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容，即获得第一个扫描到的不含空格、换行符的单个字符串。&lt;/li&gt;
&lt;li&gt;使用nextLine()时，则可以扫描到一行内容并作为一个字符串而被获取到。可以获取空格。
    
    </summary>
    
      <category term="java" scheme="https://xiaoybboy.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://xiaoybboy.github.io/tags/java/"/>
    
      <category term="Scanner" scheme="https://xiaoybboy.github.io/tags/Scanner/"/>
    
  </entry>
  
  <entry>
    <title>github上ssh配置</title>
    <link href="https://xiaoybboy.github.io/2017/03/31/github%E4%B8%8Assh%E9%85%8D%E7%BD%AE/"/>
    <id>https://xiaoybboy.github.io/2017/03/31/github上ssh配置/</id>
    <published>2017-03-30T20:13:14.000Z</published>
    <updated>2017-04-06T07:10:30.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置-ssh-key"><a href="#配置-ssh-key" class="headerlink" title="配置 ssh key"></a>配置 ssh key</h1><p>使用 git bash 生成 public ssh key，以下是最简单的方法<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa</div><div class="line">C/Documents and Settings/username/.ssh 目录下会生成 id_rsa.pub</div></pre></td></tr></table></figure></p>
<p>将 id_rsa.pub 的内容完全复制到 github Account Setting 里的 ssh key 里即可</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>然后会看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi [yourGithubAccount]! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure></p>
<p>设置用户信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;[yourName]&quot;//用户名</div><div class="line">$ git config --global user.email  &quot;[yourEmail]&quot;//填写自己的邮箱</div></pre></td></tr></table></figure></p>
<p>经过以上步骤，本机已成功连接到 github，为部署打下基础。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置-ssh-key&quot;&gt;&lt;a href=&quot;#配置-ssh-key&quot; class=&quot;headerlink&quot; title=&quot;配置 ssh key&quot;&gt;&lt;/a&gt;配置 ssh key&lt;/h1&gt;&lt;p&gt;使用 git bash 生成 public ssh key，以下是最简单的方法&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/categories/hexo/"/>
    
    
      <category term="github" scheme="https://xiaoybboy.github.io/tags/github/"/>
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://xiaoybboy.github.io/2017/03/24/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://xiaoybboy.github.io/2017/03/24/栈与队列/</id>
    <published>2017-03-24T08:11:27.000Z</published>
    <updated>2017-04-06T07:10:30.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型.</p>
</div>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>假设两个栈为A和B。</p>
<ol>
<li>入队列的时候，只需要向A栈中入栈即可。</li>
<li>出队列的时候，要先检查B栈是否为空。如果B为空，把A栈中的元素全部放入B栈中。如果B不为空，就从B栈顶弹出一个元素。<br>这样就实现了一个队列先进先出的功能。<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 </div><div class="line"> * &lt;分析&gt;： </div><div class="line"> * 入队：将元素进栈A</div><div class="line"> * 出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈； 如果不为空，栈B直接出栈。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span> </span>&#123;</div><div class="line">	Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">	Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">		stack1.push(node);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> a;</div><div class="line">		<span class="keyword">if</span> (!stack2.isEmpty()) &#123;</div><div class="line">			a = stack2.pop();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">while</span> (!stack1.isEmpty()) &#123;</div><div class="line">				stack2.push(stack1.pop());</div><div class="line">			&#125;</div><div class="line">			a = stack2.pop();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> a;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h1><p>用两个队列实现栈的功能。</p>
<h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h1><p>把B当做一个中转站<br>入栈：将元素进队列A<br>出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素出队列并放入队列B，直到队列A中的元素留下一个，然<br>后队列A出队列，再把队列B中的元素出队列以此放入队列A中。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用两个队列实现栈的功能； 思路 &lt;分析&gt;：把B当做一个中转站 入栈：将元素进队列A</div><div class="line"> * 出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素出队列并放入队列B，直到队列A中的元素留下一</div><div class="line"> * 个，然后队列A出队列，再把 队列B中的元素出队列以此放入队列A中。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueStack</span> </span>&#123;</div><div class="line">	Queue&lt;Integer&gt; queue1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">	Queue&lt;Integer&gt; queue2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">		<span class="comment">// 两个栈都为空时，优先考虑queue1</span></div><div class="line">		<span class="keyword">if</span> (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123;</div><div class="line">			queue1.add(node);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 如果queue1为空，queue2有元素，直接放入queue2</span></div><div class="line">		<span class="keyword">if</span> (queue1.isEmpty()) &#123;</div><div class="line">			queue2.add(node);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (queue2.isEmpty()) &#123;</div><div class="line">			queue1.add(node);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 两个栈都为空时，没有元素可以弹出</span></div><div class="line">		<span class="keyword">if</span> (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 如果queue1为空，queue2有元素， 将queue2的元素依次放入queue1中，直到最后一个元素，我们弹出。</span></div><div class="line">		<span class="keyword">if</span> (queue1.isEmpty()) &#123;</div><div class="line">			<span class="keyword">while</span> (queue2.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">				queue1.add(queue2.poll());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> queue2.poll();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (queue2.isEmpty()) &#123;</div><div class="line">			<span class="keyword">while</span> (queue1.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">				queue2.add(queue1.poll());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> queue1.poll();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> (Integer) <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型.&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://xiaoybboy.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://xiaoybboy.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>青蛙跳台阶</title>
    <link href="https://xiaoybboy.github.io/2017/03/24/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://xiaoybboy.github.io/2017/03/24/青蛙跳台阶/</id>
    <published>2017-03-24T07:49:49.000Z</published>
    <updated>2017-04-06T07:10:30.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</div>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>假设第一次跳了一阶，那么还剩 n-1 阶，有f(n-1)中跳法。 假设第一次跳了2阶，那么还剩 n-2 阶，有f(n-2)中跳法。所以，这是一个斐波那契数列。f(n) = f(n-1)+f(n-2)</p>
</blockquote>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</div><div class="line"> * </div><div class="line"> * 思路：假设第一次跳了一阶，那么还剩 n-1 阶，有f(n-1)中跳法。</div><div class="line"> * </div><div class="line"> * 假设第一次跳了2阶，那么还剩 n-2 阶，有f(n-2)中跳法。</div><div class="line"> * </div><div class="line"> * 所以，这是一个斐波那契数列。f(n) = f(n-1)+f(n-2)</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpFloor</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorSolution</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (target == <span class="number">2</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> f1 = <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> f2 = <span class="number">2</span>;</div><div class="line">		<span class="keyword">int</span> cursum = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</div><div class="line">			cursum = f1 + f2;</div><div class="line">			f1 = f2;</div><div class="line">			f2 = cursum;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> cursum;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ol>
<li>假设第一次跳 1 阶。那么还剩 n-1 阶。一共还剩f(n-1)种跳法。</li>
<li>假设第一次跳 2 阶。那么还剩 n-2 阶。一共还剩f(n-2)种跳法。 。。。</li>
<li>假设第一次跳 n-1 阶。那么还剩 1 阶。一共还剩f(1)种跳法。</li>
<li>假设第一次跳 n 阶。一种跳法。</li>
<li>所以：f(n) = f(n-1)+f(n-2)+…+1; 而且:f(n-1) = f(n-2) +…+1;</li>
<li>所以f(n) = 2f(n-1)</li>
</ol>
</blockquote>
<h1 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</div><div class="line"> * </div><div class="line"> * 思路：同样：假设第一次跳 1 阶。那么还剩 n-1 阶。一共还剩f(n-1)种跳法。</div><div class="line"> * </div><div class="line"> * 假设第一次跳 2 阶。那么还剩 n-2 阶。一共还剩f(n-2)种跳法。 。。。</div><div class="line"> * </div><div class="line"> * 假设第一次跳 n-1 阶。那么还剩 1 阶。一共还剩f(1)种跳法。</div><div class="line"> * </div><div class="line"> * 假设第一次跳 n 阶。一种跳法。</div><div class="line"> * </div><div class="line"> * 所以：f(n) = f(n-1)+f(n-2)+...+1; 而且:f(n-1) = f(n-2) +...+1;</div><div class="line"> * </div><div class="line"> * 所以f(n) = 2f(n-1)</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumoFloor2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorSolution</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> JumpFloorSolution(target - <span class="number">1</span>) * <span class="number">2</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>矩阵覆盖</title>
    <link href="https://xiaoybboy.github.io/2017/03/24/%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96/"/>
    <id>https://xiaoybboy.github.io/2017/03/24/矩阵覆盖/</id>
    <published>2017-03-24T07:30:40.000Z</published>
    <updated>2017-04-06T07:10:30.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
</div>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>有以下几种情形：</p>
<blockquote>
<ol>
<li>target &lt;= 0 大矩形为&lt;= 2*0,直接return 0；</li>
<li>target = 1大矩形为2*1，只有一种摆放方法，return1；</li>
<li>target = 2 大矩形为2*2，有两种摆放方法，return2；</li>
<li>target = n 分为两步考虑：<br>第一次摆放一块 2<em>1 的小矩阵，则摆放方法总共为f(target - 1)<br>√<br>√<br>第一次摆放一块1\</em>2的小矩阵，则摆放方法总共为f(target-2)<br>因为，摆放了一块1*2的小矩阵（用√√表示），对应下方的1*2（用××表示）摆放方法就确定了，所以为f(targte-2)<br>√    √<br>×    ×<br>所以：f(target) =f(target - 1) + f(targte-2)<br>实际上就是一个斐波那契数列。</li>
</ol>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;  </div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;  </div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">2</span>)&#123;  </div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>;  </div><div class="line">        &#125;<span class="keyword">else</span>&#123;  </div><div class="line">            <span class="keyword">return</span> RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何终止一个线程</title>
    <link href="https://xiaoybboy.github.io/2017/03/23/%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B/"/>
    <id>https://xiaoybboy.github.io/2017/03/23/如何终止一个线程/</id>
    <published>2017-03-23T02:04:35.000Z</published>
    <updated>2017-04-06T07:10:30.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA如何让一个线程死亡或结束"><a href="#JAVA如何让一个线程死亡或结束" class="headerlink" title="JAVA如何让一个线程死亡或结束"></a>JAVA如何让一个线程死亡或结束</h1><p>&emsp;&emsp;不推荐使用stop()方法终止线程。，因为stop()方法容易引起死锁。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.	<span class="comment">/**</span></div><div class="line">2.	 * JAVA里面如何使用一个线程死亡或结束 *</div><div class="line">3.	 */</div><div class="line"><span class="number">4</span>.	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</div><div class="line"><span class="number">5</span>.	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="number">6</span>.	    <span class="comment">// 启动线程</span></div><div class="line"><span class="number">7</span>.	    MyThread thread = <span class="keyword">new</span> MyThread();</div><div class="line"><span class="number">8</span>.	    <span class="keyword">new</span> Thread(thread).start();</div><div class="line"><span class="number">9</span>.	</div><div class="line"><span class="number">10</span>.	    <span class="comment">// 你的其它的工作，此时线程在运行中</span></div><div class="line"><span class="number">11</span>.	</div><div class="line"><span class="number">12</span>.	    <span class="comment">// 你不想让线程干活了，停掉它</span></div><div class="line"><span class="number">13</span>.	    <span class="comment">// 注意，这只是一个标志，具体线程何时停，并不能精确控制</span></div><div class="line"><span class="number">14</span>.	    thread.allDone = <span class="keyword">true</span>;</div><div class="line"><span class="number">15</span>.	  &#125;</div><div class="line"><span class="number">16</span>.	&#125;</div><div class="line"><span class="number">17</span>.	</div><div class="line"><span class="number">18</span>.	<span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="number">19</span>.	  <span class="keyword">boolean</span> **<span class="keyword">volatile</span>** allDone = <span class="keyword">false</span>;</div><div class="line"><span class="number">20</span>.	</div><div class="line"><span class="number">21</span>.	  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">22</span>.	    <span class="comment">// 每次循环都检测标志</span></div><div class="line"><span class="number">23</span>.	    <span class="comment">// 如果设置停止标志时已经在循环里</span></div><div class="line"><span class="number">24</span>.	    <span class="comment">// 则最长需要等待一个循环的时间才能终止</span></div><div class="line"><span class="number">25</span>.	    <span class="keyword">while</span> (!allDone) &#123;</div><div class="line"><span class="number">26</span>.	      <span class="comment">// 循环里的工作</span></div><div class="line"><span class="number">27</span>.	    &#125;</div><div class="line"><span class="number">28</span>.	  &#125;</div><div class="line"><span class="number">29</span>.	&#125;</div></pre></td></tr></table></figure></p>
<p>使用 volatile 标识的变量具有线程可见性。当一个线程修改了这个变量的值，其他线程立即可以知道。所以可以避免多CPU出问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA如何让一个线程死亡或结束&quot;&gt;&lt;a href=&quot;#JAVA如何让一个线程死亡或结束&quot; class=&quot;headerlink&quot; title=&quot;JAVA如何让一个线程死亡或结束&quot;&gt;&lt;/a&gt;JAVA如何让一个线程死亡或结束&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;不推荐使用stop()方法终止线程。，因为stop()方法容易引起死锁。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://xiaoybboy.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://xiaoybboy.github.io/tags/java/"/>
    
      <category term="线程" scheme="https://xiaoybboy.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>求二叉树的深度</title>
    <link href="https://xiaoybboy.github.io/2017/03/21/%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>https://xiaoybboy.github.io/2017/03/21/求二叉树的深度/</id>
    <published>2017-03-21T03:46:41.000Z</published>
    <updated>2017-04-06T07:10:30.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>&emsp;&emsp;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。  </p>
</div>
<a id="more"></a>
# 思路
&emsp;&emsp;递归求解
# 代码

undefined

&emsp;下面是一个跟上面类似的题目。
# 题目描述
<div class="note success"><p>&emsp;&emsp;判断一棵树是不是平衡二叉树。平衡二叉树指左右子树的高度不超过1的二叉树。<br>思路很简单，直接贴代码。</p>
</div>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断一棵树是不是平衡二叉树</div><div class="line"> * </div><div class="line"> * 思路：递归求左右子树的深度，比较判断是否是平衡二叉树</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalancedBinaryTree</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> left = getDepth(root.left);</div><div class="line">		<span class="keyword">int</span> right = getDepth(root.right);</div><div class="line">		<span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 递归求解二叉树的深度</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode node)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> left = getDepth(node.left);</div><div class="line">		<span class="keyword">int</span> right = getDepth(node.right);</div><div class="line">		<span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;&amp;emsp;&amp;emsp;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。  &lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://xiaoybboy.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第一个只出现一次的字符</title>
    <link href="https://xiaoybboy.github.io/2017/03/21/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>https://xiaoybboy.github.io/2017/03/21/第一个只出现一次的字符/</id>
    <published>2017-03-21T03:03:34.000Z</published>
    <updated>2017-04-06T07:10:30.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置.<br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;暴力求解。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置</div><div class="line"> * </div><div class="line"> * 思路：暴力求解</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstNotRepeatingCharSolution</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 用一个map记录每个字符出现的次数</span></div><div class="line">		HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> c = str.charAt(i);</div><div class="line">			<span class="keyword">if</span> (map.containsKey(c)) &#123;</div><div class="line">				<span class="keyword">int</span> times = map.get(c);</div><div class="line">				times += <span class="number">1</span>;</div><div class="line">				map.put(c, times);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				map.put(c, <span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 出现一次的字符 首次出现的索引</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> c2 = str.charAt(i);</div><div class="line">			<span class="keyword">if</span> (map.get(c2) == <span class="number">1</span>) &#123;</div><div class="line">				<span class="keyword">return</span> i;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在一个字符串(1&amp;lt;=字符串长度&amp;lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置.&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第N个丑数</title>
    <link href="https://xiaoybboy.github.io/2017/03/20/%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0/"/>
    <id>https://xiaoybboy.github.io/2017/03/20/第N个丑数/</id>
    <published>2017-03-20T07:18:42.000Z</published>
    <updated>2017-04-06T07:10:30.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note primary"><p>&emsp;&emsp;把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上<br>我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 </p>
</div>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><div class="note success"><p>&emsp;&emsp;暴力求解思路。首先我们要搞清楚怎么求丑数。ugly[]表示丑数数组。</p>
</div>
<ol>
<li>ugly[0]=1;</li>
<li>ugly[1]=1*2;</li>
<li>ugly[3]=1*3;</li>
<li>ugly[4]=1<em>2</em>2;</li>
<li>ugly[5]=1*5;</li>
<li>ugly[6]=1<em>2</em>3;</li>
<li>…<br>&emsp;&emsp;是不是可以找出规律来，我们需要记录 丑数中因子 2,3,5 出现的次数。具体用语言不好描述，可以看出规律。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。</div><div class="line"> * 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetUglyNumber</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[index];</div><div class="line">		result[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;<span class="comment">// i2,i3,i5分别记录丑数的因子中2,3,5的个数</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</div><div class="line">			result[i] = min(result[i2] * <span class="number">2</span>, min(result[i3] * <span class="number">3</span>, result[i5] * <span class="number">5</span>));</div><div class="line">			<span class="keyword">if</span> (result[i] == result[i2] * <span class="number">2</span>) &#123;</div><div class="line">				i2++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (result[i] == result[i3] * <span class="number">3</span>) &#123;</div><div class="line">				i3++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (result[i] == result[i5] * <span class="number">5</span>) &#123;</div><div class="line">				i5++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result[index - <span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> i &gt; j ? j : i;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&amp;emsp;&amp;emsp;把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上&lt;br&gt;我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 &lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
