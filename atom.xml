<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如果一切重来</title>
  <subtitle>小小程序员的成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaoybboy.github.io/"/>
  <updated>2017-03-18T09:49:52.332Z</updated>
  <id>https://xiaoybboy.github.io/</id>
  
  <author>
    <name>Yb Xiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>按字典序输出一个字符串的全排序</title>
    <link href="https://xiaoybboy.github.io/2017/03/18/%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%BA%8F/"/>
    <id>https://xiaoybboy.github.io/2017/03/18/按字典序输出一个字符串的全排序/</id>
    <published>2017-03-18T08:39:56.000Z</published>
    <updated>2017-03-18T09:49:52.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;大脑短路了，想明白这个竟然花了半小时。这个题目的核心其实是求解一个字符串的全排列。因为字典序只需要用<br>Collection.sort()方法排序一个ArrayList<string> 或者TreeSet就行了。<br>&emsp;主要说下怎么对一个字符串进行全排列。比如说”abcd”怎么全排序呢?直觉告诉我们先把a放第一位，对”bcd”再进行全排列，就是一个递归。然后把b放在第一位，”acd”进行递归。…具体操作下面结合代码说。<br>&emsp;下面就是对全排列的字符串进行排序操作，按字典序输出即可。</string></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串</div><div class="line"> * abc,acb,bac,bca,cab和cba。</div><div class="line"> * </div><div class="line"> * 思路：先求解字符串的全排列，然后对这些全排列进行排序。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPermutationSort</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 保存全排列的结果</span></div><div class="line">		<span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果str不为空           </span></div><div class="line">			Permutation(str.toCharArray(), <span class="number">0</span>, result);<span class="comment">// 获取字符串的全排列  </span></div><div class="line">		&#125;</div><div class="line">		Collections.sort(result);<span class="comment">// 对全排列的字符串进行排序</span></div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> charArray</div><div class="line">	 * <span class="doctag">@param</span> i</div><div class="line">	 * <span class="doctag">@param</span> result</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>[] charArray, <span class="keyword">int</span> i, ArrayList&lt;String&gt; result)</span> </span>&#123;</div><div class="line">		<span class="comment">// 如果 i 是最后一个字符位置</span></div><div class="line">		<span class="keyword">if</span> (i == charArray.length - <span class="number">1</span>) &#123;</div><div class="line">			result.add(String.valueOf(charArray));<span class="comment">// 找到一个全排序</span></div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= charArray.length - <span class="number">1</span>; j++) &#123;</div><div class="line">				<span class="keyword">if</span> (j != i &amp;&amp; charArray[j] == charArray[i])<span class="comment">// 有重复字符时，跳过</span></div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				swap(charArray, i, j);</div><div class="line">				Permutation(charArray, i + <span class="number">1</span>, result);</div><div class="line">				swap(charArray, i, j);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 交换字符数组s的第i个位置和第j个位置的字符</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (s[i] == s[j]) &#123;</div><div class="line">			;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">char</span> c = s[i];</div><div class="line">			s[i] = s[j];</div><div class="line">			s[j] = c;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;回头再看究竟是怎么全排列的吧。就是这个函数 private void Permutation(char[] charArray, int i, ArrayList<string> result) 的递归过程。其中 i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列。当<br>i == charArray.length - 1 时，表示已经到了最后一个字符，那么就找到了一个全排列。下面很好看懂，就是递归向下找，但是为什么要交换两次 charArray i和j 位置的字符呢？<br>&emsp;其实拿”abcd”来说，当我们交换 a和b 的位置（第一次交换），然后用b作为首字符寻找全排列。但是下次我们要交换 a和c 的位置，但是这时候 a和b 已经交换了，所以要把 a和b 换回来，才能保证每次交换的顺序没有乱。</string></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;&amp;emsp;大脑短路了，想明白这个竟然花了半小时。这个题目的核心其实是求解一个字符串的全排列。因为字典序只需要用&lt;br&gt;Collection.sort()方法排序一个ArrayList&lt;String&gt; 或者TreeSet就行了。&lt;br&gt;&amp;emsp;主要说下怎么对一个字符串进行全排列。比如说”abcd”怎么全排序呢?直觉告诉我们先把a放第一位，对”bcd”再进行全排列，就是一个递归。然后把b放在第一位，”acd”进行递归。…具体操作下面结合代码说。&lt;br&gt;&amp;emsp;下面就是对全排列的字符串进行排序操作，按字典序输出即可。&lt;/p&gt;
&lt;h1 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h1&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树与双向链表</title>
    <link href="https://xiaoybboy.github.io/2017/03/18/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://xiaoybboy.github.io/2017/03/18/二叉搜索树与双向链表/</id>
    <published>2017-03-18T07:07:36.000Z</published>
    <updated>2017-03-18T07:31:57.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;使用递归的思想。步骤如下：<br>&emsp;1. 将左子树构造成双链表，并返回链表头节点。<br>&emsp;2. 定位至左子树双链表最后一个节点。<br>&emsp;3. 如果左子树链表不为空的话，将当前root追加到左子树链表。<br>&emsp;4. 将右子树构造成双链表，并返回链表头节点。<br>&emsp;5. 如果右子树链表不为空的话，将该链表追加到root节点之后。<br>&emsp;6. 根据左子树链表是否为空确定返回的节点。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</div><div class="line"> * 思路：解题思路：</div><div class="line">	1.将左子树构造成双链表，并返回链表头节点。</div><div class="line">	2.定位至左子树双链表最后一个节点。</div><div class="line">	3.如果左子树链表不为空的话，将当前root追加到左子树链表。</div><div class="line">	4.将右子树构造成双链表，并返回链表头节点。</div><div class="line">	5.如果右子树链表不为空的话，将该链表追加到root节点之后。</div><div class="line">	6.根据左子树链表是否为空确定返回的节点。</div><div class="line">	</div><div class="line"> * <span class="doctag">@author</span> XIAO</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLinkedList</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 如果root的左右子树都为空</span></div><div class="line">		<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> root;</div><div class="line">		&#125;</div><div class="line">		TreeNode left = Convert(root.left);<span class="comment">// 把root节点的左子树转成链表，返回值为链表的头</span></div><div class="line">		TreeNode p = left;</div><div class="line">		<span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</div><div class="line">			p = p.right;<span class="comment">// 循环定位到左子树双链表的最后一个节点</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 如果左子树链表不为空的话，将当前root追加到左子树链表</span></div><div class="line">		<span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</div><div class="line">			p.right = root;<span class="comment">// 把root连接到左子树形成的双向链表中，双向链表，需要左右都连接</span></div><div class="line">			root.left = p;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 同样的，把根节点的右子树也形成双向链表，返回值为链表头</span></div><div class="line">		TreeNode right = Convert(root.right);</div><div class="line">		<span class="comment">// 把右子树的链表连接到上面的左子树和根节点的链表中</span></div><div class="line">		<span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</div><div class="line">			root.right = right;<span class="comment">// 同样把右子树的链表连接上去</span></div><div class="line">			right.left = root;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> left != <span class="keyword">null</span> ? left : root;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;使用递归的思想。步骤如下：&lt;br&gt;&amp;emsp;1. 将左子树构造成双链表，并返回链表头节点。&lt;br&gt;&amp;emsp;2. 定位至左子树双链表最后一个节点。&lt;br&gt;&amp;emsp;3. 如果左子树链表不为空的话，将当前root追加到左子树链表。&lt;br&gt;&amp;emsp;4. 将右子树构造成双链表，并返回链表头节点。&lt;br&gt;&amp;emsp;5. 如果右子树链表不为空的话，将该链表追加到root节点之后。&lt;br&gt;&amp;emsp;6. 根据左子树链表是否为空确定返回的节点。&lt;/p&gt;
&lt;h1 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h1&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <link href="https://xiaoybboy.github.io/2017/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://xiaoybboy.github.io/2017/03/18/二叉树中和为某一值的路径/</id>
    <published>2017-03-18T06:17:10.000Z</published>
    <updated>2017-03-18T06:52:33.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> listAll;</div><div class="line">        list.add(root.val);</div><div class="line">        target -= root.val;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</div><div class="line">            listAll.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</div><div class="line">        FindPath(root.left, target);</div><div class="line">        FindPath(root.right, target);</div><div class="line">        list.remove(list.size()-<span class="number">1</span>);<span class="comment">//返回父节点继续搜索</span></div><div class="line">        <span class="keyword">return</span> listAll;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。&lt;/p&gt;
&lt;h1 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h1&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>测试字符串中是否包含重复字符</title>
    <link href="https://xiaoybboy.github.io/2017/03/18/%E6%B5%8B%E8%AF%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"/>
    <id>https://xiaoybboy.github.io/2017/03/18/测试字符串中是否包含重复字符/</id>
    <published>2017-03-18T04:07:14.000Z</published>
    <updated>2017-03-18T06:53:42.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;请实现一个算法，确定一个字符串的所有字符全都不同。要求不允许使用额外的存储空间。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;暂时没想到好的思路，只能暴力求解。<br><a id="more"></a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRepeat</span> </span>&#123;  </div><div class="line">    <span class="comment">// 暴力求解，双层循环，一一比较  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkDifferent</span><span class="params">(String iniString)</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;iniString.length();i++) &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;iniString.length();j++) &#123;  </div><div class="line">                <span class="keyword">if</span> (iniString.charAt(i) == iniString.charAt(j))  </div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;请实现一个算法，确定一个字符串的所有字符全都不同。要求不允许使用额外的存储空间。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;暂时没想到好的思路，只能暴力求解。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://xiaoybboy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xiaoybboy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://xiaoybboy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://xiaoybboy.github.io/2017/03/07/hello-world/"/>
    <id>https://xiaoybboy.github.io/2017/03/07/hello-world/</id>
    <published>2017-03-06T16:00:00.000Z</published>
    <updated>2017-03-18T04:17:52.867Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="github" scheme="https://xiaoybboy.github.io/tags/github/"/>
    
      <category term="hexo" scheme="https://xiaoybboy.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
