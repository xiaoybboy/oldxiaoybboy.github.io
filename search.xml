<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[栈与队列]]></title>
      <url>%2F2017%2F03%2F24%2F%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型. # 思路 假设两个栈为A和B。 1. 入队列的时候，只需要向A栈中入栈即可。 2. 出队列的时候，要先检查B栈是否为空。如果B为空，把A栈中的元素全部放入B栈中。如果B不为空，就从B栈顶弹出一个元素。 这样就实现了一个队列先进先出的功能。 # 代码实现 undefined # 题目描述 用两个队列实现栈的功能. 思路把B当做一个中转站入栈：将元素进队列A出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素出队列并放入队列B，直到队列A中的元素留下一个， 然后队列A出队列，再把队列B中的元素出队列以此放入队列A中。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 用两个队列实现栈的功能； 思路 &lt;分析&gt;：把B当做一个中转站 入栈：将元素进队列A * 出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素出队列并放入队列B，直到队列A中的元素留下一个， 然后队列A出队列，再把 * 队列B中的元素出队列以此放入队列A中。 * * @author XIAO * */public class QueueStack &#123; Queue&lt;Integer&gt; queue1 = new ArrayDeque&lt;&gt;(); Queue&lt;Integer&gt; queue2 = new ArrayDeque&lt;&gt;(); public void push(int node) &#123; // 两个栈都为空时，优先考虑queue1 if (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123; queue1.add(node); return; &#125; // 如果queue1为空，queue2有元素，直接放入queue2 if (queue1.isEmpty()) &#123; queue2.add(node); return; &#125; if (queue2.isEmpty()) &#123; queue1.add(node); return; &#125; &#125; public int pop() &#123; // 两个栈都为空时，没有元素可以弹出 if (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123; try &#123; throw new Exception("stack is empty"); &#125; catch (Exception e) &#123; &#125; &#125; // 如果queue1为空，queue2有元素， 将queue2的元素依次放入queue1中，直到最后一个元素，我们弹出。 if (queue1.isEmpty()) &#123; while (queue2.size() &gt; 1) &#123; queue1.add(queue2.poll()); &#125; return queue2.poll(); &#125; if (queue2.isEmpty()) &#123; while (queue1.size() &gt; 1) &#123; queue2.add(queue1.poll()); &#125; return queue1.poll(); &#125; return (Integer) null; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[青蛙跳台阶]]></title>
      <url>%2F2017%2F03%2F24%2F%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
      <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路 假设第一次跳了一阶，那么还剩 n-1 阶，有f(n-1)中跳法。 假设第一次跳了2阶，那么还剩 n-2 阶，有f(n-2)中跳法。所以，这是一个斐波那契数列。f(n) = f(n-1)+f(n-2) 代码实现12345678910111213141516171819202122232425262728293031323334/** * 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 * * 思路：假设第一次跳了一阶，那么还剩 n-1 阶，有f(n-1)中跳法。 * * 假设第一次跳了2阶，那么还剩 n-2 阶，有f(n-2)中跳法。 * * 所以，这是一个斐波那契数列。f(n) = f(n-1)+f(n-2) * * @author XIAO * */public class JumpFloor &#123; public int JumpFloorSolution(int target) &#123; if (target == 0) &#123; return 0; &#125; if (target == 1) &#123; return 1; &#125; if (target == 2) &#123; return 2; &#125; int f1 = 1; int f2 = 2; int cursum = 0; for (int i = 3; i &lt;= target; i++) &#123; cursum = f1 + f2; f1 = f2; f2 = cursum; &#125; return cursum; &#125;&#125; 题目2 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路 假设第一次跳 1 阶。那么还剩 n-1 阶。一共还剩f(n-1)种跳法。 假设第一次跳 2 阶。那么还剩 n-2 阶。一共还剩f(n-2)种跳法。 。。。 假设第一次跳 n-1 阶。那么还剩 1 阶。一共还剩f(1)种跳法。 假设第一次跳 n 阶。一种跳法。 所以：f(n) = f(n-1)+f(n-2)+…+1; 而且:f(n-1) = f(n-2) +…+1; 所以f(n) = 2f(n-1) 代码实现1234567891011121314151617181920212223242526272829/** * 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 * * 思路：同样：假设第一次跳 1 阶。那么还剩 n-1 阶。一共还剩f(n-1)种跳法。 * * 假设第一次跳 2 阶。那么还剩 n-2 阶。一共还剩f(n-2)种跳法。 。。。 * * 假设第一次跳 n-1 阶。那么还剩 1 阶。一共还剩f(1)种跳法。 * * 假设第一次跳 n 阶。一种跳法。 * * 所以：f(n) = f(n-1)+f(n-2)+...+1; 而且:f(n-1) = f(n-2) +...+1; * * 所以f(n) = 2f(n-1) * * @author XIAO * */public class JumoFloor2 &#123; public int JumpFloorSolution(int target) &#123; if (target &lt;= 0) &#123; return 0; &#125; if (target == 1) &#123; return 1; &#125; return JumpFloorSolution(target - 1) * 2; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[矩阵覆盖]]></title>
      <url>%2F2017%2F03%2F24%2F%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96%2F</url>
      <content type="text"><![CDATA[题目描述我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思路有以下几种情形： target &lt;= 0 大矩形为&lt;= 2*0,直接return 0； target = 1大矩形为2*1，只有一种摆放方法，return1； target = 2 大矩形为2*2，有两种摆放方法，return2； target = n 分为两步考虑：第一次摆放一块 21 的小矩阵，则摆放方法总共为f(target - 1)√√第一次摆放一块1\2的小矩阵，则摆放方法总共为f(target-2)因为，摆放了一块1*2的小矩阵（用√√表示），对应下方的1*2（用××表示）摆放方法就确定了，所以为f(targte-2)√ √× ×所以：f(target) =f(target - 1) + f(targte-2)实际上就是一个斐波那契数列。 代码123456789101112131415public class Solution &#123; public int RectCover(int target) &#123; if(target==0)&#123; return 0; &#125; if(target==1)&#123; return 1; &#125; else if(target==2)&#123; return 2; &#125;else&#123; return RectCover(target-1)+RectCover(target-2); &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何终止一个线程]]></title>
      <url>%2F2017%2F03%2F23%2F%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[JAVA如何让一个线程死亡或结束&emsp;&emsp;不推荐使用stop()方法终止线程。，因为stop()方法容易引起死锁。12345678910111213141516171819202122232425262728291. /**2. * JAVA里面如何使用一个线程死亡或结束 *3. */4. public class T &#123;5. public static void main(String[] args) &#123;6. // 启动线程7. MyThread thread = new MyThread();8. new Thread(thread).start();9. 10. // 你的其它的工作，此时线程在运行中11. 12. // 你不想让线程干活了，停掉它13. // 注意，这只是一个标志，具体线程何时停，并不能精确控制14. thread.allDone = true;15. &#125;16. &#125;17. 18. class MyThread implements Runnable &#123;19. boolean **volatile** allDone = false;20. 21. public void run() &#123;22. // 每次循环都检测标志23. // 如果设置停止标志时已经在循环里24. // 则最长需要等待一个循环的时间才能终止25. while (!allDone) &#123;26. // 循环里的工作27. &#125;28. &#125;29. &#125; 使用 volatile 标识的变量具有线程可见性。当一个线程修改了这个变量的值，其他线程立即可以知道。所以可以避免多CPU出问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[求二叉树的深度]]></title>
      <url>%2F2017%2F03%2F21%2F%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 # 思路 &emsp;&emsp;递归求解 # 代码 undefined &emsp;下面是一个跟上面类似的题目。 # 题目描述 &emsp;&emsp;判断一棵树是不是平衡二叉树。平衡二叉树指左右子树的高度不超过1的二叉树。思路很简单，直接贴代码。 代码12345678910111213141516171819202122232425262728293031/** * 判断一棵树是不是平衡二叉树 * * 思路：递归求左右子树的深度，比较判断是否是平衡二叉树 * * @author XIAO * */public class IsBalancedBinaryTree &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; if (root == null) &#123; return true; &#125; int left = getDepth(root.left); int right = getDepth(root.right); if (Math.abs(left - right) &gt; 1) &#123; return false; &#125; return true; &#125; // 递归求解二叉树的深度 private int getDepth(TreeNode node) &#123; if (node == null) &#123; return 0; &#125; int left = getDepth(node.left); int right = getDepth(node.right); return left &gt; right ? left + 1 : right + 1; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一个只出现一次的字符]]></title>
      <url>%2F2017%2F03%2F21%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置. 思路&emsp;&emsp;暴力求解。 代码1234567891011121314151617181920212223242526272829303132333435/** * 在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置 * * 思路：暴力求解 * * @author XIAO * */public class FirstNotRepeatingCharSolution &#123; public int FirstNotRepeatingChar(String str) &#123; if (str == null || str.length() == 0) &#123; return -1; &#125; // 用一个map记录每个字符出现的次数 HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); if (map.containsKey(c)) &#123; int times = map.get(c); times += 1; map.put(c, times); &#125; else &#123; map.put(c, 1); &#125; &#125; // 出现一次的字符 首次出现的索引 for (int i = 0; i &lt; str.length(); i++) &#123; char c2 = str.charAt(i); if (map.get(c2) == 1) &#123; return i; &#125; &#125; return -1; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第N个丑数]]></title>
      <url>%2F2017%2F03%2F20%2F%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路&emsp;&emsp;暴力求解思路。首先我们要搞清楚怎么求丑数。ugly[]表示丑数数组。 ugly[0]=1; ugly[1]=1*2; ugly[3]=1*3; ugly[4]=122; ugly[5]=1*5; ugly[6]=123; …&emsp;&emsp;是不是可以找出规律来，我们需要记录 丑数中因子 2,3,5 出现的次数。具体用语言不好描述，可以看出规律。代码1234567891011121314151617181920212223242526272829303132333435/** * 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 * 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 * * @author XIAO * */public class GetUglyNumber &#123; public int GetUglyNumber_Solution(int index) &#123; if (index &lt;= 0) &#123; return 0; &#125; int[] result = new int[index]; result[0] = 1; int i2 = 0, i3 = 0, i5 = 0;// i2,i3,i5分别记录丑数的因子中2,3,5的个数 for (int i = 1; i &lt; index; i++) &#123; result[i] = min(result[i2] * 2, min(result[i3] * 3, result[i5] * 5)); if (result[i] == result[i2] * 2) &#123; i2++; &#125; if (result[i] == result[i3] * 3) &#123; i3++; &#125; if (result[i] == result[i5] * 5) &#123; i5++; &#125; &#125; return result[index - 1]; &#125; private int min(int i, int j) &#123; return i &gt; j ? j : i; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[把数组排成最小的数]]></title>
      <url>%2F2017%2F03%2F20%2F%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路&emsp;&emsp;不得不说，看了这题的解法，真的佩服！~&emsp;&emsp;先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。为什么需要定制排序，因为字符串 a和b 长度不等的情况。比如 “2” 和 “21” ,显然字符串”2”&lt;”21”,但是把他们链接起来的时候 221&gt;212.所以定制一种规则来排除这种情况。定制排序规则如下： 若ab &gt; ba 则 a &gt; b， 若ab &lt; ba 则 a &lt; b，若ab = ba 则 a = b；这个定制排序很妙！ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 * 例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。 * * 思路：真的思路太强。 * * 先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。 排序规则如下： 若ab &gt; * ba 则 a &gt; b， 若ab &lt; ba 则 a &lt; b， 若ab = ba 则 a = b； 解释说明： * 比如 "3" &lt;"31" 但是 * "331" &gt; "313"，所以要将二者拼接起来进行比较 * * @author XIAO * */public class MinNumberArray &#123; public String PrintMinNumber(int[] numbers) &#123; if (numbers == null || numbers.length == 0) &#123; return ""; &#125; int length = numbers.length; String[] strings = new String[length]; // 把整型数转换成字符串 for (int i = 0; i &lt; strings.length; i++) &#123; strings[i] = String.valueOf(numbers[i]); &#125; // 对字符串数组进行排序 Arrays.sort(strings, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; String s1 = o1 + o2; String s2 = o2 + o1; return s1.compareTo(s2); &#125; &#125;); StringBuilder builder = new StringBuilder(); //把排序好的字符串拼接在一起 for (int i = 0; i &lt; strings.length; i++) &#123; builder.append(strings[i]); &#125; return builder.toString(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[连续子数组的最大和]]></title>
      <url>%2F2017%2F03%2F19%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 思路test]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo利用Github分支在不同电脑上写博客]]></title>
      <url>%2F2017%2F03%2F19%2FHexo%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;利用github的不同分支来分别保存网站静态文件与hexo源码（md原始文件及主题等），实现在不同电脑上都可以自由写博客。 Github Page&emsp;&emsp;这里假设你已经在github上建好了page的仓库，也就是 “yourusername.github.io”的名字的项目仓库，比如我的 dxjia.github.io 。另外，也假设你在自己的电脑上已经配置好git、hexo、node js等环境。 新建hexo分支&emsp;仓库建好之后，都是默认一个master分支的，Github page要求你的网站文件必须存放在这个master分支上，这个没得选；所以我们需要新建另外一个分支来保存我们的hexo原始文件；master 保存的全是public 文件夹下的内容，这也是 hexo发布到github上的内容，而hexo这个分支，保存的是我们网站的配置 。 如下图在红色输入框内写入新建的branch名hexo后，回车即可建立新的branch-hexo； 设置默认分支&emsp;&emsp;因为我们写博客更多的是更新这个分支，网站文件所在的master分支则由hexo d命令发布文章的时候进行推送，所以我们将hexo分支设置为默认分支，这样我们在新的电脑环境下git clone该仓库时，自动切到hexo`分支。按下图进行操作。 配置hexo deploy参数&emsp;&emsp;为了保证hexo d命令可以正确部署到master分支，在hexo 的配置文件 _config.yml文件中配置参数如下：1234deploy: type: git repo: https://github.com/dxjia/dxjia.github.io.git branch: master &emsp;&emsp;hexo 3.0之后 deploy type，将github改为了git，这样适用性更广了，如果你发现无法hexo d，使用下面的命令安装git deployer插件后重试即可。1npm install hexo-deployer-git --save 修改推送到hexo分支&emsp;&emsp;上一步的deploy参数正确配置后，文章写完使用hexo g -d命令就可以直接部署了，生成的博客静态文件会自动部署到 username.github.io仓库的master分支上，这时候通过浏览器访问http://username.github.io就可以看到你的博客页面里。 &emsp;&emsp;网站页面是保存了，但这时候我们还没有保存我们的hexo原始文件，包括我们的文章md文件，我们千辛万苦修改的主题配置等。。。接下来使用下面的步骤将他们都统统推送到hexo分支上去。其中目录下的.gitignore 表示哪些文件或文件夹不提交，根据自己需要配置。如果没有.git文件，先git init。123git add .git commit -m “change description”git push origin hexo 如果没关联远程仓库，执行第三步会出错。和远程仓库关联执行：git remote add origin &lt;远程仓库地址&gt;这样就OK了，我们的原始文件就都上去了，换电脑也不怕了。 日常写博客&emsp;&emsp;有时候我们可能会在不同的电脑上写博客，那在不同的电脑上配置 hexo、git、node.js，以及配置git ssh key等都要折腾一下的，这是免不了的，也是比wordpress等其他博客框架麻烦的一点。 已有环境&emsp;&emsp;如果在电脑上已经写过博客，那么可以在已有的工作目录下同步之前写的博客。在你的仓库目录下右键’git bash shell’，起来bash命令行，然后 1git pull 这样你的状态就更新了，之后就是 hexo命令写文章啦。。。写完hexo g -d部署好后，使用 123git add .git commit -m “change description”git push origin hexo 推送到hexo分支上去。 新的环境&emsp;&emsp;到了新的电脑上时，我们需要将项目先下载到本地，然后再进行hexo初始化。记住不需要hexo init指令12345git clone https://github.com/dxjia/dxjia.github.io.gitcd dxjia.github.ionpm install hexonpm installnpm install hexo-deployer-git –save 之后开始写博客，写好部署好之后，别忘记 git add , ….git push origin hexo…推上去。。。&emsp;&emsp;原文地址：http://dxjia.cn/2016/01/27/hexo-write-everywhere/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo提交新文章错误]]></title>
      <url>%2F2017%2F03%2F19%2Fhexo%E6%8F%90%E4%BA%A4%E6%96%B0%E6%96%87%E7%AB%A0%E9%94%99%E8%AF%AF%2F</url>
      <content type="text"><![CDATA[hexo提交新文章出错&emsp;&emsp;提交文章的时候报了下面这个错误，1234567891011121314151617181920212223ERROR Process failed: _posts/数组中出现次数超过一半的数字.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1: ^ at generateError (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\ js-yaml\loader.js:162:10) at throwError (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js- yaml\loader.js:168:9) at readBlockMapping (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\l ib\js-yaml\loader.js:1045:9) at composeNode (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js -yaml\loader.js:1331:12) at readDocument (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\j s-yaml\loader.js:1493:3) at loadDocuments (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\ js-yaml\loader.js:1549:5) at Object.load (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js -yaml\loader.js:1566:19) at parseYAML (F:\Myblog\hexo\node_modules\hexo\node_modules\hexo-front-matte r\lib\front_matter.js:80:21) at parse (F:\Myblog\hexo\node_modules\hexo\node_modules\hexo-front-matter\li b\front_matter.js:56:12) at F:\Myblog\hexo\node_modules\hexo\lib\plugins\processor\post.js:52:18 at tryCatcher (F:\Myblog\hexo\node_modules\hexo\node_modules\bluebird\js\rel ease\util.js:16:23) at Promise._settlePromiseFromHandler (F:\Myblog\hexo\node_modules\hexo\node_ modules\bluebird\js\release\promise.js:509:35) at Promise._settlePromise (F:\Myblog\hexo\node_modules\hexo\node_modules\blu ebird\js\release\promise.js:569:18) at Promise._settlePromise0 (F:\Myblog\hexo\node_modules\hexo\node_modules\bl uebird\js\release\promise.js:614:10) at Promise._settlePromises (F:\Myblog\hexo\node_modules\hexo\node_modules\bl uebird\js\release\promise.js:693:18) at Promise._fulfill (F:\Myblog\hexo\node_modules\hexo\node_modules\bluebird\ js\release\promise.js:638:18) at PromiseArray._resolve (F:\Myblog\hexo\node_modules\hexo\node_modules\blue bird\js\release\promise_array.js:126:19) at PromiseArray._promiseFulfilled (F:\Myblog\hexo\node_modules\hexo\node_mod ules\bluebird\js\release\promise_array.js:144:14) at PromiseArray._iterate (F:\Myblog\hexo\node_modules\hexo\node_modules\blue 仔细排查之后，发现是文章开头的categroies的冒号，写成了中文的冒号。额。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组中出现次数超过一半的数字]]></title>
      <url>%2F2017%2F03%2F19%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路&emsp;&emsp;对于这个问题提供两个解题思路。还有很多其他解法。 利用排序。先对数组进行排序，因为题目已知，有一个数字出现的次数超过了数组长度的一半。显然，排序完成之后中间的那个数组必定是这个数组。复杂度O(nlgn) 充分利用数组中有一个数字出现的次数超过数组长度的一半这个条件。这个数一定是相邻重复出现的次数最多的数。即使是最差情况，隔一个数插入这个数，最终这个数必定会出现在最后一位（还是因为出现次数大于数组长度的一半）。这个算法的复杂度只有O（n），不得不说，这个思路真的巧妙。代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。 * 由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 * * 思路1：快速排序 思路2：找最大相邻重复出现的元素 * * @author XIAO * */public class MoreThanHalfNumArray &#123; /** * 第一种思路 * * @param array * @return */ public int MoreThanHalfNum_Solution(int[] array) &#123; // 判断数组长度是否为0或者数组为null if (array.length == 0 || array == null) return 0; Arrays.sort(array);// 快速排序对数组进行排序 int mid = array[(array.length) / 2];// 中间的元素 // 对mid 进行验证 int count = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (mid == array[i]) &#123; count++; &#125; &#125; return count &gt; (array.length / 2) ? mid : 0; &#125; // 第二种思路，想了很久才想明白。关键是利用有一个数的出现次数大于数组长度的一半这个条件 public int MoreThanHalfNum_Solution2(int[] array) &#123; // 判断数组长度是否为0或者数组为null if (array.length == 0 || array == null) return 0; // 寻找相邻重复次数最多的元素 int temp = array[0];// 从第一个元素开始找 int times = 1;// 重复出现的次数 for (int i = 1; i &lt; array.length; i++) &#123; if (times == 0) &#123; temp = array[i];// 最后一次赋值的必定是我们要找的元素 times = 1; &#125; else if (array[i] == temp) &#123; times++; &#125; else &#123; times--; &#125; &#125; // 验证 int count = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] == temp) &#123; count++; &#125; &#125; return count &gt; (array.length / 2) ? temp : 0; &#125;&#125; 总结&emsp;&emsp;总体来看，第一种方法比较容易想到，时间复杂度较高。第二种方法想了很久才想明白，哎，算法能力有待提高！时间复杂度才O(N)!其他还有很多方法，有待考虑。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[按字典序输出一个字符串的全排序]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 思路&emsp;&emsp;大脑短路了，想明白这个竟然花了半小时。这个题目的核心其实是求解一个字符串的全排列。因为字典序只需要用Collection.sort()方法排序一个ArrayList 或者TreeSet就行了。&emsp;主要说下怎么对一个字符串进行全排列。比如说”abcd”怎么全排序呢?直觉告诉我们先把a放第一位，对”bcd”再进行全排列，就是一个递归。然后把b放在第一位，”acd”进行递归。…具体操作下面结合代码说。&emsp;下面就是对全排列的字符串进行排序操作，按字典序输出即可。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.ArrayList;import java.util.Collections;/** * 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串 * abc,acb,bac,bca,cab和cba。 * * 思路：先求解字符串的全排列，然后对这些全排列进行排序。 * * @author XIAO * */public class StringPermutationSort &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();// 保存全排列的结果 if (str != null &amp;&amp; str.length() &gt; 0) &#123;// 如果str不为空 Permutation(str.toCharArray(), 0, result);// 获取字符串的全排列 &#125; Collections.sort(result);// 对全排列的字符串进行排序 return result; &#125; /** * i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列 * * @param charArray * @param i * @param result */ private void Permutation(char[] charArray, int i, ArrayList&lt;String&gt; result) &#123; // 如果 i 是最后一个字符位置 if (i == charArray.length - 1) &#123; result.add(String.valueOf(charArray));// 找到一个全排序 &#125; else &#123; for (int j = i; j &lt;= charArray.length - 1; j++) &#123; if (j != i &amp;&amp; charArray[j] == charArray[i])// 有重复字符时，跳过 continue; swap(charArray, i, j); Permutation(charArray, i + 1, result); swap(charArray, i, j); &#125; &#125; &#125; // 交换字符数组s的第i个位置和第j个位置的字符 private void swap(char[] s, int i, int j) &#123; if (s[i] == s[j]) &#123; ; &#125; else &#123; char c = s[i]; s[i] = s[j]; s[j] = c; &#125; &#125;&#125; &emsp;&emsp;回头再看究竟是怎么全排列的吧。就是这个函数 private void Permutation(char[] charArray, int i, ArrayList result) 的递归过程。其中 i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列。当i == charArray.length - 1 时，表示已经到了最后一个字符，那么就找到了一个全排列。下面很好看懂，就是递归向下找，但是为什么要交换两次 charArray i和j 位置的字符呢？&emsp;&emsp;其实拿”abcd”来说，当我们交换 a和b 的位置（第一次交换），然后用b作为首字符寻找全排列。但是下次我们要交换 a和c 的位置，但是这时候 a和b 已经交换了，所以要把 a和b 换回来，才能保证每次交换的顺序没有乱。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二叉搜索树与双向链表]]></title>
      <url>%2F2017%2F03%2F18%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路&emsp;&emsp;使用递归的思想。步骤如下：&emsp;1. 将左子树构造成双链表，并返回链表头节点。&emsp;2. 定位至左子树双链表最后一个节点。&emsp;3. 如果左子树链表不为空的话，将当前root追加到左子树链表。&emsp;4. 将右子树构造成双链表，并返回链表头节点。&emsp;5. 如果右子树链表不为空的话，将该链表追加到root节点之后。&emsp;6. 根据左子树链表是否为空确定返回的节点。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142/** * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 * 思路：解题思路： 1.将左子树构造成双链表，并返回链表头节点。 2.定位至左子树双链表最后一个节点。 3.如果左子树链表不为空的话，将当前root追加到左子树链表。 4.将右子树构造成双链表，并返回链表头节点。 5.如果右子树链表不为空的话，将该链表追加到root节点之后。 6.根据左子树链表是否为空确定返回的节点。 * @author XIAO * */public class BinaryTreeLinkedList &#123; public TreeNode Convert(TreeNode root) &#123; if (root == null) &#123; return null; &#125; // 如果root的左右子树都为空 if (root.left == null &amp;&amp; root.right == null) &#123; return root; &#125; TreeNode left = Convert(root.left);// 把root节点的左子树转成链表，返回值为链表的头 TreeNode p = left; while (p != null &amp;&amp; p.right != null) &#123; p = p.right;// 循环定位到左子树双链表的最后一个节点 &#125; // 如果左子树链表不为空的话，将当前root追加到左子树链表 if (left != null) &#123; p.right = root;// 把root连接到左子树形成的双向链表中，双向链表，需要左右都连接 root.left = p; &#125; // 同样的，把根节点的右子树也形成双向链表，返回值为链表头 TreeNode right = Convert(root.right); // 把右子树的链表连接到上面的左子树和根节点的链表中 if (right != null) &#123; root.right = right;// 同样把右子树的链表连接上去 right.left = root; &#125; return left != null ? left : root; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二叉树中和为某一值的路径]]></title>
      <url>%2F2017%2F03%2F18%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 代码实现123456789101112131415public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null) return listAll; list.add(root.val); target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) listAll.add(new ArrayList&lt;Integer&gt;(list)); FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1);//返回父节点继续搜索 return listAll; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试字符串中是否包含重复字符]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%B5%8B%E8%AF%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;请实现一个算法，确定一个字符串的所有字符全都不同。要求不允许使用额外的存储空间。 思路&emsp;&emsp;暂时没想到好的思路，只能暴力求解。 代码实现12345678910public class StringRepeat &#123; // 暴力求解，双层循环，一一比较 public boolean checkDifferent(String iniString) &#123; for (int i = 0;i&lt;iniString.length();i++) &#123; for (int j = i+1;j&lt;iniString.length();j++) &#123; if (iniString.charAt(i) == iniString.charAt(j)) return false; &#125; &#125; return true;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F07%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
