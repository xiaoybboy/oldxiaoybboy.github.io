<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[java源码之ArrayList]]></title>
      <url>%2F2017%2F04%2F06%2Fjava%E6%BA%90%E7%A0%81%E4%B9%8BArrayList%2F</url>
      <content type="text"><![CDATA[ArrayList概述：1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList是基于数组实现的，Object[] elementData;是一个动态数组，其容量能自动增长。 ArrayList与Collection关系如下图： ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。 ArrayList的实现： 对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码： 私有属性： ArrayList定义只定义类两个私有属性：1234567891011121. /** 2. * The array buffer into which the elements of the ArrayList are stored3. * The capacity of the ArrayList is the length of this array buffer. 4. */ 5. private transient Object[] elementData; 6. 7. /** 8. * The size of the ArrayList (the number of elements it contains). 9. * @serial 10. */ 11. private int size; 12 很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。有个关键字需要解释：transient。Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。被标记为transient的属性在对象被序列化的时候不会被保存。接着回到ArrayList的分析中…… modCount和Array.copyof()，System.arraycopy。在父类AbstractList中定义了一个int型的属性：modCount，记录了ArrayList结构性变化的次数。protected transient int modCount = 0; 在ArrayList的所有涉及结构变化的方法中都增加modCount的值，包括：add()、remove()、addAll()、removeRange()及clear()方法。这些方法每调用一次，modCount的值就加1。 注：add()及addAll()方法的modCount的值是在其中调用的ensureCapacity()方法中增加的。然后，先了解一个方法，下面到处都会用到。Array.copyof()，System.arraycopy。12345678910111. public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; 2. return (T[]) copyOf(original, newLength, original.getClass()); 3. &#125; 4. 5. public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; 6. T[] copy = ((Object)newType == (Object)Object[].class) 7. ? (T[]) new Object[newLength] // 类型相同，则重新生成一个大小为newLength的数组实例 8. : (T[]) Array.newInstance(newType.getComponentType(), newLength); // 类型不同，重新生成一个大小为newLength的新类型数组实例 9. System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); //将原数组内容拷贝到新数组中,新数组取最小的数组长度 10. return copy; // 返回新数组的引用 11. &#125; 而其中的System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)的声明： public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);src - 源数组。srcPos - 源数组中的起始位置。dest - 目标数组。destPos - 目标数据中的起始位置。length - 要复制的数组元素的数量。System.arraycopy是一个native方法，是底层使用c++实现的。 构造方法：ArrayList提供了三种方式的构造器，可以构造一个默认的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960612. * Constructs an empty list with the specified initial capacity. 3. */ 4. public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; //初始容量大于0,实例化数组5. this.elementData = new Object[initialCapacity]; 6. &#125; else if (initialCapacity == 0) &#123; //初始容量为07. this.elementData = EMPTY_ELEMENTDATA; //空数组8. &#125; else &#123; 9. throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ 10. initialCapacity); 11. &#125; 12. &#125; 13. 14. /** ArrayList无参构造函数。15. * Constructs an empty list with an initial capacity of ten. 16. */ 17. public ArrayList() &#123; 18. this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; 19. &#125; 20. 21. /** // 创建一个包含collection的ArrayList22. * Constructs a list containing the elements of the specified 23. * collection, in the order they are returned by the collection&apos;s 24. * iterator. */ 25. public ArrayList(Collection&lt;? extends E&gt; c) &#123; 26. elementData = c.toArray(); //先转化成数组27. if ((size = elementData.length) != 0) &#123; //如果集合不为空28. // c.toArray might (incorrectly) not return Object[] 29. if (elementData.getClass() != Object[].class) 30. //给elementData 赋值31. elementData = Arrays.copyOf(elementData, size, Object[].class);32. &#125; else &#123; 33. // 如果是一个空的集合，用空数组来替换34. this.elementData = EMPTY_ELEMENTDATA; 35. &#125; 36. &#125;37.``` 有参的两个构造器很好理解，下面说下无参的构造器。EMPTY_ELEMENTDATA是什么的？看名字就知道了，是一个空的数组。DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是一个空数组。那么他们之间有什么区别呢？为什么ArrayList无参构造函数构造的是一个DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空数组呢？因为以前的代码是直接初始化一个长度为10的数组。看上面的注释，我们可以知道，We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added.就是当第一个元素被加入到elementData中时，区分这两者。```java1. /** 2. * 默认的初始容量为10 3. */ 4. private static final int DEFAULT_CAPACITY = 10; 5. 6. /** 7. * Shared empty array instance used for empty instances. 8. */ 9. private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 10. 11. /** 12. * Shared empty array instance used for default sized empty instances. We13. * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added. 14. */ 15. private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 既然如此，我们先看一下add()1. public boolean add(E e) &#123; 2. ensureCapacityInternal(size + 1); // Increments modCount!! 3. elementData[size++] = e; 4. return true; 5. &#125; 看第一行，应该就是区分的体现了，下面着重看下这个ensureCapacityInternal()函数。这涉及到下面的数组容量扩充，我们单独说一下。 调整数组容量ensureCapacity：与之前的ArrayList源码改变最大的就是这一部分了，先把三个调整容量的函数都贴出来，下面要多次用到。ensureCapacityInternal是第二个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631. /** 2. * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if 3. * necessary, to ensure that it can hold at least the number of elements 4. * specified by the minimum capacity argument. 5. * 6. * @param minCapacity the desired minimum capacity 7. */ 8. public void ensureCapacity(int minCapacity) &#123; 9. int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) 10. // any size if not default element table 11. ? 0 12. // larger than default for default empty table. It's already 13. // supposed to be at default size. 14. : DEFAULT_CAPACITY; 15. 16. if (minCapacity &gt; minExpand) &#123; 17. ensureExplicitCapacity(minCapacity); 18. &#125; 19. &#125; 20. 21. private void ensureCapacityInternal(int minCapacity) &#123; 22. if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; 23. minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); 24. &#125; 25. ensureExplicitCapacity(minCapacity); 26. &#125; 27. 28. private void ensureExplicitCapacity(int minCapacity) &#123; 29. modCount++; 30. if (minCapacity - elementData.length &gt; 0) 31. grow(minCapacity); 32. &#125; 1. /** 容量扩充，确保数组中至少能包含minimum capacity个元素2. * Increases the capacity to ensure that it can hold at least the 3. * number of elements specified by the minimum capacity argument. 4. * 5. * @param minCapacity the desired minimum capacity 6. */ 7. private void grow(int minCapacity) &#123; 8. int oldCapacity = elementData.length; 9. int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //原来容量的1.5倍 10. if (newCapacity - minCapacity &lt; 0) 11. newCapacity = minCapacity; 12. if (newCapacity - MAX_ARRAY_SIZE &gt; 0) 13. newCapacity = hugeCapacity(minCapacity); 14. // minCapacity is usually close to size, so this is a win: 15. elementData = Arrays.copyOf(elementData, newCapacity); 16. &#125; 17. //对大容量数组的处理18. private static int hugeCapacity(int minCapacity) &#123; 19. if (minCapacity &lt; 0) // overflow 20. throw new OutOfMemoryError(); 21. return (minCapacity &gt; MAX_ARRAY_SIZE) ? 22. Integer.MAX_VALUE : 23. MAX_ARRAY_SIZE; 24. &#125; 看ensureCapacityInternal中的下面这一句33. if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; 34. minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); 35. &#125; ``` 看到了吧，先比较DEFAULT_CAPACITY和minCapacity，取较大的值作为minCapacity，显然，对于无参的构造器的空数组，比较的结果是DEFAULT_CAPACITY(上面有定义是10)，然后接下来执行ensureExplicitCapacity(minCapacity)。再接下来，实际执行扩充的是grow(int minCapacity) 这个函数。上面如果是初始化的时候，容易计算此时的minCapacity = DEFAULT_CAPACITY = 10.所以执行grow的时候， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; ```会执行这一句，应该空的数组扩充1.5倍之后还是空的。接着往下看，就可以知道其实无参的ArrayList的构造器初始化的是一个长度为10的elementData 数组。总结对于无参的ArrayList构造器，初始化的其实是一个容量为10的Object[] elementData 数组。每次执行扩充时，最终进行数组容量扩充的是grow（）函数，而且不难看出每次数组扩充后的容量为原来数组容量 的1.5倍。int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);元素存储：ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解：```java //两个范围检验函数，查看索引是否越界，越界抛出异常 private void rangeCheck(int index) { if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private void rangeCheckForAdd(int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); . } // 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。 public E set(int index, E element) { RangeCheck(index); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; } // 将指定的元素添加到此列表的尾部。 上面讲到过这个函数，实现也很简单 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } // 将指定的元素插入此列表中的指定位置。 // 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。 public void add(int index, E element) { rangeCheckForAdd(index);//索引范围检验 ensureCapacityInternal(size + 1); // 扩充1个单元 // 将 elementData中从Index位置开始、长度为size-index的元素， // 拷贝到从下标为index+1位置开始的新的elementData数组中。 // 即将当前位于该位置的元素以及所有后续元素右移一个位置。 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element;//插入元素 size++; } // 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。 public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] a = c.toArray();//先转换成数组 int numNew = a.length; ensureCapacityInternal(size + numNew); // 容量扩充 System.arraycopy(a, 0, elementData, size, numNew);//元素复制 size += numNew; return numNew != 0; } // 从指定的位置开始，将指定collection中的所有元素插入到此列表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) { rangeCheckForAdd(index);//索引检查 Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // 容量扩充 int numMoved = size - index;//要移动的元素的个数 if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved);//复制元素 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; }```ArrayList是基于数组实现的，可以看到上面的添加元素的方法，大都需要先进行索引检查（与操作索引相关的），还要进行数组容量的扩充，然后是 System.arraycopy复制元素。具体过程查看上面的注释。元素读取：这个很简单，直接返回数组i位置上的元素即可。 // 返回此列表中指定位置上的元素。 public E get(int index) { RangeCheck(index); return (E) elementData[index]; } 元素删除：ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：romove(int index): // 移除此列表中指定位置上的元素。 public E remove(int index) { RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[–size] = null; // Let gc do its work return oldValue; }首先是检查范围，修改modCount，保留将要被移除的元素，将移除位置之后的元素向前挪动一个位置，将list末尾元素置空（null），返回被移除的元素。remove(Object o) 1 // 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。 2 public boolean remove(Object o) { 3 // 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。 4 if (o == null) { 5 for (int index = 0; index &lt; size; index++) 6 if (elementData[index] == null) { 7 // 类似remove(int index)，移除列表中指定位置上的元素。 8 fastRemove(index); 9 return true; 10 } 11 } else { 12 for (int index = 0; index &lt; size; index++) 13 if (o.equals(elementData[index])) { 14 fastRemove(index); 15 return true; 16 } 17 } 18 return false; 19 } 20 }首先通过代码可以看到，当移除成功后返回true，否则返回false。remove(Object o)中通过遍历element寻找是否存在传入对象，一旦找到就调用fastRemove移除对象。为什么找到了元素就知道了index，不通过remove(index)来移除元素呢？因为fastRemove跳过了判断边界的处理，因为找到元素就相当于确定了index不会超过边界，而且fastRemove并不返回被移除的元素。下面是fastRemove的代码，基本和remove(index)一致。方法说明：skips bounds checking and does notreturn the value removed. 1 private void fastRemove(int index) { 2 modCount++; 3 int numMoved = size - index - 1; 4 if (numMoved &gt; 0) 5 System.arraycopy(elementData, index+1, elementData, index, numMoved); 7 elementData[–size] = null; // Let gc do its work 8 } batchRemove() //保留集合c中的元素，集合外的元素全部删除 Retains only the elements in this list that are contained in the specified collection. In other words, removes from this list all of its elements that are not contained in the specified collection. public boolean retainAll(Collection&lt;?&gt; c) { Objects.requireNonNull(c); return batchRemove(c, true); } private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) { final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try { for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; } finally { // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) { System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; } if (w != size) { // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; } } return modified; } removeRange(int fromIndex,int toIndex) protected void removeRange(int fromIndex, int toIndex) { 2 modCount++; 3 int numMoved = size - toIndex; 4 System.arraycopy(elementData, toIndex, elementData, fromIndex, 5 numMoved); 6 7 // Let gc do its work 8 int newSize = size - (toIndex-fromIndex); 9 while (size != newSize) 10 elementData[–size] = null; 11 }执行过程是将elementData从toIndex位置开始的元素向前移动到fromIndex，然后将toIndex位置之后的元素全部置空顺便修改size。这个方法是protected，及受保护的方法，为什么这个方法被定义为protected呢？这是一个解释，但是可能不容易看明白。http://stackoverflow.com/questions/2289183/why-is-javas-abstractlists-removerange-method-protected先看下面这个例子 ArrayList ints = new ArrayList(Arrays.asList(0, 1, 2, 3, 4, 5, 6)); // fromIndex low endpoint (inclusive) of the subList // toIndex high endpoint (exclusive) of the subList ints.subList(2, 4).clear(); System.out.println(ints);输出结果是[0, 1, 4, 5, 6]，结果是不是像调用了removeRange(int fromIndex,int toIndex)！哈哈哈，就是这样的。但是为什么效果相同呢？是不是调用了removeRange(int fromIndex,int toIndex)呢？ ＃＃ ArrayList和Vector区别：• ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。• Vector提供indexOf(obj, start)接口，ArrayList没有。• Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。 ## trimToSize ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下：public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } }由于elementData的长度会被拓展，size标记的是其中包含的元素的个数。所以会出现size很小但elementData.length很大的情况，将出现空间的浪费。trimToSize将返回一个新的数组给elementData，元素内容保持不变，length和size相同，节省空间。)转为静态数组toArray＃＃ 注意ArrayList的两个转化为静态数组的toArray方法。第一个， 调用Arrays.copyOf将返回一个数组，数组内容是size个elementData的元素，即拷贝elementData从0至size-1位置的元素到新数组并返回。 public Object[] toArray() { return Arrays.copyOf(elementData, size); }第二个，如果传入数组的长度小于size，返回一个新的数组，大小为size，类型与传入数组相同。所传入数组长度与size相等，则将elementData复制到传入数组中并返回传入的数组。若传入数组长度大于size，除了复制elementData外，还将把返回数组的第size个元素置为空。 public T[] toArray(T[] a) { if (a.length &lt; size) // Make a new array of a’s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; }＃＃ clone(),返回此 ArrayList 实例的浅表副本。（不复制这些元素本身。）调用父类的clone方法返回一个对象的副本，将返回对象的elementData数组的内容赋值为原对象elementData数组的内容，将副本的modCount设置为0。 public Object clone() { try { ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn’t happen, since we are Cloneable throw new InternalError(e); } }11) clear() public void clear() { modCount++; // Let gc do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; }clear的时候并没有修改elementData的长度（好不容易申请、拓展来的，凭什么释放，留着搞不好还有用呢。这使得确定不再修改list内容之后最好调用trimToSize来释放掉一些空间），只是将所有元素置为null，size设置为0。12) contains(Object) public boolean contains(Object o) { return indexOf(o) &gt;= 0; }indexOf方法返回值与0比较来判断对象是否在list中。接着看indexOf。 public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1; }lastIndexOf，光看名字应该就明白了返回的是传入对象在elementData数组中最后出现的index值。 public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i &gt;= 0; i–) if (elementData[i]==null) return i; } else { for (int i = size-1; i &gt;= 0; i–) if (o.equals(elementData[i])) return i; } return -1; }采用了从后向前遍历element数组，若遇到Object则返回index值，若没有遇到，返回-1.13）序列化因为实现了java.io.Serializable接口，索引可以进行序列化操作。 /** Save the state of the ArrayList instance to a stream (that is, serialize it). 把arraylist实例写入一个流中 */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } /** Reconstitute the ArrayList instance from a stream (that is, deserialize it). 从流中读出一个ArrayList实例 */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) { // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) { a[i] = s.readObject(); } } }Fail-Fast机制：ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。14)ArrayList的遍历方式 ArrayList支持3种遍历方式 1、通过迭代器遍历：Iterator iter = list.iterator();while (iter.hasNext()){System.out.println(iter.next());} 2、随机访问，通过索引值去遍历，由于ArrayList实现了RandomAccess接口int size = list.size();for (int i=0; i&lt;size; i++){System.out.println(list.get(i));} 3、for循环遍历：for(String str:list){System.out.println(str); }4.方法4for(int i = 0;i &lt; list.size(); i ++){ System.out.println(list.get(i));}二．总结:关于ArrayList的源码，给出几点比较重要的总结：1、注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。2、注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。3、ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码： public static T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass()); }很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型，其源码如下： public static T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) { T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; }这里可以很明显地看出，该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。4、ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。5、在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。 数组扩容这是对ArrayList效率影响比较大的一个因素。每 当执行Add、AddRange、Insert、InsertRange等添加元素的方法，都会检查内部数组的容量是否不够了，如果是，它就会以当前容量 的两倍来重新构建一个数组，将旧元素Copy到新数组中，然后丢弃旧数组，在这个临界点的扩容操作，应该来说是比较影响效率的。例1：比如，一个可能有200个元素的数据动态添加到一个以默认16个元素大小创建的ArrayList中，将会经过：162222 = 256四次的扩容才会满足最终的要求，那么如果一开始就以：ArrayList List = new ArrayList( 210 );的方式创建ArrayList，不仅会减少4次数组创建和Copy的操作，还会减少内存使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java Scanner next()和nextLine()]]></title>
      <url>%2F2017%2F04%2F02%2FJava-Scanner-next-%E5%92%8CnextLine%2F</url>
      <content type="text"><![CDATA[java中使用Scanner类获取数据输入十分方便，Scanner类中next()与nextLine()都可以实现字符串String的获取.它们的区别如下： next() 方法从第一个有效字符（非空格，非换行符），开始扫描。当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容，即获得第一个扫描到的不含空格、换行符的单个字符串。 使用nextLine()时，则可以扫描到一行内容并作为一个字符串而被获取到。可以获取空格。 测试1234567891011121314public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("---&gt;Test1:\n"); String nextStr = scanner.next(); System.out.println("scanner.next()得到：" + nextStr); String nextlineStr = scanner.nextLine(); System.out.println("scanner.nextLine()得到：" + nextlineStr); System.out.println("\n---&gt;Test2:"); String nextlineStr2 = scanner.nextLine(); System.out.println("scanner.nextLine()得到：" + nextlineStr2); String nextStr2 = scanner.next(); System.out.println("scanner.next()得到：" + nextStr2); &#125; 结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github上ssh配置]]></title>
      <url>%2F2017%2F03%2F31%2Fgithub%E4%B8%8Assh%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[配置 ssh key使用 git bash 生成 public ssh key，以下是最简单的方法12$ ssh-keygen -t rsaC/Documents and Settings/username/.ssh 目录下会生成 id_rsa.pub 将 id_rsa.pub 的内容完全复制到 github Account Setting 里的 ssh key 里即可 测试1$ ssh -T git@github.com 然后会看到1Hi [yourGithubAccount]! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 设置用户信息12$ git config --global user.name &quot;[yourName]&quot;//用户名$ git config --global user.email &quot;[yourEmail]&quot;//填写自己的邮箱 经过以上步骤，本机已成功连接到 github，为部署打下基础。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[栈与队列]]></title>
      <url>%2F2017%2F03%2F24%2F%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型. 思路假设两个栈为A和B。 入队列的时候，只需要向A栈中入栈即可。 出队列的时候，要先检查B栈是否为空。如果B为空，把A栈中的元素全部放入B栈中。如果B不为空，就从B栈顶弹出一个元素。这样就实现了一个队列先进先出的功能。代码实现1234567891011121314151617181920212223242526272829303132/** * 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 * &lt;分析&gt;： * 入队：将元素进栈A * 出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈； 如果不为空，栈B直接出栈。 * * @author XIAO * */import java.util.Stack;public class StackQueue &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; int a; if (!stack2.isEmpty()) &#123; a = stack2.pop(); &#125; else &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; a = stack2.pop(); &#125; return a; &#125;&#125; 题目描述用两个队列实现栈的功能。 思路把B当做一个中转站入栈：将元素进队列A出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把队列B中的元素出队列以此放入队列A中。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 用两个队列实现栈的功能； 思路 &lt;分析&gt;：把B当做一个中转站 入栈：将元素进队列A * 出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素出队列并放入队列B，直到队列A中的元素留下一 * 个，然后队列A出队列，再把 队列B中的元素出队列以此放入队列A中。 * * @author XIAO * */public class QueueStack &#123; Queue&lt;Integer&gt; queue1 = new ArrayDeque&lt;&gt;(); Queue&lt;Integer&gt; queue2 = new ArrayDeque&lt;&gt;(); public void push(int node) &#123; // 两个栈都为空时，优先考虑queue1 if (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123; queue1.add(node); return; &#125; // 如果queue1为空，queue2有元素，直接放入queue2 if (queue1.isEmpty()) &#123; queue2.add(node); return; &#125; if (queue2.isEmpty()) &#123; queue1.add(node); return; &#125; &#125; public int pop() &#123; // 两个栈都为空时，没有元素可以弹出 if (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123; try &#123; throw new Exception("stack is empty"); &#125; catch (Exception e) &#123; &#125; &#125; // 如果queue1为空，queue2有元素， 将queue2的元素依次放入queue1中，直到最后一个元素，我们弹出。 if (queue1.isEmpty()) &#123; while (queue2.size() &gt; 1) &#123; queue1.add(queue2.poll()); &#125; return queue2.poll(); &#125; if (queue2.isEmpty()) &#123; while (queue1.size() &gt; 1) &#123; queue2.add(queue1.poll()); &#125; return queue1.poll(); &#125; return (Integer) null; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[青蛙跳台阶]]></title>
      <url>%2F2017%2F03%2F24%2F%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
      <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路 假设第一次跳了一阶，那么还剩 n-1 阶，有f(n-1)中跳法。 假设第一次跳了2阶，那么还剩 n-2 阶，有f(n-2)中跳法。所以，这是一个斐波那契数列。f(n) = f(n-1)+f(n-2) 代码实现12345678910111213141516171819202122232425262728293031323334/** * 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 * * 思路：假设第一次跳了一阶，那么还剩 n-1 阶，有f(n-1)中跳法。 * * 假设第一次跳了2阶，那么还剩 n-2 阶，有f(n-2)中跳法。 * * 所以，这是一个斐波那契数列。f(n) = f(n-1)+f(n-2) * * @author XIAO * */public class JumpFloor &#123; public int JumpFloorSolution(int target) &#123; if (target == 0) &#123; return 0; &#125; if (target == 1) &#123; return 1; &#125; if (target == 2) &#123; return 2; &#125; int f1 = 1; int f2 = 2; int cursum = 0; for (int i = 3; i &lt;= target; i++) &#123; cursum = f1 + f2; f1 = f2; f2 = cursum; &#125; return cursum; &#125;&#125; 题目2 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路 假设第一次跳 1 阶。那么还剩 n-1 阶。一共还剩f(n-1)种跳法。 假设第一次跳 2 阶。那么还剩 n-2 阶。一共还剩f(n-2)种跳法。 。。。 假设第一次跳 n-1 阶。那么还剩 1 阶。一共还剩f(1)种跳法。 假设第一次跳 n 阶。一种跳法。 所以：f(n) = f(n-1)+f(n-2)+…+1; 而且:f(n-1) = f(n-2) +…+1; 所以f(n) = 2f(n-1) 代码实现1234567891011121314151617181920212223242526272829/** * 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 * * 思路：同样：假设第一次跳 1 阶。那么还剩 n-1 阶。一共还剩f(n-1)种跳法。 * * 假设第一次跳 2 阶。那么还剩 n-2 阶。一共还剩f(n-2)种跳法。 。。。 * * 假设第一次跳 n-1 阶。那么还剩 1 阶。一共还剩f(1)种跳法。 * * 假设第一次跳 n 阶。一种跳法。 * * 所以：f(n) = f(n-1)+f(n-2)+...+1; 而且:f(n-1) = f(n-2) +...+1; * * 所以f(n) = 2f(n-1) * * @author XIAO * */public class JumoFloor2 &#123; public int JumpFloorSolution(int target) &#123; if (target &lt;= 0) &#123; return 0; &#125; if (target == 1) &#123; return 1; &#125; return JumpFloorSolution(target - 1) * 2; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[矩阵覆盖]]></title>
      <url>%2F2017%2F03%2F24%2F%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96%2F</url>
      <content type="text"><![CDATA[题目描述我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思路有以下几种情形： target &lt;= 0 大矩形为&lt;= 2*0,直接return 0； target = 1大矩形为2*1，只有一种摆放方法，return1； target = 2 大矩形为2*2，有两种摆放方法，return2； target = n 分为两步考虑：第一次摆放一块 21 的小矩阵，则摆放方法总共为f(target - 1)√√第一次摆放一块1\2的小矩阵，则摆放方法总共为f(target-2)因为，摆放了一块1*2的小矩阵（用√√表示），对应下方的1*2（用××表示）摆放方法就确定了，所以为f(targte-2)√ √× ×所以：f(target) =f(target - 1) + f(targte-2)实际上就是一个斐波那契数列。 代码123456789101112131415public class Solution &#123; public int RectCover(int target) &#123; if(target==0)&#123; return 0; &#125; if(target==1)&#123; return 1; &#125; else if(target==2)&#123; return 2; &#125;else&#123; return RectCover(target-1)+RectCover(target-2); &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何终止一个线程]]></title>
      <url>%2F2017%2F03%2F23%2F%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[JAVA如何让一个线程死亡或结束&emsp;&emsp;不推荐使用stop()方法终止线程。，因为stop()方法容易引起死锁。12345678910111213141516171819202122232425262728291. /**2. * JAVA里面如何使用一个线程死亡或结束 *3. */4. public class T &#123;5. public static void main(String[] args) &#123;6. // 启动线程7. MyThread thread = new MyThread();8. new Thread(thread).start();9. 10. // 你的其它的工作，此时线程在运行中11. 12. // 你不想让线程干活了，停掉它13. // 注意，这只是一个标志，具体线程何时停，并不能精确控制14. thread.allDone = true;15. &#125;16. &#125;17. 18. class MyThread implements Runnable &#123;19. boolean **volatile** allDone = false;20. 21. public void run() &#123;22. // 每次循环都检测标志23. // 如果设置停止标志时已经在循环里24. // 则最长需要等待一个循环的时间才能终止25. while (!allDone) &#123;26. // 循环里的工作27. &#125;28. &#125;29. &#125; 使用 volatile 标识的变量具有线程可见性。当一个线程修改了这个变量的值，其他线程立即可以知道。所以可以避免多CPU出问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[求二叉树的深度]]></title>
      <url>%2F2017%2F03%2F21%2F%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 # 思路 &emsp;&emsp;递归求解 # 代码 undefined &emsp;下面是一个跟上面类似的题目。 # 题目描述 &emsp;&emsp;判断一棵树是不是平衡二叉树。平衡二叉树指左右子树的高度不超过1的二叉树。思路很简单，直接贴代码。 代码12345678910111213141516171819202122232425262728293031/** * 判断一棵树是不是平衡二叉树 * * 思路：递归求左右子树的深度，比较判断是否是平衡二叉树 * * @author XIAO * */public class IsBalancedBinaryTree &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; if (root == null) &#123; return true; &#125; int left = getDepth(root.left); int right = getDepth(root.right); if (Math.abs(left - right) &gt; 1) &#123; return false; &#125; return true; &#125; // 递归求解二叉树的深度 private int getDepth(TreeNode node) &#123; if (node == null) &#123; return 0; &#125; int left = getDepth(node.left); int right = getDepth(node.right); return left &gt; right ? left + 1 : right + 1; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一个只出现一次的字符]]></title>
      <url>%2F2017%2F03%2F21%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置. 思路&emsp;&emsp;暴力求解。 代码1234567891011121314151617181920212223242526272829303132333435/** * 在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置 * * 思路：暴力求解 * * @author XIAO * */public class FirstNotRepeatingCharSolution &#123; public int FirstNotRepeatingChar(String str) &#123; if (str == null || str.length() == 0) &#123; return -1; &#125; // 用一个map记录每个字符出现的次数 HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); if (map.containsKey(c)) &#123; int times = map.get(c); times += 1; map.put(c, times); &#125; else &#123; map.put(c, 1); &#125; &#125; // 出现一次的字符 首次出现的索引 for (int i = 0; i &lt; str.length(); i++) &#123; char c2 = str.charAt(i); if (map.get(c2) == 1) &#123; return i; &#125; &#125; return -1; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第N个丑数]]></title>
      <url>%2F2017%2F03%2F20%2F%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路&emsp;&emsp;暴力求解思路。首先我们要搞清楚怎么求丑数。ugly[]表示丑数数组。 ugly[0]=1; ugly[1]=1*2; ugly[3]=1*3; ugly[4]=122; ugly[5]=1*5; ugly[6]=123; …&emsp;&emsp;是不是可以找出规律来，我们需要记录 丑数中因子 2,3,5 出现的次数。具体用语言不好描述，可以看出规律。代码1234567891011121314151617181920212223242526272829303132333435/** * 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 * 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 * * @author XIAO * */public class GetUglyNumber &#123; public int GetUglyNumber_Solution(int index) &#123; if (index &lt;= 0) &#123; return 0; &#125; int[] result = new int[index]; result[0] = 1; int i2 = 0, i3 = 0, i5 = 0;// i2,i3,i5分别记录丑数的因子中2,3,5的个数 for (int i = 1; i &lt; index; i++) &#123; result[i] = min(result[i2] * 2, min(result[i3] * 3, result[i5] * 5)); if (result[i] == result[i2] * 2) &#123; i2++; &#125; if (result[i] == result[i3] * 3) &#123; i3++; &#125; if (result[i] == result[i5] * 5) &#123; i5++; &#125; &#125; return result[index - 1]; &#125; private int min(int i, int j) &#123; return i &gt; j ? j : i; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[把数组排成最小的数]]></title>
      <url>%2F2017%2F03%2F20%2F%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路&emsp;&emsp;不得不说，看了这题的解法，真的佩服！~&emsp;&emsp;先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。为什么需要定制排序，因为字符串 a和b 长度不等的情况。比如 “2” 和 “21” ,显然字符串”2”&lt;”21”,但是把他们链接起来的时候 221&gt;212.所以定制一种规则来排除这种情况。定制排序规则如下： 若ab &gt; ba 则 a &gt; b， 若ab &lt; ba 则 a &lt; b，若ab = ba 则 a = b；这个定制排序很妙！ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 * 例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。 * * 思路：真的思路太强。 * * 先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。 排序规则如下： 若ab &gt; * ba 则 a &gt; b， 若ab &lt; ba 则 a &lt; b， 若ab = ba 则 a = b； 解释说明： * 比如 "3" &lt;"31" 但是 * "331" &gt; "313"，所以要将二者拼接起来进行比较 * * @author XIAO * */public class MinNumberArray &#123; public String PrintMinNumber(int[] numbers) &#123; if (numbers == null || numbers.length == 0) &#123; return ""; &#125; int length = numbers.length; String[] strings = new String[length]; // 把整型数转换成字符串 for (int i = 0; i &lt; strings.length; i++) &#123; strings[i] = String.valueOf(numbers[i]); &#125; // 对字符串数组进行排序 Arrays.sort(strings, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; String s1 = o1 + o2; String s2 = o2 + o1; return s1.compareTo(s2); &#125; &#125;); StringBuilder builder = new StringBuilder(); //把排序好的字符串拼接在一起 for (int i = 0; i &lt; strings.length; i++) &#123; builder.append(strings[i]); &#125; return builder.toString(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[连续子数组的最大和]]></title>
      <url>%2F2017%2F03%2F19%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 思路test]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo利用Github分支在不同电脑上写博客]]></title>
      <url>%2F2017%2F03%2F19%2FHexo%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;利用github的不同分支来分别保存网站静态文件与hexo源码（md原始文件及主题等），实现在不同电脑上都可以自由写博客。 Github Page&emsp;&emsp;这里假设你已经在github上建好了page的仓库，也就是 “yourusername.github.io”的名字的项目仓库，比如我的 dxjia.github.io 。另外，也假设你在自己的电脑上已经配置好git、hexo、node js等环境。 新建hexo分支&emsp;仓库建好之后，都是默认一个master分支的，Github page要求你的网站文件必须存放在这个master分支上，这个没得选；所以我们需要新建另外一个分支来保存我们的hexo原始文件；master 保存的全是public 文件夹下的内容，这也是 hexo发布到github上的内容，而hexo这个分支，保存的是我们网站的配置 。 如下图在红色输入框内写入新建的branch名hexo后，回车即可建立新的branch-hexo； 设置默认分支&emsp;&emsp;因为我们写博客更多的是更新这个分支，网站文件所在的master分支则由hexo d命令发布文章的时候进行推送，所以我们将hexo分支设置为默认分支，这样我们在新的电脑环境下git clone该仓库时，自动切到hexo`分支。按下图进行操作。 配置hexo deploy参数&emsp;&emsp;为了保证hexo d命令可以正确部署到master分支，在hexo 的配置文件 _config.yml文件中配置参数如下：1234deploy: type: git repo: https://github.com/dxjia/dxjia.github.io.git branch: master &emsp;&emsp;hexo 3.0之后 deploy type，将github改为了git，这样适用性更广了，如果你发现无法hexo d，使用下面的命令安装git deployer插件后重试即可。1npm install hexo-deployer-git --save 修改推送到hexo分支&emsp;&emsp;上一步的deploy参数正确配置后，文章写完使用hexo g -d命令就可以直接部署了，生成的博客静态文件会自动部署到 username.github.io仓库的master分支上，这时候通过浏览器访问http://username.github.io就可以看到你的博客页面里。 &emsp;&emsp;网站页面是保存了，但这时候我们还没有保存我们的hexo原始文件，包括我们的文章md文件，我们千辛万苦修改的主题配置等。。。接下来使用下面的步骤将他们都统统推送到hexo分支上去。其中目录下的.gitignore 表示哪些文件或文件夹不提交，根据自己需要配置。如果没有.git文件，先git init。123git add .git commit -m “change description”git push origin hexo 如果没关联远程仓库，执行第三步会出错。和远程仓库关联执行：git remote add origin &lt;远程仓库地址&gt;这样就OK了，我们的原始文件就都上去了，换电脑也不怕了。 日常写博客&emsp;&emsp;有时候我们可能会在不同的电脑上写博客，那在不同的电脑上配置 hexo、git、node.js，以及配置git ssh key等都要折腾一下的，这是免不了的，也是比wordpress等其他博客框架麻烦的一点。 已有环境&emsp;&emsp;如果在电脑上已经写过博客，那么可以在已有的工作目录下同步之前写的博客。在你的仓库目录下右键’git bash shell’，起来bash命令行，然后 1git pull 这样你的状态就更新了，之后就是 hexo命令写文章啦。。。写完hexo g -d部署好后，使用 123git add .git commit -m “change description”git push origin hexo 推送到hexo分支上去。 新的环境&emsp;&emsp;到了新的电脑上时，我们需要将项目先下载到本地，然后再进行hexo初始化。记住不需要hexo init指令12345git clone https://github.com/dxjia/dxjia.github.io.gitcd dxjia.github.ionpm install hexonpm installnpm install hexo-deployer-git –save 之后开始写博客，写好部署好之后，别忘记 git add , ….git push origin hexo…推上去。。。&emsp;&emsp;原文地址：http://dxjia.cn/2016/01/27/hexo-write-everywhere/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo提交新文章错误]]></title>
      <url>%2F2017%2F03%2F19%2Fhexo%E6%8F%90%E4%BA%A4%E6%96%B0%E6%96%87%E7%AB%A0%E9%94%99%E8%AF%AF%2F</url>
      <content type="text"><![CDATA[hexo提交新文章出错&emsp;&emsp;提交文章的时候报了下面这个错误，1234567891011121314151617181920212223ERROR Process failed: _posts/数组中出现次数超过一半的数字.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1: ^ at generateError (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\ js-yaml\loader.js:162:10) at throwError (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js- yaml\loader.js:168:9) at readBlockMapping (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\l ib\js-yaml\loader.js:1045:9) at composeNode (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js -yaml\loader.js:1331:12) at readDocument (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\j s-yaml\loader.js:1493:3) at loadDocuments (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\ js-yaml\loader.js:1549:5) at Object.load (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js -yaml\loader.js:1566:19) at parseYAML (F:\Myblog\hexo\node_modules\hexo\node_modules\hexo-front-matte r\lib\front_matter.js:80:21) at parse (F:\Myblog\hexo\node_modules\hexo\node_modules\hexo-front-matter\li b\front_matter.js:56:12) at F:\Myblog\hexo\node_modules\hexo\lib\plugins\processor\post.js:52:18 at tryCatcher (F:\Myblog\hexo\node_modules\hexo\node_modules\bluebird\js\rel ease\util.js:16:23) at Promise._settlePromiseFromHandler (F:\Myblog\hexo\node_modules\hexo\node_ modules\bluebird\js\release\promise.js:509:35) at Promise._settlePromise (F:\Myblog\hexo\node_modules\hexo\node_modules\blu ebird\js\release\promise.js:569:18) at Promise._settlePromise0 (F:\Myblog\hexo\node_modules\hexo\node_modules\bl uebird\js\release\promise.js:614:10) at Promise._settlePromises (F:\Myblog\hexo\node_modules\hexo\node_modules\bl uebird\js\release\promise.js:693:18) at Promise._fulfill (F:\Myblog\hexo\node_modules\hexo\node_modules\bluebird\ js\release\promise.js:638:18) at PromiseArray._resolve (F:\Myblog\hexo\node_modules\hexo\node_modules\blue bird\js\release\promise_array.js:126:19) at PromiseArray._promiseFulfilled (F:\Myblog\hexo\node_modules\hexo\node_mod ules\bluebird\js\release\promise_array.js:144:14) at PromiseArray._iterate (F:\Myblog\hexo\node_modules\hexo\node_modules\blue 仔细排查之后，发现是文章开头的categroies的冒号，写成了中文的冒号。额。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组中出现次数超过一半的数字]]></title>
      <url>%2F2017%2F03%2F19%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路&emsp;&emsp;对于这个问题提供两个解题思路。还有很多其他解法。 利用排序。先对数组进行排序，因为题目已知，有一个数字出现的次数超过了数组长度的一半。显然，排序完成之后中间的那个数组必定是这个数组。复杂度O(nlgn) 充分利用数组中有一个数字出现的次数超过数组长度的一半这个条件。这个数一定是相邻重复出现的次数最多的数。即使是最差情况，隔一个数插入这个数，最终这个数必定会出现在最后一位（还是因为出现次数大于数组长度的一半）。这个算法的复杂度只有O（n），不得不说，这个思路真的巧妙。代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。 * 由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 * * 思路1：快速排序 思路2：找最大相邻重复出现的元素 * * @author XIAO * */public class MoreThanHalfNumArray &#123; /** * 第一种思路 * * @param array * @return */ public int MoreThanHalfNum_Solution(int[] array) &#123; // 判断数组长度是否为0或者数组为null if (array.length == 0 || array == null) return 0; Arrays.sort(array);// 快速排序对数组进行排序 int mid = array[(array.length) / 2];// 中间的元素 // 对mid 进行验证 int count = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (mid == array[i]) &#123; count++; &#125; &#125; return count &gt; (array.length / 2) ? mid : 0; &#125; // 第二种思路，想了很久才想明白。关键是利用有一个数的出现次数大于数组长度的一半这个条件 public int MoreThanHalfNum_Solution2(int[] array) &#123; // 判断数组长度是否为0或者数组为null if (array.length == 0 || array == null) return 0; // 寻找相邻重复次数最多的元素 int temp = array[0];// 从第一个元素开始找 int times = 1;// 重复出现的次数 for (int i = 1; i &lt; array.length; i++) &#123; if (times == 0) &#123; temp = array[i];// 最后一次赋值的必定是我们要找的元素 times = 1; &#125; else if (array[i] == temp) &#123; times++; &#125; else &#123; times--; &#125; &#125; // 验证 int count = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] == temp) &#123; count++; &#125; &#125; return count &gt; (array.length / 2) ? temp : 0; &#125;&#125; 总结&emsp;&emsp;总体来看，第一种方法比较容易想到，时间复杂度较高。第二种方法想了很久才想明白，哎，算法能力有待提高！时间复杂度才O(N)!其他还有很多方法，有待考虑。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[按字典序输出一个字符串的全排序]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 思路&emsp;&emsp;大脑短路了，想明白这个竟然花了半小时。这个题目的核心其实是求解一个字符串的全排列。因为字典序只需要用Collection.sort()方法排序一个ArrayList 或者TreeSet就行了。&emsp;主要说下怎么对一个字符串进行全排列。比如说”abcd”怎么全排序呢?直觉告诉我们先把a放第一位，对”bcd”再进行全排列，就是一个递归。然后把b放在第一位，”acd”进行递归。…具体操作下面结合代码说。&emsp;下面就是对全排列的字符串进行排序操作，按字典序输出即可。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.ArrayList;import java.util.Collections;/** * 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串 * abc,acb,bac,bca,cab和cba。 * * 思路：先求解字符串的全排列，然后对这些全排列进行排序。 * * @author XIAO * */public class StringPermutationSort &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();// 保存全排列的结果 if (str != null &amp;&amp; str.length() &gt; 0) &#123;// 如果str不为空 Permutation(str.toCharArray(), 0, result);// 获取字符串的全排列 &#125; Collections.sort(result);// 对全排列的字符串进行排序 return result; &#125; /** * i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列 * * @param charArray * @param i * @param result */ private void Permutation(char[] charArray, int i, ArrayList&lt;String&gt; result) &#123; // 如果 i 是最后一个字符位置 if (i == charArray.length - 1) &#123; result.add(String.valueOf(charArray));// 找到一个全排序 &#125; else &#123; for (int j = i; j &lt;= charArray.length - 1; j++) &#123; if (j != i &amp;&amp; charArray[j] == charArray[i])// 有重复字符时，跳过 continue; swap(charArray, i, j); Permutation(charArray, i + 1, result); swap(charArray, i, j); &#125; &#125; &#125; // 交换字符数组s的第i个位置和第j个位置的字符 private void swap(char[] s, int i, int j) &#123; if (s[i] == s[j]) &#123; ; &#125; else &#123; char c = s[i]; s[i] = s[j]; s[j] = c; &#125; &#125;&#125; &emsp;&emsp;回头再看究竟是怎么全排列的吧。就是这个函数 private void Permutation(char[] charArray, int i, ArrayList result) 的递归过程。其中 i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列。当i == charArray.length - 1 时，表示已经到了最后一个字符，那么就找到了一个全排列。下面很好看懂，就是递归向下找，但是为什么要交换两次 charArray i和j 位置的字符呢？&emsp;&emsp;其实拿”abcd”来说，当我们交换 a和b 的位置（第一次交换），然后用b作为首字符寻找全排列。但是下次我们要交换 a和c 的位置，但是这时候 a和b 已经交换了，所以要把 a和b 换回来，才能保证每次交换的顺序没有乱。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二叉搜索树与双向链表]]></title>
      <url>%2F2017%2F03%2F18%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路&emsp;&emsp;使用递归的思想。步骤如下：&emsp;1. 将左子树构造成双链表，并返回链表头节点。&emsp;2. 定位至左子树双链表最后一个节点。&emsp;3. 如果左子树链表不为空的话，将当前root追加到左子树链表。&emsp;4. 将右子树构造成双链表，并返回链表头节点。&emsp;5. 如果右子树链表不为空的话，将该链表追加到root节点之后。&emsp;6. 根据左子树链表是否为空确定返回的节点。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142/** * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 * 思路：解题思路： 1.将左子树构造成双链表，并返回链表头节点。 2.定位至左子树双链表最后一个节点。 3.如果左子树链表不为空的话，将当前root追加到左子树链表。 4.将右子树构造成双链表，并返回链表头节点。 5.如果右子树链表不为空的话，将该链表追加到root节点之后。 6.根据左子树链表是否为空确定返回的节点。 * @author XIAO * */public class BinaryTreeLinkedList &#123; public TreeNode Convert(TreeNode root) &#123; if (root == null) &#123; return null; &#125; // 如果root的左右子树都为空 if (root.left == null &amp;&amp; root.right == null) &#123; return root; &#125; TreeNode left = Convert(root.left);// 把root节点的左子树转成链表，返回值为链表的头 TreeNode p = left; while (p != null &amp;&amp; p.right != null) &#123; p = p.right;// 循环定位到左子树双链表的最后一个节点 &#125; // 如果左子树链表不为空的话，将当前root追加到左子树链表 if (left != null) &#123; p.right = root;// 把root连接到左子树形成的双向链表中，双向链表，需要左右都连接 root.left = p; &#125; // 同样的，把根节点的右子树也形成双向链表，返回值为链表头 TreeNode right = Convert(root.right); // 把右子树的链表连接到上面的左子树和根节点的链表中 if (right != null) &#123; root.right = right;// 同样把右子树的链表连接上去 right.left = root; &#125; return left != null ? left : root; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二叉树中和为某一值的路径]]></title>
      <url>%2F2017%2F03%2F18%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 代码实现123456789101112131415public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null) return listAll; list.add(root.val); target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) listAll.add(new ArrayList&lt;Integer&gt;(list)); FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1);//返回父节点继续搜索 return listAll; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试字符串中是否包含重复字符]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%B5%8B%E8%AF%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;请实现一个算法，确定一个字符串的所有字符全都不同。要求不允许使用额外的存储空间。 思路&emsp;&emsp;暂时没想到好的思路，只能暴力求解。 代码实现12345678910public class StringRepeat &#123; // 暴力求解，双层循环，一一比较 public boolean checkDifferent(String iniString) &#123; for (int i = 0;i&lt;iniString.length();i++) &#123; for (int j = i+1;j&lt;iniString.length();j++) &#123; if (iniString.charAt(i) == iniString.charAt(j)) return false; &#125; &#125; return true;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F07%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
