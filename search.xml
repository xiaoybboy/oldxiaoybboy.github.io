<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[二叉搜索树与双向链表]]></title>
      <url>%2F2017%2F03%2F18%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路&emsp;&emsp;使用递归的思想。步骤如下：&emsp;1. 将左子树构造成双链表，并返回链表头节点。&emsp;2. 定位至左子树双链表最后一个节点。&emsp;3. 如果左子树链表不为空的话，将当前root追加到左子树链表。&emsp;4. 将右子树构造成双链表，并返回链表头节点。&emsp;5. 如果右子树链表不为空的话，将该链表追加到root节点之后。&emsp;6. 根据左子树链表是否为空确定返回的节点。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 * 思路：解题思路： 1.将左子树构造成双链表，并返回链表头节点。 2.定位至左子树双链表最后一个节点。 3.如果左子树链表不为空的话，将当前root追加到左子树链表。 4.将右子树构造成双链表，并返回链表头节点。 5.如果右子树链表不为空的话，将该链表追加到root节点之后。 6.根据左子树链表是否为空确定返回的节点。 * @author XIAO * */public class BinaryTreeLinkedList &#123; public TreeNode Convert(TreeNode root) &#123; if (root == null) &#123; return null; &#125; // 如果root的左右子树都为空 if (root.left == null &amp;&amp; root.right == null) &#123; return root; &#125; TreeNode left = Convert(root.left);// 把root节点的左子树转成链表，返回值为链表的头 TreeNode p = left; while (p != null &amp;&amp; p.right != null) &#123; p = p.right;// 循环定位到左子树双链表的最后一个节点 &#125; // 如果左子树链表不为空的话，将当前root追加到左子树链表 if (left != null) &#123; p.right = root;// 把root连接到左子树形成的双向链表中，双向链表，需要左右都连接 root.left = p; &#125; // 同样的，把根节点的右子树也形成双向链表，返回值为链表头 TreeNode right = Convert(root.right); // 把右子树的链表连接到上面的左子树和根节点的链表中 if (right != null) &#123; root.right = right;// 同样把右子树的链表连接上去 right.left = root; &#125; return left != null ? left : root; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二叉树中和为某一值的路径]]></title>
      <url>%2F2017%2F03%2F18%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 代码实现 123456789101112131415public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null) return listAll; list.add(root.val); target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) listAll.add(new ArrayList&lt;Integer&gt;(list)); FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1);//返回父节点继续搜索 return listAll; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试字符串中是否包含重复字符]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%B5%8B%E8%AF%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;请实现一个算法，确定一个字符串的所有字符全都不同。要求不允许使用额外的存储空间。 思路&emsp;&emsp;暂时没想到好的思路，只能暴力求解。 代码实现12345678910public class StringRepeat &#123; // 暴力求解，双层循环，一一比较 public boolean checkDifferent(String iniString) &#123; for (int i = 0;i&lt;iniString.length();i++) &#123; for (int j = i+1;j&lt;iniString.length();j++) &#123; if (iniString.charAt(i) == iniString.charAt(j)) return false; &#125; &#125; return true;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F07%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
