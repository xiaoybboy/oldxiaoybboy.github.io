<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[按字典序输出一个字符串的全排序]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 思路&emsp;&emsp;大脑短路了，想明白这个竟然花了半小时。这个题目的核心其实是求解一个字符串的全排列。因为字典序只需要用Collection.sort()方法排序一个ArrayList 或者TreeSet就行了。&emsp;主要说下怎么对一个字符串进行全排列。比如说”abcd”怎么全排序呢?直觉告诉我们先把a放第一位，对”bcd”再进行全排列，就是一个递归。然后把b放在第一位，”acd”进行递归。…具体操作下面结合代码说。&emsp;下面就是对全排列的字符串进行排序操作，按字典序输出即可。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.ArrayList;import java.util.Collections;/** * 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串 * abc,acb,bac,bca,cab和cba。 * * 思路：先求解字符串的全排列，然后对这些全排列进行排序。 * * @author XIAO * */public class StringPermutationSort &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();// 保存全排列的结果 if (str != null &amp;&amp; str.length() &gt; 0) &#123;// 如果str不为空 Permutation(str.toCharArray(), 0, result);// 获取字符串的全排列 &#125; Collections.sort(result);// 对全排列的字符串进行排序 return result; &#125; /** * i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列 * * @param charArray * @param i * @param result */ private void Permutation(char[] charArray, int i, ArrayList&lt;String&gt; result) &#123; // 如果 i 是最后一个字符位置 if (i == charArray.length - 1) &#123; result.add(String.valueOf(charArray));// 找到一个全排序 &#125; else &#123; for (int j = i; j &lt;= charArray.length - 1; j++) &#123; if (j != i &amp;&amp; charArray[j] == charArray[i])// 有重复字符时，跳过 continue; swap(charArray, i, j); Permutation(charArray, i + 1, result); swap(charArray, i, j); &#125; &#125; &#125; // 交换字符数组s的第i个位置和第j个位置的字符 private void swap(char[] s, int i, int j) &#123; if (s[i] == s[j]) &#123; ; &#125; else &#123; char c = s[i]; s[i] = s[j]; s[j] = c; &#125; &#125;&#125; &emsp;&emsp;回头再看究竟是怎么全排列的吧。就是这个函数 private void Permutation(char[] charArray, int i, ArrayList result) 的递归过程。其中 i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列。当i == charArray.length - 1 时，表示已经到了最后一个字符，那么就找到了一个全排列。下面很好看懂，就是递归向下找，但是为什么要交换两次 charArray i和j 位置的字符呢？&emsp;&emsp;其实拿”abcd”来说，当我们交换 a和b 的位置（第一次交换），然后用b作为首字符寻找全排列。但是下次我们要交换 a和c 的位置，但是这时候 a和b 已经交换了，所以要把 a和b 换回来，才能保证每次交换的顺序没有乱。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二叉搜索树与双向链表]]></title>
      <url>%2F2017%2F03%2F18%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路&emsp;&emsp;使用递归的思想。步骤如下：&emsp;1. 将左子树构造成双链表，并返回链表头节点。&emsp;2. 定位至左子树双链表最后一个节点。&emsp;3. 如果左子树链表不为空的话，将当前root追加到左子树链表。&emsp;4. 将右子树构造成双链表，并返回链表头节点。&emsp;5. 如果右子树链表不为空的话，将该链表追加到root节点之后。&emsp;6. 根据左子树链表是否为空确定返回的节点。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 * 思路：解题思路： 1.将左子树构造成双链表，并返回链表头节点。 2.定位至左子树双链表最后一个节点。 3.如果左子树链表不为空的话，将当前root追加到左子树链表。 4.将右子树构造成双链表，并返回链表头节点。 5.如果右子树链表不为空的话，将该链表追加到root节点之后。 6.根据左子树链表是否为空确定返回的节点。 * @author XIAO * */public class BinaryTreeLinkedList &#123; public TreeNode Convert(TreeNode root) &#123; if (root == null) &#123; return null; &#125; // 如果root的左右子树都为空 if (root.left == null &amp;&amp; root.right == null) &#123; return root; &#125; TreeNode left = Convert(root.left);// 把root节点的左子树转成链表，返回值为链表的头 TreeNode p = left; while (p != null &amp;&amp; p.right != null) &#123; p = p.right;// 循环定位到左子树双链表的最后一个节点 &#125; // 如果左子树链表不为空的话，将当前root追加到左子树链表 if (left != null) &#123; p.right = root;// 把root连接到左子树形成的双向链表中，双向链表，需要左右都连接 root.left = p; &#125; // 同样的，把根节点的右子树也形成双向链表，返回值为链表头 TreeNode right = Convert(root.right); // 把右子树的链表连接到上面的左子树和根节点的链表中 if (right != null) &#123; root.right = right;// 同样把右子树的链表连接上去 right.left = root; &#125; return left != null ? left : root; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二叉树中和为某一值的路径]]></title>
      <url>%2F2017%2F03%2F18%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 代码实现 123456789101112131415public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null) return listAll; list.add(root.val); target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) listAll.add(new ArrayList&lt;Integer&gt;(list)); FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1);//返回父节点继续搜索 return listAll; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试字符串中是否包含重复字符]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%B5%8B%E8%AF%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[题目描述&emsp;&emsp;请实现一个算法，确定一个字符串的所有字符全都不同。要求不允许使用额外的存储空间。 思路&emsp;&emsp;暂时没想到好的思路，只能暴力求解。 代码实现12345678910public class StringRepeat &#123; // 暴力求解，双层循环，一一比较 public boolean checkDifferent(String iniString) &#123; for (int i = 0;i&lt;iniString.length();i++) &#123; for (int j = i+1;j&lt;iniString.length();j++) &#123; if (iniString.charAt(i) == iniString.charAt(j)) return false; &#125; &#125; return true;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F07%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
